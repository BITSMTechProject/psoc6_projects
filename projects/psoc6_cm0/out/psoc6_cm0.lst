
out/psoc6_cm0.elf:     file format elf32-littlearm


Disassembly of section .text:

10000000 <__Vectors>:
10000000:	08002000 	.word	0x08002000
10000004:	10000a3f 	.word	0x10000a3f
10000008:	0000000d 	.word	0x0000000d
1000000c:	10000aa1 	.word	0x10000aa1
	...
1000002c:	10000a9d 	.word	0x10000a9d
	...
10000038:	10000a9d 	.word	0x10000a9d
1000003c:	10000a9d 	.word	0x10000a9d
10000040:	10000a9d 	.word	0x10000a9d
10000044:	10000a9d 	.word	0x10000a9d
10000048:	10000a9d 	.word	0x10000a9d
1000004c:	10000a9d 	.word	0x10000a9d
10000050:	10000a9d 	.word	0x10000a9d
10000054:	10000a9d 	.word	0x10000a9d
10000058:	10000a9d 	.word	0x10000a9d
1000005c:	10000a9d 	.word	0x10000a9d
10000060:	10000a9d 	.word	0x10000a9d
10000064:	10000a9d 	.word	0x10000a9d
10000068:	10000a9d 	.word	0x10000a9d
1000006c:	10000a9d 	.word	0x10000a9d
10000070:	10000a9d 	.word	0x10000a9d
10000074:	10000a9d 	.word	0x10000a9d
10000078:	10000a9d 	.word	0x10000a9d
1000007c:	10000a9d 	.word	0x10000a9d

10000080 <__do_global_dtors_aux>:
10000080:	b510      	push	{r4, lr}
10000082:	4c05      	ldr	r4, [pc, #20]	; (10000098 <__do_global_dtors_aux+0x18>)
10000084:	7823      	ldrb	r3, [r4, #0]
10000086:	b933      	cbnz	r3, 10000096 <__do_global_dtors_aux+0x16>
10000088:	4b04      	ldr	r3, [pc, #16]	; (1000009c <__do_global_dtors_aux+0x1c>)
1000008a:	b113      	cbz	r3, 10000092 <__do_global_dtors_aux+0x12>
1000008c:	4804      	ldr	r0, [pc, #16]	; (100000a0 <__do_global_dtors_aux+0x20>)
1000008e:	f3af 8000 	nop.w
10000092:	2301      	movs	r3, #1
10000094:	7023      	strb	r3, [r4, #0]
10000096:	bd10      	pop	{r4, pc}
10000098:	08000184 	.word	0x08000184
1000009c:	00000000 	.word	0x00000000
100000a0:	100012e0 	.word	0x100012e0

100000a4 <frame_dummy>:
100000a4:	b508      	push	{r3, lr}
100000a6:	4b03      	ldr	r3, [pc, #12]	; (100000b4 <frame_dummy+0x10>)
100000a8:	b11b      	cbz	r3, 100000b2 <frame_dummy+0xe>
100000aa:	4903      	ldr	r1, [pc, #12]	; (100000b8 <frame_dummy+0x14>)
100000ac:	4803      	ldr	r0, [pc, #12]	; (100000bc <frame_dummy+0x18>)
100000ae:	f3af 8000 	nop.w
100000b2:	bd08      	pop	{r3, pc}
100000b4:	00000000 	.word	0x00000000
100000b8:	08000188 	.word	0x08000188
100000bc:	100012e0 	.word	0x100012e0

100000c0 <Cy_PDL_Init>:
* This function must be called prior calling any function in PDL.
*
*******************************************************************************/
void Cy_PDL_Init(const cy_stc_device_t * device)
{
    cy_device = device;
100000c0:	4b01      	ldr	r3, [pc, #4]	; (100000c8 <Cy_PDL_Init+0x8>)
100000c2:	6018      	str	r0, [r3, #0]
}
100000c4:	4770      	bx	lr
100000c6:	bf00      	nop
100000c8:	080001a0 	.word	0x080001a0

100000cc <Cy_IPC_Pipe_Config>:
*
*******************************************************************************/
void Cy_IPC_Pipe_Config(cy_stc_ipc_pipe_ep_t * theEpArray)
{
    /* Keep copy of this endpoint */
    if (cy_ipc_pipe_epArray == NULL)
100000cc:	4b03      	ldr	r3, [pc, #12]	; (100000dc <Cy_IPC_Pipe_Config+0x10>)
100000ce:	681b      	ldr	r3, [r3, #0]
100000d0:	b103      	cbz	r3, 100000d4 <Cy_IPC_Pipe_Config+0x8>
    {
        cy_ipc_pipe_epArray = theEpArray;
    }
}
100000d2:	4770      	bx	lr
        cy_ipc_pipe_epArray = theEpArray;
100000d4:	4b01      	ldr	r3, [pc, #4]	; (100000dc <Cy_IPC_Pipe_Config+0x10>)
100000d6:	6018      	str	r0, [r3, #0]
}
100000d8:	e7fb      	b.n	100000d2 <Cy_IPC_Pipe_Config+0x6>
100000da:	bf00      	nop
100000dc:	080001a4 	.word	0x080001a4

100000e0 <Cy_IPC_Pipe_EndpointInit>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Pipe_EndpointInit
*
*******************************************************************************/
void Cy_IPC_Pipe_EndpointInit(uint32_t epAddr, cy_ipc_pipe_callback_array_ptr_t cbArray,
                              uint32_t cbCnt, uint32_t epConfig, cy_stc_sysint_t const *epInterrupt)
{
100000e0:	b4f0      	push	{r4, r5, r6, r7}
100000e2:	9d04      	ldr	r5, [sp, #16]
    cy_stc_ipc_pipe_ep_t * endpoint;

    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
100000e4:	4c23      	ldr	r4, [pc, #140]	; (10000174 <Cy_IPC_Pipe_EndpointInit+0x94>)
100000e6:	6824      	ldr	r4, [r4, #0]
100000e8:	2c00      	cmp	r4, #0
100000ea:	d040      	beq.n	1000016e <Cy_IPC_Pipe_EndpointInit+0x8e>

    endpoint = &cy_ipc_pipe_epArray[epAddr];
100000ec:	4c21      	ldr	r4, [pc, #132]	; (10000174 <Cy_IPC_Pipe_EndpointInit+0x94>)
100000ee:	6827      	ldr	r7, [r4, #0]
100000f0:	242c      	movs	r4, #44	; 0x2c
100000f2:	fb00 f404 	mul.w	r4, r0, r4
100000f6:	1938      	adds	r0, r7, r4

    /* Extract the channel, interrupt and interrupt mask */
    endpoint->ipcChan         = _FLD2VAL(CY_IPC_PIPE_CFG_CHAN,  epConfig);
100000f8:	b2de      	uxtb	r6, r3
100000fa:	513e      	str	r6, [r7, r4]
    endpoint->intrChan        = _FLD2VAL(CY_IPC_PIPE_CFG_INTR,  epConfig);
100000fc:	f3c3 2407 	ubfx	r4, r3, #8, #8
10000100:	6044      	str	r4, [r0, #4]
    endpoint->pipeIntMask     = _FLD2VAL(CY_IPC_PIPE_CFG_IMASK, epConfig);
10000102:	0c1b      	lsrs	r3, r3, #16
10000104:	6083      	str	r3, [r0, #8]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_SendMsgWord
*
*******************************************************************************/
__STATIC_INLINE IPC_STRUCT_Type* Cy_IPC_Drv_GetIpcBaseAddress (uint32_t ipcIndex)
{
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000106:	4b1c      	ldr	r3, [pc, #112]	; (10000178 <Cy_IPC_Pipe_EndpointInit+0x98>)
10000108:	681b      	ldr	r3, [r3, #0]
1000010a:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
1000010e:	429e      	cmp	r6, r3
10000110:	d300      	bcc.n	10000114 <Cy_IPC_Pipe_EndpointInit+0x34>

/** Halt the processor in the debug state
 */
static inline void CY_HALT(void)
{
    __asm("    bkpt    1");
10000112:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10000114:	4b18      	ldr	r3, [pc, #96]	; (10000178 <Cy_IPC_Pipe_EndpointInit+0x98>)
10000116:	681b      	ldr	r3, [r3, #0]
10000118:	6a1c      	ldr	r4, [r3, #32]
1000011a:	f8b3 70ba 	ldrh.w	r7, [r3, #186]	; 0xba
1000011e:	fb07 4406 	mla	r4, r7, r6, r4

    /* Assign IPC channel to this endpoint */
    endpoint->ipcPtr   = Cy_IPC_Drv_GetIpcBaseAddress (endpoint->ipcChan);
10000122:	6104      	str	r4, [r0, #16]

    /* Assign interrupt structure to endpoint and Initialize the interrupt mask for this endpoint */
    endpoint->ipcIntrPtr = Cy_IPC_Drv_GetIntrBaseAddr(endpoint->intrChan);
10000124:	6844      	ldr	r4, [r0, #4]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_GetInterruptStatus
*
*******************************************************************************/
__STATIC_INLINE IPC_INTR_STRUCT_Type* Cy_IPC_Drv_GetIntrBaseAddr (uint32_t ipcIntrIndex)
{
    CY_ASSERT_L1(CY_IPC_INTERRUPTS > ipcIntrIndex);
10000126:	f893 3034 	ldrb.w	r3, [r3, #52]	; 0x34
1000012a:	429c      	cmp	r4, r3
1000012c:	d300      	bcc.n	10000130 <Cy_IPC_Pipe_EndpointInit+0x50>
1000012e:	be01      	bkpt	0x0001
    return ( (IPC_INTR_STRUCT_Type*) CY_IPC_INTR_STRUCT_PTR(ipcIntrIndex));
10000130:	4b11      	ldr	r3, [pc, #68]	; (10000178 <Cy_IPC_Pipe_EndpointInit+0x98>)
10000132:	681b      	ldr	r3, [r3, #0]
10000134:	6a1b      	ldr	r3, [r3, #32]
10000136:	3480      	adds	r4, #128	; 0x80
10000138:	eb03 1344 	add.w	r3, r3, r4, lsl #5
1000013c:	6143      	str	r3, [r0, #20]

    /* Only allow notify and release interrupts from endpoints in this pipe. */
    Cy_IPC_Drv_SetInterruptMask(endpoint->ipcIntrPtr, endpoint->pipeIntMask, endpoint->pipeIntMask);
1000013e:	6884      	ldr	r4, [r0, #8]
*
*******************************************************************************/
__STATIC_INLINE void  Cy_IPC_Drv_SetInterruptMask (IPC_INTR_STRUCT_Type* base,
                                              uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)
{
    CY_ASSERT_L1(0UL == (ipcAcquireMask & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
10000140:	0c26      	lsrs	r6, r4, #16
10000142:	0436      	lsls	r6, r6, #16
10000144:	b106      	cbz	r6, 10000148 <Cy_IPC_Pipe_EndpointInit+0x68>
10000146:	be01      	bkpt	0x0001
    CY_ASSERT_L1(0UL == (ipcReleaseMask & ~(uint32_t)(IPC_STRUCT_RELEASE_INTR_RELEASE_Msk)));
10000148:	0c26      	lsrs	r6, r4, #16
1000014a:	0436      	lsls	r6, r6, #16
1000014c:	b106      	cbz	r6, 10000150 <Cy_IPC_Pipe_EndpointInit+0x70>
1000014e:	be01      	bkpt	0x0001
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
                      _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_RELEASE, ipcReleaseMask);
10000150:	fa1f fc84 	uxth.w	ip, r4
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
10000154:	ea4c 4404 	orr.w	r4, ip, r4, lsl #16
10000158:	609c      	str	r4, [r3, #8]

    /* Save the Client count and the callback array pointer */
    endpoint->clientCount   = cbCnt;
1000015a:	61c2      	str	r2, [r0, #28]
    endpoint->callbackArray = cbArray;
1000015c:	6201      	str	r1, [r0, #32]
    endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
1000015e:	2300      	movs	r3, #0
10000160:	6183      	str	r3, [r0, #24]

    if (NULL != epInterrupt)
10000162:	b115      	cbz	r5, 1000016a <Cy_IPC_Pipe_EndpointInit+0x8a>
    {
        endpoint->pipeIntrSrc     = epInterrupt->intrSrc;
10000164:	f9b5 3000 	ldrsh.w	r3, [r5]
10000168:	8183      	strh	r3, [r0, #12]
    }
}
1000016a:	bcf0      	pop	{r4, r5, r6, r7}
1000016c:	4770      	bx	lr
1000016e:	be01      	bkpt	0x0001
}
10000170:	e7bc      	b.n	100000ec <Cy_IPC_Pipe_EndpointInit+0xc>
10000172:	bf00      	nop
10000174:	080001a4 	.word	0x080001a4
10000178:	080001a0 	.word	0x080001a0

1000017c <Cy_IPC_Pipe_Init>:
{
1000017c:	b530      	push	{r4, r5, lr}
1000017e:	b08f      	sub	sp, #60	; 0x3c
    CY_ASSERT_L1(NULL != config);
10000180:	4604      	mov	r4, r0
10000182:	2800      	cmp	r0, #0
10000184:	d047      	beq.n	10000216 <Cy_IPC_Pipe_Init+0x9a>
    CY_ASSERT_L2((uint32_t)(1UL << __NVIC_PRIO_BITS) > config->ep1ConfigData.ipcNotifierPriority);
10000186:	69a3      	ldr	r3, [r4, #24]
10000188:	2b07      	cmp	r3, #7
1000018a:	d900      	bls.n	1000018e <Cy_IPC_Pipe_Init+0x12>
    __asm("    bkpt    1");
1000018c:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != config->endpointsCallbacksArray);
1000018e:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10000190:	2b00      	cmp	r3, #0
10000192:	d042      	beq.n	1000021a <Cy_IPC_Pipe_Init+0x9e>
    CY_ASSERT_L1(NULL != config->userPipeIsrHandler);
10000194:	6b23      	ldr	r3, [r4, #48]	; 0x30
10000196:	2b00      	cmp	r3, #0
10000198:	d041      	beq.n	1000021e <Cy_IPC_Pipe_Init+0xa2>
    epConfigDataA = config->ep1ConfigData;
1000019a:	f10d 0c1c 	add.w	ip, sp, #28
1000019e:	f104 0e14 	add.w	lr, r4, #20
100001a2:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
100001a6:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
100001aa:	f8de 3000 	ldr.w	r3, [lr]
100001ae:	f8cc 3000 	str.w	r3, [ip]
    epConfigDataB = config->ep0ConfigData;
100001b2:	f10d 0c08 	add.w	ip, sp, #8
100001b6:	46a6      	mov	lr, r4
100001b8:	e8be 000f 	ldmia.w	lr!, {r0, r1, r2, r3}
100001bc:	e8ac 000f 	stmia.w	ip!, {r0, r1, r2, r3}
100001c0:	f8de 3000 	ldr.w	r3, [lr]
100001c4:	f8cc 3000 	str.w	r3, [ip]
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)((int32_t)cpuss_interrupts_ipc_0_IRQn + (int32_t)epConfigDataA.ipcNotifierNumber);
100001c8:	9b07      	ldr	r3, [sp, #28]
100001ca:	3317      	adds	r3, #23
100001cc:	f8ad 3030 	strh.w	r3, [sp, #48]	; 0x30
    ipc_intr_cypipeConfig.intrPriority     = epConfigDataA.ipcNotifierPriority;
100001d0:	9b08      	ldr	r3, [sp, #32]
100001d2:	930d      	str	r3, [sp, #52]	; 0x34
    Cy_IPC_Pipe_EndpointInit(epConfigDataA.epAddress,
100001d4:	ad0c      	add	r5, sp, #48	; 0x30
100001d6:	9500      	str	r5, [sp, #0]
100001d8:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
100001da:	6aa2      	ldr	r2, [r4, #40]	; 0x28
100001dc:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
100001de:	980a      	ldr	r0, [sp, #40]	; 0x28
100001e0:	f7ff ff7e 	bl	100000e0 <Cy_IPC_Pipe_EndpointInit>
    Cy_IPC_Pipe_EndpointInit(epConfigDataB.epAddress, NULL, 0UL, epConfigDataB.epConfig, NULL);
100001e4:	2100      	movs	r1, #0
100001e6:	9100      	str	r1, [sp, #0]
100001e8:	9b06      	ldr	r3, [sp, #24]
100001ea:	460a      	mov	r2, r1
100001ec:	9805      	ldr	r0, [sp, #20]
100001ee:	f7ff ff77 	bl	100000e0 <Cy_IPC_Pipe_EndpointInit>
    (void)Cy_SysInt_Init(&ipc_intr_cypipeConfig, config->userPipeIsrHandler);
100001f2:	6b21      	ldr	r1, [r4, #48]	; 0x30
100001f4:	4628      	mov	r0, r5
100001f6:	f000 f955 	bl	100004a4 <Cy_SysInt_Init>
    NVIC_EnableIRQ(ipc_intr_cypipeConfig.intrSrc);
100001fa:	f9bd 3030 	ldrsh.w	r3, [sp, #48]	; 0x30
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
100001fe:	2b00      	cmp	r3, #0
10000200:	db07      	blt.n	10000212 <Cy_IPC_Pipe_Init+0x96>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[(((uint32_t)IRQn) >> 5UL)] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
10000202:	f003 011f 	and.w	r1, r3, #31
10000206:	095b      	lsrs	r3, r3, #5
10000208:	2201      	movs	r2, #1
1000020a:	408a      	lsls	r2, r1
1000020c:	4905      	ldr	r1, [pc, #20]	; (10000224 <Cy_IPC_Pipe_Init+0xa8>)
1000020e:	f841 2023 	str.w	r2, [r1, r3, lsl #2]
}
10000212:	b00f      	add	sp, #60	; 0x3c
10000214:	bd30      	pop	{r4, r5, pc}
10000216:	be01      	bkpt	0x0001
}
10000218:	e7b5      	b.n	10000186 <Cy_IPC_Pipe_Init+0xa>
    __asm("    bkpt    1");
1000021a:	be01      	bkpt	0x0001
}
1000021c:	e7ba      	b.n	10000194 <Cy_IPC_Pipe_Init+0x18>
    __asm("    bkpt    1");
1000021e:	be01      	bkpt	0x0001
}
10000220:	e7bb      	b.n	1000019a <Cy_IPC_Pipe_Init+0x1e>
10000222:	bf00      	nop
10000224:	e000e100 	.word	0xe000e100

10000228 <Cy_IPC_Pipe_ExecCallback>:
* \note This function is obsolete and will be removed in the next releases.
*       Please use Cy_IPC_Pipe_ExecuteCallback() instead.
*
*******************************************************************************/
void Cy_IPC_Pipe_ExecCallback(cy_stc_ipc_pipe_ep_t * endpoint)
{
10000228:	b570      	push	{r4, r5, r6, lr}
1000022a:	b082      	sub	sp, #8
    uint32_t *msgPtr = NULL;
1000022c:	2300      	movs	r3, #0
1000022e:	9301      	str	r3, [sp, #4]
    uint32_t releaseMask = (uint32_t)0;

    cy_ipc_pipe_callback_ptr_t callbackPtr;

    /* Parameters checking begin */
    CY_ASSERT_L1(NULL != endpoint);
10000230:	4604      	mov	r4, r0
10000232:	b328      	cbz	r0, 10000280 <Cy_IPC_Pipe_ExecCallback+0x58>
    CY_ASSERT_L1(NULL != endpoint->ipcPtr);
10000234:	6923      	ldr	r3, [r4, #16]
10000236:	b32b      	cbz	r3, 10000284 <Cy_IPC_Pipe_ExecCallback+0x5c>
    CY_ASSERT_L1(NULL != endpoint->ipcIntrPtr);
10000238:	6963      	ldr	r3, [r4, #20]
1000023a:	b32b      	cbz	r3, 10000288 <Cy_IPC_Pipe_ExecCallback+0x60>
    CY_ASSERT_L1(NULL != endpoint->callbackArray);
1000023c:	6a23      	ldr	r3, [r4, #32]
1000023e:	b32b      	cbz	r3, 1000028c <Cy_IPC_Pipe_ExecCallback+0x64>
    /* Parameters checking end */

    shadowIntr = Cy_IPC_Drv_GetInterruptStatusMasked(endpoint->ipcIntrPtr);
10000240:	6963      	ldr	r3, [r4, #20]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_GetInterruptStatusMasked
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_IPC_Drv_GetInterruptStatusMasked (IPC_INTR_STRUCT_Type const * base)
{
    return REG_IPC_INTR_STRUCT_INTR_MASKED(base);
10000242:	68dd      	ldr	r5, [r3, #12]

    /* Check to make sure the interrupt was a notify interrupt */
    if (0UL != Cy_IPC_Drv_ExtractAcquireMask(shadowIntr))
10000244:	0c2a      	lsrs	r2, r5, #16
10000246:	d00b      	beq.n	10000260 <Cy_IPC_Pipe_ExecCallback+0x38>
*******************************************************************************/
__STATIC_INLINE void  Cy_IPC_Drv_ClearInterrupt(IPC_INTR_STRUCT_Type* base, uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)
{
    CY_ASSERT_L1(0UL == (ipcAcquireMask  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
    CY_ASSERT_L1(0UL == (ipcReleaseMask & ~(uint32_t)(IPC_STRUCT_RELEASE_INTR_RELEASE_Msk)));
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
10000248:	0c2a      	lsrs	r2, r5, #16
1000024a:	0412      	lsls	r2, r2, #16
1000024c:	601a      	str	r2, [r3, #0]
                  _VAL2FLD(IPC_INTR_STRUCT_INTR_RELEASE, ipcReleaseMask);
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
1000024e:	681b      	ldr	r3, [r3, #0]
    {
        /* Clear the notify interrupt.  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, CY_IPC_NO_NOTIFICATION, Cy_IPC_Drv_ExtractAcquireMask(shadowIntr));

        if ( Cy_IPC_Drv_IsLockAcquired (endpoint->ipcPtr) )
10000250:	6920      	ldr	r0, [r4, #16]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_LockAcquire
*
*******************************************************************************/
__STATIC_INLINE bool Cy_IPC_Drv_IsLockAcquired (IPC_STRUCT_Type const * base)
{
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
10000252:	4b1d      	ldr	r3, [pc, #116]	; (100002c8 <Cy_IPC_Pipe_ExecCallback+0xa0>)
10000254:	681b      	ldr	r3, [r3, #0]
10000256:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
1000025a:	581b      	ldr	r3, [r3, r0]
1000025c:	2b00      	cmp	r3, #0
1000025e:	db17      	blt.n	10000290 <Cy_IPC_Pipe_ExecCallback+0x68>
* Release mask value.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_IPC_Drv_ExtractReleaseMask (uint32_t intMask)
{
    return _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intMask);
10000260:	b2ad      	uxth	r5, r5
            (void)Cy_IPC_Drv_LockRelease (endpoint->ipcPtr, releaseMask);
        }
    }

    /* Check to make sure the interrupt was a release interrupt */
    if (0UL != Cy_IPC_Drv_ExtractReleaseMask(shadowIntr))  /* Check for a Release interrupt */
10000262:	b14d      	cbz	r5, 10000278 <Cy_IPC_Pipe_ExecCallback+0x50>
    {
        /* Clear the release interrupt  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, Cy_IPC_Drv_ExtractReleaseMask(shadowIntr), CY_IPC_NO_NOTIFICATION);
10000264:	6963      	ldr	r3, [r4, #20]
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
10000266:	601d      	str	r5, [r3, #0]
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
10000268:	681b      	ldr	r3, [r3, #0]

        if (endpoint->releaseCallbackPtr != NULL)
1000026a:	6a63      	ldr	r3, [r4, #36]	; 0x24
1000026c:	b33b      	cbz	r3, 100002be <Cy_IPC_Pipe_ExecCallback+0x96>
        {
            endpoint->releaseCallbackPtr();
1000026e:	4798      	blx	r3

            /* Clear the pointer after it was called */
            endpoint->releaseCallbackPtr = NULL;
10000270:	2300      	movs	r3, #0
10000272:	6263      	str	r3, [r4, #36]	; 0x24
                endpoint->defaultReleaseCallbackPtr();
            }
        }

        /* Clear the busy flag when release is detected */
        endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
10000274:	2300      	movs	r3, #0
10000276:	61a3      	str	r3, [r4, #24]
    }

    (void)Cy_IPC_Drv_GetInterruptStatus(endpoint->ipcIntrPtr);
10000278:	6963      	ldr	r3, [r4, #20]
    return REG_IPC_INTR_STRUCT_INTR(base);
1000027a:	681b      	ldr	r3, [r3, #0]
}
1000027c:	b002      	add	sp, #8
1000027e:	bd70      	pop	{r4, r5, r6, pc}
    __asm("    bkpt    1");
10000280:	be01      	bkpt	0x0001
}
10000282:	e7d7      	b.n	10000234 <Cy_IPC_Pipe_ExecCallback+0xc>
    __asm("    bkpt    1");
10000284:	be01      	bkpt	0x0001
}
10000286:	e7d7      	b.n	10000238 <Cy_IPC_Pipe_ExecCallback+0x10>
    __asm("    bkpt    1");
10000288:	be01      	bkpt	0x0001
}
1000028a:	e7d7      	b.n	1000023c <Cy_IPC_Pipe_ExecCallback+0x14>
    __asm("    bkpt    1");
1000028c:	be01      	bkpt	0x0001
}
1000028e:	e7d7      	b.n	10000240 <Cy_IPC_Pipe_ExecCallback+0x18>
*
*******************************************************************************/
__STATIC_INLINE  cy_en_ipcdrv_status_t  Cy_IPC_Drv_ReadMsgPtr (IPC_STRUCT_Type const * base, void ** msgPtr)
{
    CY_ASSERT_L1(NULL != msgPtr);
    return Cy_IPC_Drv_ReadMsgWord(base, (uint32_t *)msgPtr);
10000290:	a901      	add	r1, sp, #4
10000292:	f000 f851 	bl	10000338 <Cy_IPC_Drv_ReadMsgWord>
            if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_ReadMsgPtr (endpoint->ipcPtr, (void **)&msgPtr))
10000296:	b960      	cbnz	r0, 100002b2 <Cy_IPC_Pipe_ExecCallback+0x8a>
                releaseMask = _FLD2VAL(CY_IPC_PIPE_MSG_RELEASE, *msgPtr);
10000298:	9801      	ldr	r0, [sp, #4]
1000029a:	6803      	ldr	r3, [r0, #0]
1000029c:	0c1e      	lsrs	r6, r3, #16
                clientID    = _FLD2VAL(CY_IPC_PIPE_MSG_CLIENT,  *msgPtr);
1000029e:	b2db      	uxtb	r3, r3
                if (endpoint->clientCount > clientID)
100002a0:	69e2      	ldr	r2, [r4, #28]
100002a2:	429a      	cmp	r2, r3
100002a4:	d906      	bls.n	100002b4 <Cy_IPC_Pipe_ExecCallback+0x8c>
                    callbackPtr = endpoint->callbackArray[clientID];  /* Get the callback function */
100002a6:	6a22      	ldr	r2, [r4, #32]
100002a8:	f852 3023 	ldr.w	r3, [r2, r3, lsl #2]
                    if (callbackPtr != NULL)
100002ac:	b113      	cbz	r3, 100002b4 <Cy_IPC_Pipe_ExecCallback+0x8c>
                        callbackPtr(msgPtr);   /* Call the function pointer for "clientID" */
100002ae:	4798      	blx	r3
100002b0:	e000      	b.n	100002b4 <Cy_IPC_Pipe_ExecCallback+0x8c>
    uint32_t releaseMask = (uint32_t)0;
100002b2:	2600      	movs	r6, #0
            (void)Cy_IPC_Drv_LockRelease (endpoint->ipcPtr, releaseMask);
100002b4:	4631      	mov	r1, r6
100002b6:	6920      	ldr	r0, [r4, #16]
100002b8:	f000 f818 	bl	100002ec <Cy_IPC_Drv_LockRelease>
100002bc:	e7d0      	b.n	10000260 <Cy_IPC_Pipe_ExecCallback+0x38>
            if (endpoint->defaultReleaseCallbackPtr != NULL)
100002be:	6aa3      	ldr	r3, [r4, #40]	; 0x28
100002c0:	2b00      	cmp	r3, #0
100002c2:	d0d7      	beq.n	10000274 <Cy_IPC_Pipe_ExecCallback+0x4c>
                endpoint->defaultReleaseCallbackPtr();
100002c4:	4798      	blx	r3
100002c6:	e7d5      	b.n	10000274 <Cy_IPC_Pipe_ExecCallback+0x4c>
100002c8:	080001a0 	.word	0x080001a0

100002cc <Cy_IPC_Pipe_ExecuteCallback>:
{
100002cc:	b508      	push	{r3, lr}
    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
100002ce:	4b06      	ldr	r3, [pc, #24]	; (100002e8 <Cy_IPC_Pipe_ExecuteCallback+0x1c>)
100002d0:	681b      	ldr	r3, [r3, #0]
100002d2:	b13b      	cbz	r3, 100002e4 <Cy_IPC_Pipe_ExecuteCallback+0x18>
    endpoint = &cy_ipc_pipe_epArray[epAddr];
100002d4:	4b04      	ldr	r3, [pc, #16]	; (100002e8 <Cy_IPC_Pipe_ExecuteCallback+0x1c>)
100002d6:	681b      	ldr	r3, [r3, #0]
    Cy_IPC_Pipe_ExecCallback(endpoint);
100002d8:	222c      	movs	r2, #44	; 0x2c
100002da:	fb02 3000 	mla	r0, r2, r0, r3
100002de:	f7ff ffa3 	bl	10000228 <Cy_IPC_Pipe_ExecCallback>
}
100002e2:	bd08      	pop	{r3, pc}
    __asm("    bkpt    1");
100002e4:	be01      	bkpt	0x0001
}
100002e6:	e7f5      	b.n	100002d4 <Cy_IPC_Pipe_ExecuteCallback+0x8>
100002e8:	080001a4 	.word	0x080001a4

100002ec <Cy_IPC_Drv_LockRelease>:
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
100002ec:	4b08      	ldr	r3, [pc, #32]	; (10000310 <Cy_IPC_Drv_LockRelease+0x24>)
100002ee:	681b      	ldr	r3, [r3, #0]
100002f0:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
100002f4:	581b      	ldr	r3, [r3, r0]
cy_en_ipcdrv_status_t Cy_IPC_Drv_LockRelease (IPC_STRUCT_Type* base, uint32_t releaseEventIntr)
{
    cy_en_ipcdrv_status_t retStatus;

    /* Check to make sure the IPC is Acquired */
    if( Cy_IPC_Drv_IsLockAcquired(base) )
100002f6:	2b00      	cmp	r3, #0
100002f8:	da07      	bge.n	1000030a <Cy_IPC_Drv_LockRelease+0x1e>
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_INTR_STRUCT_INTR_RELEASE_Msk)));
100002fa:	0c0b      	lsrs	r3, r1, #16
100002fc:	041b      	lsls	r3, r3, #16
100002fe:	b103      	cbz	r3, 10000302 <Cy_IPC_Drv_LockRelease+0x16>
    __asm("    bkpt    1");
10000300:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_RELEASE(base) = _VAL2FLD(IPC_INTR_STRUCT_INTR_RELEASE, notifyEventIntr);
10000302:	b289      	uxth	r1, r1
10000304:	6041      	str	r1, [r0, #4]
    {
        /* The IPC was acquired, release the IPC channel */
        Cy_IPC_Drv_ReleaseNotify(base, releaseEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
10000306:	2000      	movs	r0, #0
10000308:	4770      	bx	lr
    }
    else   /* The IPC channel was already released (not acquired) */
    {
        retStatus = CY_IPC_DRV_ERROR;
1000030a:	4802      	ldr	r0, [pc, #8]	; (10000314 <Cy_IPC_Drv_LockRelease+0x28>)
    }

    return (retStatus);
}
1000030c:	4770      	bx	lr
1000030e:	bf00      	nop
10000310:	080001a0 	.word	0x080001a0
10000314:	008a0001 	.word	0x008a0001

10000318 <Cy_IPC_Drv_SendMsgWord>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_LockAcquire
*
*******************************************************************************/
__STATIC_INLINE cy_en_ipcdrv_status_t Cy_IPC_Drv_LockAcquire (IPC_STRUCT_Type const * base)
{
    return ( 0UL != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(base))) ? CY_IPC_DRV_SUCCESS : CY_IPC_DRV_ERROR;
10000318:	6803      	ldr	r3, [r0, #0]
1000031a:	2b00      	cmp	r3, #0
1000031c:	da08      	bge.n	10000330 <Cy_IPC_Drv_SendMsgWord+0x18>
    REG_IPC_STRUCT_DATA(base) = dataValue;
1000031e:	60c2      	str	r2, [r0, #12]
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
10000320:	0c0b      	lsrs	r3, r1, #16
10000322:	041b      	lsls	r3, r3, #16
10000324:	b103      	cbz	r3, 10000328 <Cy_IPC_Drv_SendMsgWord+0x10>
10000326:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_NOTIFY(base) = _VAL2FLD(IPC_STRUCT_NOTIFY_INTR_NOTIFY, notifyEventIntr);
10000328:	b289      	uxth	r1, r1
1000032a:	6081      	str	r1, [r0, #8]
        /* If the channel was acquired, send the message. */
        Cy_IPC_Drv_WriteDataValue(base, message);

        Cy_IPC_Drv_AcquireNotify(base, notifyEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
1000032c:	2000      	movs	r0, #0
1000032e:	4770      	bx	lr
    }
    else
    {
        /* Channel was already acquired, return Error */
        retStatus = CY_IPC_DRV_ERROR;
10000330:	4800      	ldr	r0, [pc, #0]	; (10000334 <Cy_IPC_Drv_SendMsgWord+0x1c>)
    }
    return (retStatus);
}
10000332:	4770      	bx	lr
10000334:	008a0001 	.word	0x008a0001

10000338 <Cy_IPC_Drv_ReadMsgWord>:
*******************************************************************************/
cy_en_ipcdrv_status_t  Cy_IPC_Drv_ReadMsgWord (IPC_STRUCT_Type const * base, uint32_t * message)
{
    cy_en_ipcdrv_status_t retStatus;

    CY_ASSERT_L1(NULL != message);
10000338:	460a      	mov	r2, r1
1000033a:	b151      	cbz	r1, 10000352 <Cy_IPC_Drv_ReadMsgWord+0x1a>
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
1000033c:	4b07      	ldr	r3, [pc, #28]	; (1000035c <Cy_IPC_Drv_ReadMsgWord+0x24>)
1000033e:	681b      	ldr	r3, [r3, #0]
10000340:	f8d3 30bc 	ldr.w	r3, [r3, #188]	; 0xbc
10000344:	581b      	ldr	r3, [r3, r0]

    if ( Cy_IPC_Drv_IsLockAcquired(base) )
10000346:	2b00      	cmp	r3, #0
10000348:	da05      	bge.n	10000356 <Cy_IPC_Drv_ReadMsgWord+0x1e>
    return REG_IPC_STRUCT_DATA(base);
1000034a:	68c3      	ldr	r3, [r0, #12]
    {
        /* The channel is locked; message is valid. */
        *message = Cy_IPC_Drv_ReadDataValue(base);
1000034c:	6013      	str	r3, [r2, #0]

        retStatus = CY_IPC_DRV_SUCCESS;
1000034e:	2000      	movs	r0, #0
10000350:	4770      	bx	lr
10000352:	be01      	bkpt	0x0001
}
10000354:	e7f2      	b.n	1000033c <Cy_IPC_Drv_ReadMsgWord+0x4>
    }
    else
    {
        /* The channel is not locked so channel is invalid. */
        retStatus = CY_IPC_DRV_ERROR;
10000356:	4802      	ldr	r0, [pc, #8]	; (10000360 <Cy_IPC_Drv_ReadMsgWord+0x28>)
    }
    return(retStatus);
}
10000358:	4770      	bx	lr
1000035a:	bf00      	nop
1000035c:	080001a0 	.word	0x080001a0
10000360:	008a0001 	.word	0x008a0001

10000364 <Cy_IPC_Sema_InitExt>:
*******************************************************************************/
cy_en_ipcsema_status_t Cy_IPC_Sema_InitExt(uint32_t ipcChannel, cy_stc_ipc_sema_t *ipcSema)
{
    cy_en_ipcsema_status_t retStatus = CY_IPC_SEMA_BAD_PARAM;

    if (ipcChannel >= CY_IPC_CHANNELS)
10000364:	4b1e      	ldr	r3, [pc, #120]	; (100003e0 <Cy_IPC_Sema_InitExt+0x7c>)
10000366:	681b      	ldr	r3, [r3, #0]
10000368:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
1000036c:	4283      	cmp	r3, r0
1000036e:	d933      	bls.n	100003d8 <Cy_IPC_Sema_InitExt+0x74>
{
10000370:	b570      	push	{r4, r5, r6, lr}
10000372:	460c      	mov	r4, r1
    {
        retStatus = CY_IPC_SEMA_BAD_PARAM;
    }
    else
    {
        if(NULL != ipcSema)
10000374:	2900      	cmp	r1, #0
10000376:	d031      	beq.n	100003dc <Cy_IPC_Sema_InitExt+0x78>
        {
            /* Check if semaphore count is a multiple of 32 */
            if( 0UL == (ipcSema->maxSema & CY_IPC_SEMA_PER_WORD_MASK))
10000378:	680b      	ldr	r3, [r1, #0]
1000037a:	f013 0f1f 	tst.w	r3, #31
1000037e:	d001      	beq.n	10000384 <Cy_IPC_Sema_InitExt+0x20>
                    retStatus = CY_IPC_SEMA_ERROR_LOCKED;
                }
            }
            else
            {
                retStatus = CY_IPC_SEMA_BAD_PARAM;
10000380:	4818      	ldr	r0, [pc, #96]	; (100003e4 <Cy_IPC_Sema_InitExt+0x80>)
            retStatus = CY_IPC_SEMA_BAD_PARAM;
        }
    }

    return(retStatus);
}
10000382:	bd70      	pop	{r4, r5, r6, pc}
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000384:	4b16      	ldr	r3, [pc, #88]	; (100003e0 <Cy_IPC_Sema_InitExt+0x7c>)
10000386:	681b      	ldr	r3, [r3, #0]
10000388:	f893 3033 	ldrb.w	r3, [r3, #51]	; 0x33
1000038c:	4298      	cmp	r0, r3
1000038e:	d300      	bcc.n	10000392 <Cy_IPC_Sema_InitExt+0x2e>
    __asm("    bkpt    1");
10000390:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10000392:	4b13      	ldr	r3, [pc, #76]	; (100003e0 <Cy_IPC_Sema_InitExt+0x7c>)
10000394:	681b      	ldr	r3, [r3, #0]
10000396:	6a1d      	ldr	r5, [r3, #32]
10000398:	f8b3 30ba 	ldrh.w	r3, [r3, #186]	; 0xba
1000039c:	fb03 5500 	mla	r5, r3, r0, r5
                cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
100003a0:	4e11      	ldr	r6, [pc, #68]	; (100003e8 <Cy_IPC_Sema_InitExt+0x84>)
100003a2:	6035      	str	r5, [r6, #0]
                (void)memset(ipcSema->arrayPtr, 0, (ipcSema->maxSema /8u));
100003a4:	6822      	ldr	r2, [r4, #0]
100003a6:	08d2      	lsrs	r2, r2, #3
100003a8:	2100      	movs	r1, #0
100003aa:	6860      	ldr	r0, [r4, #4]
100003ac:	f000 ff0a 	bl	100011c4 <memset>
                (void) Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION);
100003b0:	2100      	movs	r1, #0
100003b2:	4628      	mov	r0, r5
100003b4:	f7ff ff9a 	bl	100002ec <Cy_IPC_Drv_LockRelease>
    return Cy_IPC_Drv_SendMsgWord(base, notifyEventIntr, (uint32_t)msgPtr);
100003b8:	4622      	mov	r2, r4
100003ba:	2100      	movs	r1, #0
100003bc:	6830      	ldr	r0, [r6, #0]
100003be:	f7ff ffab 	bl	10000318 <Cy_IPC_Drv_SendMsgWord>
                if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_SendMsgPtr (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION, ipcSema))
100003c2:	b108      	cbz	r0, 100003c8 <Cy_IPC_Sema_InitExt+0x64>
                    retStatus = CY_IPC_SEMA_ERROR_LOCKED;
100003c4:	4809      	ldr	r0, [pc, #36]	; (100003ec <Cy_IPC_Sema_InitExt+0x88>)
100003c6:	e7dc      	b.n	10000382 <Cy_IPC_Sema_InitExt+0x1e>
                    if(CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION))
100003c8:	2100      	movs	r1, #0
100003ca:	6830      	ldr	r0, [r6, #0]
100003cc:	f7ff ff8e 	bl	100002ec <Cy_IPC_Drv_LockRelease>
100003d0:	2800      	cmp	r0, #0
100003d2:	d0d6      	beq.n	10000382 <Cy_IPC_Sema_InitExt+0x1e>
                        retStatus = CY_IPC_SEMA_ERROR_LOCKED;
100003d4:	4805      	ldr	r0, [pc, #20]	; (100003ec <Cy_IPC_Sema_InitExt+0x88>)
    return(retStatus);
100003d6:	e7d4      	b.n	10000382 <Cy_IPC_Sema_InitExt+0x1e>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
100003d8:	4802      	ldr	r0, [pc, #8]	; (100003e4 <Cy_IPC_Sema_InitExt+0x80>)
}
100003da:	4770      	bx	lr
            retStatus = CY_IPC_SEMA_BAD_PARAM;
100003dc:	4801      	ldr	r0, [pc, #4]	; (100003e4 <Cy_IPC_Sema_InitExt+0x80>)
100003de:	e7d0      	b.n	10000382 <Cy_IPC_Sema_InitExt+0x1e>
100003e0:	080001a0 	.word	0x080001a0
100003e4:	008a0103 	.word	0x008a0103
100003e8:	080001a8 	.word	0x080001a8
100003ec:	008a0101 	.word	0x008a0101

100003f0 <Cy_IPC_Sema_Init>:
{
100003f0:	b510      	push	{r4, lr}
100003f2:	460b      	mov	r3, r1
    if( (NULL == memPtr) && (0u == count))
100003f4:	4614      	mov	r4, r2
100003f6:	b11a      	cbz	r2, 10000400 <Cy_IPC_Sema_Init+0x10>
    else if ((NULL != memPtr) && (0u != count))
100003f8:	b1e4      	cbz	r4, 10000434 <Cy_IPC_Sema_Init+0x44>
100003fa:	b9ab      	cbnz	r3, 10000428 <Cy_IPC_Sema_Init+0x38>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
100003fc:	480e      	ldr	r0, [pc, #56]	; (10000438 <Cy_IPC_Sema_Init+0x48>)
}
100003fe:	bd10      	pop	{r4, pc}
    if( (NULL == memPtr) && (0u == count))
10000400:	2900      	cmp	r1, #0
10000402:	d1f9      	bne.n	100003f8 <Cy_IPC_Sema_Init+0x8>
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000404:	4a0d      	ldr	r2, [pc, #52]	; (1000043c <Cy_IPC_Sema_Init+0x4c>)
10000406:	6812      	ldr	r2, [r2, #0]
10000408:	f892 2033 	ldrb.w	r2, [r2, #51]	; 0x33
1000040c:	4290      	cmp	r0, r2
1000040e:	d300      	bcc.n	10000412 <Cy_IPC_Sema_Init+0x22>
10000410:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10000412:	4a0a      	ldr	r2, [pc, #40]	; (1000043c <Cy_IPC_Sema_Init+0x4c>)
10000414:	6811      	ldr	r1, [r2, #0]
10000416:	6a0a      	ldr	r2, [r1, #32]
10000418:	f8b1 10ba 	ldrh.w	r1, [r1, #186]	; 0xba
1000041c:	fb01 2000 	mla	r0, r1, r0, r2
        cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
10000420:	4a07      	ldr	r2, [pc, #28]	; (10000440 <Cy_IPC_Sema_Init+0x50>)
10000422:	6010      	str	r0, [r2, #0]
        retStatus = CY_IPC_SEMA_SUCCESS;
10000424:	4618      	mov	r0, r3
10000426:	e7ea      	b.n	100003fe <Cy_IPC_Sema_Init+0xe>
        cy_semaData.maxSema  = count;
10000428:	4906      	ldr	r1, [pc, #24]	; (10000444 <Cy_IPC_Sema_Init+0x54>)
1000042a:	600b      	str	r3, [r1, #0]
        cy_semaData.arrayPtr = memPtr;
1000042c:	604c      	str	r4, [r1, #4]
        retStatus = Cy_IPC_Sema_InitExt(ipcChannel, &cy_semaData);
1000042e:	f7ff ff99 	bl	10000364 <Cy_IPC_Sema_InitExt>
10000432:	e7e4      	b.n	100003fe <Cy_IPC_Sema_Init+0xe>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
10000434:	4800      	ldr	r0, [pc, #0]	; (10000438 <Cy_IPC_Sema_Init+0x48>)
10000436:	e7e2      	b.n	100003fe <Cy_IPC_Sema_Init+0xe>
10000438:	008a0103 	.word	0x008a0103
1000043c:	080001a0 	.word	0x080001a0
10000440:	080001a8 	.word	0x080001a8
10000444:	080000d4 	.word	0x080000d4

10000448 <Cy_WDT_Unlock>:
*
*******************************************************************************/
void Cy_WDT_Unlock(void)
{
    /* The WDT lock is to be removed by two writes */
    SRSS_WDT_CTL = ((SRSS_WDT_CTL & (uint32_t)(~SRSS_WDT_CTL_WDT_LOCK_Msk)) | CY_SRSS_WDT_LOCK_BIT0);
10000448:	4a07      	ldr	r2, [pc, #28]	; (10000468 <Cy_WDT_Unlock+0x20>)
1000044a:	f8d2 3180 	ldr.w	r3, [r2, #384]	; 0x180
1000044e:	f023 4340 	bic.w	r3, r3, #3221225472	; 0xc0000000
10000452:	f043 4380 	orr.w	r3, r3, #1073741824	; 0x40000000
10000456:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180

    SRSS_WDT_CTL |= CY_SRSS_WDT_LOCK_BIT1;
1000045a:	f8d2 3180 	ldr.w	r3, [r2, #384]	; 0x180
1000045e:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
10000462:	f8c2 3180 	str.w	r3, [r2, #384]	; 0x180
}
10000466:	4770      	bx	lr
10000468:	40260000 	.word	0x40260000

1000046c <Cy_SysInt_SetVector>:
cy_israddress Cy_SysInt_SetVector(IRQn_Type IRQn, cy_israddress userIsr)
{
    cy_israddress prevIsr;

    /* Set the new vector only if it was moved to __ramVectors */
    if (SCB->VTOR == (uint32_t)&__ramVectors)
1000046c:	4b0a      	ldr	r3, [pc, #40]	; (10000498 <Cy_SysInt_SetVector+0x2c>)
1000046e:	689a      	ldr	r2, [r3, #8]
10000470:	4b0a      	ldr	r3, [pc, #40]	; (1000049c <Cy_SysInt_SetVector+0x30>)
10000472:	429a      	cmp	r2, r3
10000474:	d004      	beq.n	10000480 <Cy_SysInt_SetVector+0x14>
            #endif
        #endif
    }
    else
    {
        prevIsr = __Vectors[CY_INT_IRQ_BASE + (uint32_t)IRQn];
10000476:	3010      	adds	r0, #16
10000478:	4b09      	ldr	r3, [pc, #36]	; (100004a0 <Cy_SysInt_SetVector+0x34>)
1000047a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
    }

    return (prevIsr);
}
1000047e:	4770      	bx	lr
        CY_ASSERT_L1(CY_SYSINT_IS_VECTOR_VALID(userIsr));
10000480:	b139      	cbz	r1, 10000492 <Cy_SysInt_SetVector+0x26>
        prevIsr = __ramVectors[CY_INT_IRQ_BASE + (uint32_t)IRQn];
10000482:	f100 0310 	add.w	r3, r0, #16
10000486:	4a05      	ldr	r2, [pc, #20]	; (1000049c <Cy_SysInt_SetVector+0x30>)
10000488:	f852 0023 	ldr.w	r0, [r2, r3, lsl #2]
        __ramVectors[CY_INT_IRQ_BASE + (uint32_t)IRQn] = userIsr;
1000048c:	f842 1023 	str.w	r1, [r2, r3, lsl #2]
10000490:	4770      	bx	lr
10000492:	be01      	bkpt	0x0001
}
10000494:	e7f5      	b.n	10000482 <Cy_SysInt_SetVector+0x16>
10000496:	bf00      	nop
10000498:	e000ed00 	.word	0xe000ed00
1000049c:	08000000 	.word	0x08000000
100004a0:	10000000 	.word	0x10000000

100004a4 <Cy_SysInt_Init>:
    if(NULL != config)
100004a4:	b338      	cbz	r0, 100004f6 <Cy_SysInt_Init+0x52>
{
100004a6:	b508      	push	{r3, lr}
100004a8:	4684      	mov	ip, r0
        CY_ASSERT_L3(CY_SYSINT_IS_PRIORITY_VALID(config->intrPriority));
100004aa:	6843      	ldr	r3, [r0, #4]
100004ac:	2b07      	cmp	r3, #7
100004ae:	d900      	bls.n	100004b2 <Cy_SysInt_Init+0xe>
    __asm("    bkpt    1");
100004b0:	be01      	bkpt	0x0001
                NVIC_SetPriority(config->intrSrc, config->intrPriority);
100004b2:	f9bc 3000 	ldrsh.w	r3, [ip]
100004b6:	f8dc 2004 	ldr.w	r2, [ip, #4]
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
100004ba:	2b00      	cmp	r3, #0
100004bc:	db0e      	blt.n	100004dc <Cy_SysInt_Init+0x38>
  {
    NVIC->IP[((uint32_t)IRQn)]               = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100004be:	0152      	lsls	r2, r2, #5
100004c0:	b2d2      	uxtb	r2, r2
100004c2:	f103 4360 	add.w	r3, r3, #3758096384	; 0xe0000000
100004c6:	f503 4361 	add.w	r3, r3, #57600	; 0xe100
100004ca:	f883 2300 	strb.w	r2, [r3, #768]	; 0x300
                if (SCB->VTOR == (uint32_t)&__ramVectors)
100004ce:	4b0b      	ldr	r3, [pc, #44]	; (100004fc <Cy_SysInt_Init+0x58>)
100004d0:	689a      	ldr	r2, [r3, #8]
100004d2:	4b0b      	ldr	r3, [pc, #44]	; (10000500 <Cy_SysInt_Init+0x5c>)
100004d4:	429a      	cmp	r2, r3
100004d6:	d008      	beq.n	100004ea <Cy_SysInt_Init+0x46>
    cy_en_sysint_status_t status = CY_SYSINT_SUCCESS;
100004d8:	2000      	movs	r0, #0
}
100004da:	bd08      	pop	{r3, pc}
  }
  else
  {
    SCB->SHP[(((uint32_t)IRQn) & 0xFUL)-4UL] = (uint8_t)((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL);
100004dc:	f003 030f 	and.w	r3, r3, #15
100004e0:	0152      	lsls	r2, r2, #5
100004e2:	b2d2      	uxtb	r2, r2
100004e4:	4807      	ldr	r0, [pc, #28]	; (10000504 <Cy_SysInt_Init+0x60>)
100004e6:	54c2      	strb	r2, [r0, r3]
100004e8:	e7f1      	b.n	100004ce <Cy_SysInt_Init+0x2a>
                    (void)Cy_SysInt_SetVector(config->intrSrc, userIsr);
100004ea:	f9bc 0000 	ldrsh.w	r0, [ip]
100004ee:	f7ff ffbd 	bl	1000046c <Cy_SysInt_SetVector>
    cy_en_sysint_status_t status = CY_SYSINT_SUCCESS;
100004f2:	2000      	movs	r0, #0
100004f4:	e7f1      	b.n	100004da <Cy_SysInt_Init+0x36>
        status = CY_SYSINT_BAD_PARAM;
100004f6:	4804      	ldr	r0, [pc, #16]	; (10000508 <Cy_SysInt_Init+0x64>)
}
100004f8:	4770      	bx	lr
100004fa:	bf00      	nop
100004fc:	e000ed00 	.word	0xe000ed00
10000500:	08000000 	.word	0x08000000
10000504:	e000ed14 	.word	0xe000ed14
10000508:	00560001 	.word	0x00560001

1000050c <Cy_SysClk_ClkSlowGetDivider>:
}


uint8_t Cy_SysClk_ClkSlowGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_SLOW_INT_DIV, CPUSS_CM0_CLOCK_CTL));
1000050c:	4b04      	ldr	r3, [pc, #16]	; (10000520 <Cy_SysClk_ClkSlowGetDivider+0x14>)
1000050e:	681b      	ldr	r3, [r3, #0]
10000510:	681a      	ldr	r2, [r3, #0]
10000512:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
10000516:	58d0      	ldr	r0, [r2, r3]
}
10000518:	f3c0 2007 	ubfx	r0, r0, #8, #8
1000051c:	4770      	bx	lr
1000051e:	bf00      	nop
10000520:	080001a0 	.word	0x080001a0

10000524 <Cy_SysClk_ClkPeriGetDivider>:
}


uint8_t Cy_SysClk_ClkPeriGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_PERI_INT_DIV, CPUSS_CM0_CLOCK_CTL));
10000524:	4b03      	ldr	r3, [pc, #12]	; (10000534 <Cy_SysClk_ClkPeriGetDivider+0x10>)
10000526:	681b      	ldr	r3, [r3, #0]
10000528:	681a      	ldr	r2, [r3, #0]
1000052a:	f8d3 3088 	ldr.w	r3, [r3, #136]	; 0x88
1000052e:	58d0      	ldr	r0, [r2, r3]
}
10000530:	0e00      	lsrs	r0, r0, #24
10000532:	4770      	bx	lr
10000534:	080001a0 	.word	0x080001a0

10000538 <Cy_SysClk_ClkHfGetSource>:
}


cy_en_clkhf_in_sources_t Cy_SysClk_ClkHfGetSource(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
10000538:	4b06      	ldr	r3, [pc, #24]	; (10000554 <Cy_SysClk_ClkHfGetSource+0x1c>)
1000053a:	681b      	ldr	r3, [r3, #0]
1000053c:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10000540:	4283      	cmp	r3, r0
10000542:	d800      	bhi.n	10000546 <Cy_SysClk_ClkHfGetSource+0xe>
10000544:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_in_sources_t)((uint32_t)(_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_MUX, SRSS_CLK_ROOT_SELECT[clkHf]))));
10000546:	30e0      	adds	r0, #224	; 0xe0
10000548:	4b03      	ldr	r3, [pc, #12]	; (10000558 <Cy_SysClk_ClkHfGetSource+0x20>)
1000054a:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
1000054e:	f000 000f 	and.w	r0, r0, #15
10000552:	4770      	bx	lr
10000554:	080001a0 	.word	0x080001a0
10000558:	40260000 	.word	0x40260000

1000055c <Cy_SysClk_ClkHfGetDivider>:
}


cy_en_clkhf_dividers_t Cy_SysClk_ClkHfGetDivider(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
1000055c:	4b06      	ldr	r3, [pc, #24]	; (10000578 <Cy_SysClk_ClkHfGetDivider+0x1c>)
1000055e:	681b      	ldr	r3, [r3, #0]
10000560:	f893 3040 	ldrb.w	r3, [r3, #64]	; 0x40
10000564:	4283      	cmp	r3, r0
10000566:	d800      	bhi.n	1000056a <Cy_SysClk_ClkHfGetDivider+0xe>
10000568:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_dividers_t)(((uint32_t)_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_DIV, SRSS_CLK_ROOT_SELECT[clkHf]))));
1000056a:	30e0      	adds	r0, #224	; 0xe0
1000056c:	4b03      	ldr	r3, [pc, #12]	; (1000057c <Cy_SysClk_ClkHfGetDivider+0x20>)
1000056e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
10000572:	f3c0 1001 	ubfx	r0, r0, #4, #2
10000576:	4770      	bx	lr
10000578:	080001a0 	.word	0x080001a0
1000057c:	40260000 	.word	0x40260000

10000580 <Cy_SysClk_WcoOkay>:
}


bool Cy_SysClk_WcoOkay(void)
{
    return (_FLD2BOOL(BACKUP_STATUS_WCO_OK, BACKUP_STATUS));
10000580:	4b02      	ldr	r3, [pc, #8]	; (1000058c <Cy_SysClk_WcoOkay+0xc>)
10000582:	6918      	ldr	r0, [r3, #16]
}
10000584:	f3c0 0080 	ubfx	r0, r0, #2, #1
10000588:	4770      	bx	lr
1000058a:	bf00      	nop
1000058c:	40270000 	.word	0x40270000

10000590 <Cy_SysClk_AltHfGetFrequency>:
    #if defined(CY_IP_MXBLESS)
        return (cy_BleEcoClockFreqHz);
    #else /* CY_IP_MXBLESS */
        return (0UL);
    #endif /* CY_IP_MXBLESS */
}
10000590:	2000      	movs	r0, #0
10000592:	4770      	bx	lr

10000594 <Cy_SysClk_AltLfGetFrequency>:


uint32_t Cy_SysClk_AltLfGetFrequency(void)
{
    return (0UL);
}
10000594:	2000      	movs	r0, #0
10000596:	4770      	bx	lr

10000598 <Cy_SysClk_ExtClkGetFrequency>:


uint32_t Cy_SysClk_ExtClkGetFrequency(void)
{
    return (cySysClkExtFreq);
}
10000598:	4b01      	ldr	r3, [pc, #4]	; (100005a0 <Cy_SysClk_ExtClkGetFrequency+0x8>)
1000059a:	6818      	ldr	r0, [r3, #0]
1000059c:	4770      	bx	lr
1000059e:	bf00      	nop
100005a0:	080001ac 	.word	0x080001ac

100005a4 <Cy_SysClk_EcoGetStatus>:


uint32_t Cy_SysClk_EcoGetStatus(void)
{
    /* if ECO is not ready, just report the ECO_OK bit. Otherwise report 2 = ECO ready */
    return ((SRSS_CLK_ECO_STATUS_Msk == (SRSS_CLK_ECO_STATUS_Msk & SRSS_CLK_ECO_STATUS)) ?
100005a4:	4b07      	ldr	r3, [pc, #28]	; (100005c4 <Cy_SysClk_EcoGetStatus+0x20>)
100005a6:	f8d3 3530 	ldr.w	r3, [r3, #1328]	; 0x530
100005aa:	f003 0303 	and.w	r3, r3, #3
      CY_SYSCLK_ECOSTAT_STABLE : (SRSS_CLK_ECO_STATUS_ECO_OK_Msk & SRSS_CLK_ECO_STATUS));
100005ae:	2b03      	cmp	r3, #3
100005b0:	d005      	beq.n	100005be <Cy_SysClk_EcoGetStatus+0x1a>
100005b2:	4b04      	ldr	r3, [pc, #16]	; (100005c4 <Cy_SysClk_EcoGetStatus+0x20>)
100005b4:	f8d3 0530 	ldr.w	r0, [r3, #1328]	; 0x530
100005b8:	f000 0001 	and.w	r0, r0, #1
100005bc:	4770      	bx	lr
100005be:	2002      	movs	r0, #2
}
100005c0:	4770      	bx	lr
100005c2:	bf00      	nop
100005c4:	40260000 	.word	0x40260000

100005c8 <Cy_SysClk_EcoGetFrequency>:
    return (retVal);
}


uint32_t Cy_SysClk_EcoGetFrequency(void)
{
100005c8:	b508      	push	{r3, lr}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
100005ca:	f7ff ffeb 	bl	100005a4 <Cy_SysClk_EcoGetStatus>
100005ce:	2802      	cmp	r0, #2
100005d0:	d001      	beq.n	100005d6 <Cy_SysClk_EcoGetFrequency+0xe>
100005d2:	2000      	movs	r0, #0
}
100005d4:	bd08      	pop	{r3, pc}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
100005d6:	4b01      	ldr	r3, [pc, #4]	; (100005dc <Cy_SysClk_EcoGetFrequency+0x14>)
100005d8:	6818      	ldr	r0, [r3, #0]
100005da:	e7fb      	b.n	100005d4 <Cy_SysClk_EcoGetFrequency+0xc>
100005dc:	080001b0 	.word	0x080001b0

100005e0 <Cy_SysClk_ClkPathGetSource>:

}


cy_en_clkpath_in_sources_t Cy_SysClk_ClkPathGetSource(uint32_t clkPath)
{
100005e0:	4602      	mov	r2, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
100005e2:	4b0c      	ldr	r3, [pc, #48]	; (10000614 <Cy_SysClk_ClkPathGetSource+0x34>)
100005e4:	681b      	ldr	r3, [r3, #0]
100005e6:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
100005ea:	4283      	cmp	r3, r0
100005ec:	d800      	bhi.n	100005f0 <Cy_SysClk_ClkPathGetSource+0x10>
100005ee:	be01      	bkpt	0x0001
    cy_en_clkpath_in_sources_t retVal =
        (cy_en_clkpath_in_sources_t )((uint32_t)_FLD2VAL(SRSS_CLK_PATH_SELECT_PATH_MUX, SRSS_CLK_PATH_SELECT[clkPath]));
100005f0:	f102 03d0 	add.w	r3, r2, #208	; 0xd0
100005f4:	4908      	ldr	r1, [pc, #32]	; (10000618 <Cy_SysClk_ClkPathGetSource+0x38>)
100005f6:	f851 0023 	ldr.w	r0, [r1, r3, lsl #2]
    cy_en_clkpath_in_sources_t retVal =
100005fa:	f000 0007 	and.w	r0, r0, #7
    if (retVal == CY_SYSCLK_CLKPATH_IN_DSIMUX)
100005fe:	2804      	cmp	r0, #4
10000600:	d000      	beq.n	10000604 <Cy_SysClk_ClkPathGetSource+0x24>
    {
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
    }
    return (retVal);
}
10000602:	4770      	bx	lr
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
10000604:	32c0      	adds	r2, #192	; 0xc0
10000606:	f851 0022 	ldr.w	r0, [r1, r2, lsl #2]
1000060a:	f000 001f 	and.w	r0, r0, #31
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
1000060e:	f440 7080 	orr.w	r0, r0, #256	; 0x100
10000612:	e7f6      	b.n	10000602 <Cy_SysClk_ClkPathGetSource+0x22>
10000614:	080001a0 	.word	0x080001a0
10000618:	40260000 	.word	0x40260000

1000061c <Cy_SysClk_ClkPathMuxGetFrequency>:


uint32_t Cy_SysClk_ClkPathMuxGetFrequency(uint32_t clkPath)
{
1000061c:	b508      	push	{r3, lr}
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
1000061e:	4b28      	ldr	r3, [pc, #160]	; (100006c0 <Cy_SysClk_ClkPathMuxGetFrequency+0xa4>)
10000620:	681b      	ldr	r3, [r3, #0]
10000622:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
10000626:	4283      	cmp	r3, r0
10000628:	d800      	bhi.n	1000062c <Cy_SysClk_ClkPathMuxGetFrequency+0x10>
1000062a:	be01      	bkpt	0x0001

    uint32_t freq = 0UL;    /* The path mux output frequency in Hz, 0 = an unknown frequency */

    /* Get the frequency of the source, i.e., the path mux input */
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
1000062c:	f7ff ffd8 	bl	100005e0 <Cy_SysClk_ClkPathGetSource>
10000630:	2803      	cmp	r0, #3
10000632:	d90d      	bls.n	10000650 <Cy_SysClk_ClkPathMuxGetFrequency+0x34>
10000634:	f5b0 7f8a 	cmp.w	r0, #276	; 0x114
10000638:	d240      	bcs.n	100006bc <Cy_SysClk_ClkPathMuxGetFrequency+0xa0>
1000063a:	f5b0 7f88 	cmp.w	r0, #272	; 0x110
1000063e:	d30f      	bcc.n	10000660 <Cy_SysClk_ClkPathMuxGetFrequency+0x44>
10000640:	f5a0 7088 	sub.w	r0, r0, #272	; 0x110
10000644:	2803      	cmp	r0, #3
10000646:	d835      	bhi.n	100006b4 <Cy_SysClk_ClkPathMuxGetFrequency+0x98>
10000648:	e8df f000 	tbb	[pc, r0]
1000064c:	27311f15 	.word	0x27311f15
10000650:	2803      	cmp	r0, #3
10000652:	d803      	bhi.n	1000065c <Cy_SysClk_ClkPathMuxGetFrequency+0x40>
10000654:	e8df f000 	tbb	[pc, r0]
10000658:	0c090630 	.word	0x0c090630
1000065c:	2000      	movs	r0, #0
1000065e:	e02c      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10000660:	2000      	movs	r0, #0
10000662:	e02a      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
        case CY_SYSCLK_CLKPATH_IN_IMO: /* The IMO frequency is fixed at 8 MHz */
            freq = CY_SYSCLK_IMO_FREQ;
            break;

        case CY_SYSCLK_CLKPATH_IN_EXT:
            freq = Cy_SysClk_ExtClkGetFrequency();
10000664:	f7ff ff98 	bl	10000598 <Cy_SysClk_ExtClkGetFrequency>
            break;
10000668:	e027      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ECO:
            freq = Cy_SysClk_EcoGetFrequency();
1000066a:	f7ff ffad 	bl	100005c8 <Cy_SysClk_EcoGetFrequency>
            break;
1000066e:	e024      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ALTHF:
            freq = Cy_SysClk_AltHfGetFrequency();
10000670:	f7ff ff8e 	bl	10000590 <Cy_SysClk_AltHfGetFrequency>
            break;
10000674:	e021      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>

        case CY_SYSCLK_CLKPATH_IN_ILO:
            freq = (0UL != (SRSS_CLK_ILO_CONFIG & SRSS_CLK_ILO_CONFIG_ENABLE_Msk)) ? CY_SYSCLK_ILO_FREQ : 0UL;
10000676:	4b13      	ldr	r3, [pc, #76]	; (100006c4 <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>)
10000678:	f8d3 350c 	ldr.w	r3, [r3, #1292]	; 0x50c
1000067c:	2b00      	cmp	r3, #0
1000067e:	db01      	blt.n	10000684 <Cy_SysClk_ClkPathMuxGetFrequency+0x68>
10000680:	2000      	movs	r0, #0
10000682:	e01a      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10000684:	f44f 4000 	mov.w	r0, #32768	; 0x8000
10000688:	e017      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            break;

        case CY_SYSCLK_CLKPATH_IN_WCO:
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
1000068a:	f7ff ff79 	bl	10000580 <Cy_SysClk_WcoOkay>
1000068e:	b908      	cbnz	r0, 10000694 <Cy_SysClk_ClkPathMuxGetFrequency+0x78>
10000690:	2000      	movs	r0, #0
10000692:	e012      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
10000694:	f44f 4000 	mov.w	r0, #32768	; 0x8000
10000698:	e00f      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            break;

        case CY_SYSCLK_CLKPATH_IN_PILO:
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
1000069a:	4b0a      	ldr	r3, [pc, #40]	; (100006c4 <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>)
1000069c:	f8d3 353c 	ldr.w	r3, [r3, #1340]	; 0x53c
100006a0:	2b00      	cmp	r3, #0
100006a2:	db01      	blt.n	100006a8 <Cy_SysClk_ClkPathMuxGetFrequency+0x8c>
100006a4:	2000      	movs	r0, #0
        default:
            /* Don't know the frequency of dsi_out, leave freq = 0UL */
            break;
    }

    return (freq);
100006a6:	e008      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
100006a8:	f44f 4000 	mov.w	r0, #32768	; 0x8000
100006ac:	e005      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = Cy_SysClk_AltLfGetFrequency();
100006ae:	f7ff ff71 	bl	10000594 <Cy_SysClk_AltLfGetFrequency>
            break;
100006b2:	e002      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
100006b4:	2000      	movs	r0, #0
100006b6:	e000      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
            freq = CY_SYSCLK_IMO_FREQ;
100006b8:	4803      	ldr	r0, [pc, #12]	; (100006c8 <Cy_SysClk_ClkPathMuxGetFrequency+0xac>)
}
100006ba:	bd08      	pop	{r3, pc}
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
100006bc:	2000      	movs	r0, #0
100006be:	e7fc      	b.n	100006ba <Cy_SysClk_ClkPathMuxGetFrequency+0x9e>
100006c0:	080001a0 	.word	0x080001a0
100006c4:	40260000 	.word	0x40260000
100006c8:	007a1200 	.word	0x007a1200

100006cc <Cy_SysClk_FllIsEnabled>:
#define MARGIN_SCALE            (100000ULL) /* 10 ^ 5 */
/** \endcond */

bool Cy_SysClk_FllIsEnabled(void)
{
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
100006cc:	4b02      	ldr	r3, [pc, #8]	; (100006d8 <Cy_SysClk_FllIsEnabled+0xc>)
100006ce:	f8d3 0580 	ldr.w	r0, [r3, #1408]	; 0x580
}
100006d2:	0fc0      	lsrs	r0, r0, #31
100006d4:	4770      	bx	lr
100006d6:	bf00      	nop
100006d8:	40260000 	.word	0x40260000

100006dc <Cy_SysClk_FllGetConfiguration>:
}


void Cy_SysClk_FllGetConfiguration(cy_stc_fll_manual_config_t *config)
{
    CY_ASSERT_L1(config != NULL);
100006dc:	4603      	mov	r3, r0
100006de:	b338      	cbz	r0, 10000730 <Cy_SysClk_FllGetConfiguration+0x54>
    /* read 2 parameters from CLK_FLL_CONFIG register */
    uint32_t tempReg = SRSS_CLK_FLL_CONFIG;
100006e0:	4914      	ldr	r1, [pc, #80]	; (10000734 <Cy_SysClk_FllGetConfiguration+0x58>)
100006e2:	f8d1 2580 	ldr.w	r2, [r1, #1408]	; 0x580
    config->fllMult         = _FLD2VAL(SRSS_CLK_FLL_CONFIG_FLL_MULT, tempReg);
100006e6:	f3c2 0011 	ubfx	r0, r2, #0, #18
100006ea:	6018      	str	r0, [r3, #0]
    config->enableOutputDiv = _FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, tempReg);
100006ec:	f3c2 6200 	ubfx	r2, r2, #24, #1
100006f0:	71da      	strb	r2, [r3, #7]
    /* read 2 parameters from CLK_FLL_CONFIG2 register */
    tempReg = SRSS_CLK_FLL_CONFIG2;
100006f2:	f8d1 2584 	ldr.w	r2, [r1, #1412]	; 0x584
    config->refDiv          = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, tempReg);
100006f6:	f3c2 000c 	ubfx	r0, r2, #0, #13
100006fa:	8098      	strh	r0, [r3, #4]
    config->lockTolerance   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, tempReg);
100006fc:	f3c2 4208 	ubfx	r2, r2, #16, #9
10000700:	811a      	strh	r2, [r3, #8]
    /* read 4 parameters from CLK_FLL_CONFIG3 register */
    tempReg = SRSS_CLK_FLL_CONFIG3;
10000702:	f8d1 2588 	ldr.w	r2, [r1, #1416]	; 0x588
    config->igain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, tempReg);
10000706:	f002 000f 	and.w	r0, r2, #15
1000070a:	7298      	strb	r0, [r3, #10]
    config->pgain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, tempReg);
1000070c:	f3c2 1003 	ubfx	r0, r2, #4, #4
10000710:	72d8      	strb	r0, [r3, #11]
    config->settlingCount   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, tempReg);
10000712:	f3c2 200c 	ubfx	r0, r2, #8, #13
10000716:	8198      	strh	r0, [r3, #12]
    config->outputMode      = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, tempReg));
10000718:	f3c2 7201 	ubfx	r2, r2, #28, #2
1000071c:	739a      	strb	r2, [r3, #14]
    /* read 2 parameters from CLK_FLL_CONFIG4 register */
    tempReg = SRSS_CLK_FLL_CONFIG4;
1000071e:	f8d1 258c 	ldr.w	r2, [r1, #1420]	; 0x58c
    config->ccoRange        = (cy_en_fll_cco_ranges_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_RANGE, tempReg));
10000722:	f3c2 2102 	ubfx	r1, r2, #8, #3
10000726:	7199      	strb	r1, [r3, #6]
    config->cco_Freq        = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_FREQ, tempReg);
10000728:	f3c2 4208 	ubfx	r2, r2, #16, #9
1000072c:	821a      	strh	r2, [r3, #16]
}
1000072e:	4770      	bx	lr
10000730:	be01      	bkpt	0x0001
}
10000732:	e7d5      	b.n	100006e0 <Cy_SysClk_FllGetConfiguration+0x4>
10000734:	40260000 	.word	0x40260000

10000738 <Cy_SysClk_PllIsEnabled>:
#define CY_SYSCLK_PLL_MAX_OUT_FREQ (150000000UL)


bool Cy_SysClk_PllIsEnabled(uint32_t clkPath)
{
    clkPath--; /* to correctly access PLL config and status registers structures */
10000738:	3801      	subs	r0, #1
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_PLL);
1000073a:	4b07      	ldr	r3, [pc, #28]	; (10000758 <Cy_SysClk_PllIsEnabled+0x20>)
1000073c:	681b      	ldr	r3, [r3, #0]
1000073e:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
10000742:	4283      	cmp	r3, r0
10000744:	d800      	bhi.n	10000748 <Cy_SysClk_PllIsEnabled+0x10>
    __asm("    bkpt    1");
10000746:	be01      	bkpt	0x0001
    return (_FLD2BOOL(SRSS_CLK_PLL_CONFIG_ENABLE, SRSS_CLK_PLL_CONFIG[clkPath]));
10000748:	f500 70c0 	add.w	r0, r0, #384	; 0x180
1000074c:	4b03      	ldr	r3, [pc, #12]	; (1000075c <Cy_SysClk_PllIsEnabled+0x24>)
1000074e:	f853 0020 	ldr.w	r0, [r3, r0, lsl #2]
}
10000752:	0fc0      	lsrs	r0, r0, #31
10000754:	4770      	bx	lr
10000756:	bf00      	nop
10000758:	080001a0 	.word	0x080001a0
1000075c:	40260000 	.word	0x40260000

10000760 <Cy_SysClk_PllGetConfiguration>:


cy_en_sysclk_status_t Cy_SysClk_PllGetConfiguration(uint32_t clkPath, cy_stc_pll_manual_config_t *config)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    clkPath--; /* to correctly access PLL config and status register structures */
10000760:	3801      	subs	r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
10000762:	4b0f      	ldr	r3, [pc, #60]	; (100007a0 <Cy_SysClk_PllGetConfiguration+0x40>)
10000764:	681b      	ldr	r3, [r3, #0]
10000766:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
1000076a:	4283      	cmp	r3, r0
1000076c:	d915      	bls.n	1000079a <Cy_SysClk_PllGetConfiguration+0x3a>
    {
        uint32_t tempReg = SRSS_CLK_PLL_CONFIG[clkPath];
1000076e:	f500 70c0 	add.w	r0, r0, #384	; 0x180
10000772:	4b0c      	ldr	r3, [pc, #48]	; (100007a4 <Cy_SysClk_PllGetConfiguration+0x44>)
10000774:	f853 3020 	ldr.w	r3, [r3, r0, lsl #2]
        config->feedbackDiv  = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_FEEDBACK_DIV,  tempReg);
10000778:	f003 027f 	and.w	r2, r3, #127	; 0x7f
1000077c:	700a      	strb	r2, [r1, #0]
        config->referenceDiv = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_REFERENCE_DIV, tempReg);
1000077e:	f3c3 2204 	ubfx	r2, r3, #8, #5
10000782:	704a      	strb	r2, [r1, #1]
        config->outputDiv    = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    tempReg);
10000784:	f3c3 4204 	ubfx	r2, r3, #16, #5
10000788:	708a      	strb	r2, [r1, #2]
        config->lfMode       =         _FLD2BOOL(SRSS_CLK_PLL_CONFIG_PLL_LF_MODE,   tempReg);
1000078a:	f3c3 62c0 	ubfx	r2, r3, #27, #1
1000078e:	70ca      	strb	r2, [r1, #3]
        config->outputMode   = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, tempReg));
10000790:	f3c3 7301 	ubfx	r3, r3, #28, #2
10000794:	710b      	strb	r3, [r1, #4]
        retVal = CY_SYSCLK_SUCCESS;
10000796:	2000      	movs	r0, #0
10000798:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
1000079a:	4803      	ldr	r0, [pc, #12]	; (100007a8 <Cy_SysClk_PllGetConfiguration+0x48>)
    }
    return (retVal);
}
1000079c:	4770      	bx	lr
1000079e:	bf00      	nop
100007a0:	080001a0 	.word	0x080001a0
100007a4:	40260000 	.word	0x40260000
100007a8:	004a0001 	.word	0x004a0001

100007ac <Cy_SysClk_FllGetFrequency>:
    return (CY_SYSLIB_DIV_ROUND(freq, 1UL + (uint32_t)Cy_SysClk_ClkTimerGetDivider()));
}


uint32_t Cy_SysClk_FllGetFrequency(void)
{
100007ac:	b570      	push	{r4, r5, r6, lr}
100007ae:	b086      	sub	sp, #24
    uint32_t rDiv;    /* FLL reference divider */
    uint32_t oDiv;    /* FLL output divider */
    bool  enabled;    /* FLL enable status; n/a for direct */
    uint32_t freq = 0UL;    /* FLL Frequency */

    cy_stc_fll_manual_config_t fllCfg = {0UL,0U,CY_SYSCLK_FLL_CCO_RANGE0,false,0U,0U,0U,0U,CY_SYSCLK_FLLPLL_OUTPUT_AUTO,0U};
100007b0:	2300      	movs	r3, #0
100007b2:	9301      	str	r3, [sp, #4]
100007b4:	9302      	str	r3, [sp, #8]
100007b6:	9303      	str	r3, [sp, #12]
100007b8:	9304      	str	r3, [sp, #16]
100007ba:	9305      	str	r3, [sp, #20]
    Cy_SysClk_FllGetConfiguration(&fllCfg);
100007bc:	a801      	add	r0, sp, #4
100007be:	f7ff ff8d 	bl	100006dc <Cy_SysClk_FllGetConfiguration>
    enabled = (Cy_SysClk_FllIsEnabled()) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != fllCfg.outputMode);
100007c2:	f7ff ff83 	bl	100006cc <Cy_SysClk_FllIsEnabled>
100007c6:	b138      	cbz	r0, 100007d8 <Cy_SysClk_FllGetFrequency+0x2c>
100007c8:	f89d 3012 	ldrb.w	r3, [sp, #18]
100007cc:	2b02      	cmp	r3, #2
100007ce:	d001      	beq.n	100007d4 <Cy_SysClk_FllGetFrequency+0x28>
100007d0:	2101      	movs	r1, #1
100007d2:	e002      	b.n	100007da <Cy_SysClk_FllGetFrequency+0x2e>
100007d4:	2100      	movs	r1, #0
100007d6:	e000      	b.n	100007da <Cy_SysClk_FllGetFrequency+0x2e>
100007d8:	2100      	movs	r1, #0
    fDiv = fllCfg.fllMult;
100007da:	9d01      	ldr	r5, [sp, #4]
    rDiv = fllCfg.refDiv;
100007dc:	f8bd 4008 	ldrh.w	r4, [sp, #8]
100007e0:	4620      	mov	r0, r4
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
100007e2:	f89d 300b 	ldrb.w	r3, [sp, #11]
100007e6:	b183      	cbz	r3, 1000080a <Cy_SysClk_FllGetFrequency+0x5e>
100007e8:	2602      	movs	r6, #2

    if (enabled && /* If FLL is enabled and not bypassed */
100007ea:	b181      	cbz	r1, 1000080e <Cy_SysClk_FllGetFrequency+0x62>
100007ec:	b184      	cbz	r4, 10000810 <Cy_SysClk_FllGetFrequency+0x64>
        (0UL != rDiv)) /* to avoid division by zero */
    {
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
100007ee:	2000      	movs	r0, #0
100007f0:	f7ff ff14 	bl	1000061c <Cy_SysClk_ClkPathMuxGetFrequency>
        freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
100007f4:	fba0 0105 	umull	r0, r1, r0, r5
100007f8:	fba4 2306 	umull	r2, r3, r4, r6
100007fc:	0854      	lsrs	r4, r2, #1
100007fe:	1900      	adds	r0, r0, r4
10000800:	f141 0100 	adc.w	r1, r1, #0
10000804:	f000 fb5c 	bl	10000ec0 <__aeabi_uldivmod>
10000808:	e002      	b.n	10000810 <Cy_SysClk_FllGetFrequency+0x64>
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
1000080a:	2601      	movs	r6, #1
1000080c:	e7ed      	b.n	100007ea <Cy_SysClk_FllGetFrequency+0x3e>
    uint32_t freq = 0UL;    /* FLL Frequency */
1000080e:	2000      	movs	r0, #0
                                             ((uint64_t)rDiv * (uint64_t)oDiv));
    }

    return (freq);
}
10000810:	b006      	add	sp, #24
10000812:	bd70      	pop	{r4, r5, r6, pc}

10000814 <Cy_SysClk_PllGetFrequency>:
    uint32_t rDiv;    /* PLL reference divider */
    uint32_t oDiv;    /* PLL output divider */
    bool  enabled;    /* PLL enable status; n/a for direct */
    uint32_t freq=0UL;    /* PLL Frequency */

    if((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10000814:	4b25      	ldr	r3, [pc, #148]	; (100008ac <Cy_SysClk_PllGetFrequency+0x98>)
10000816:	681b      	ldr	r3, [r3, #0]
10000818:	f893 203f 	ldrb.w	r2, [r3, #63]	; 0x3f
1000081c:	2a00      	cmp	r2, #0
1000081e:	d043      	beq.n	100008a8 <Cy_SysClk_PllGetFrequency+0x94>
{
10000820:	b5f0      	push	{r4, r5, r6, r7, lr}
10000822:	b083      	sub	sp, #12
10000824:	4604      	mov	r4, r0
    if((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
10000826:	b158      	cbz	r0, 10000840 <Cy_SysClk_PllGetFrequency+0x2c>
    {
        CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10000828:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
1000082c:	4283      	cmp	r3, r0
1000082e:	d800      	bhi.n	10000832 <Cy_SysClk_PllGetFrequency+0x1e>
10000830:	be01      	bkpt	0x0001

        if (clkPath <= CY_SRSS_NUM_PLL)
10000832:	4b1e      	ldr	r3, [pc, #120]	; (100008ac <Cy_SysClk_PllGetFrequency+0x98>)
10000834:	681b      	ldr	r3, [r3, #0]
10000836:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
1000083a:	42a3      	cmp	r3, r4
1000083c:	d202      	bcs.n	10000844 <Cy_SysClk_PllGetFrequency+0x30>
    uint32_t freq=0UL;    /* PLL Frequency */
1000083e:	2000      	movs	r0, #0
            }
        }
    }

    return (freq);
}
10000840:	b003      	add	sp, #12
10000842:	bdf0      	pop	{r4, r5, r6, r7, pc}
            cy_stc_pll_manual_config_t pllcfg = {0U,0U,0U,false,CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
10000844:	2300      	movs	r3, #0
10000846:	9300      	str	r3, [sp, #0]
10000848:	f88d 3004 	strb.w	r3, [sp, #4]
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &pllcfg);
1000084c:	4669      	mov	r1, sp
1000084e:	4620      	mov	r0, r4
10000850:	f7ff ff86 	bl	10000760 <Cy_SysClk_PllGetConfiguration>
            enabled = (Cy_SysClk_PllIsEnabled(clkPath)) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != pllcfg.outputMode);
10000854:	4620      	mov	r0, r4
10000856:	f7ff ff6f 	bl	10000738 <Cy_SysClk_PllIsEnabled>
1000085a:	b138      	cbz	r0, 1000086c <Cy_SysClk_PllGetFrequency+0x58>
1000085c:	f89d 3004 	ldrb.w	r3, [sp, #4]
10000860:	2b02      	cmp	r3, #2
10000862:	d001      	beq.n	10000868 <Cy_SysClk_PllGetFrequency+0x54>
10000864:	2301      	movs	r3, #1
10000866:	e002      	b.n	1000086e <Cy_SysClk_PllGetFrequency+0x5a>
10000868:	2300      	movs	r3, #0
1000086a:	e000      	b.n	1000086e <Cy_SysClk_PllGetFrequency+0x5a>
1000086c:	2300      	movs	r3, #0
            fDiv = pllcfg.feedbackDiv;
1000086e:	f89d 7000 	ldrb.w	r7, [sp]
            rDiv = pllcfg.referenceDiv;
10000872:	f89d 5001 	ldrb.w	r5, [sp, #1]
10000876:	4628      	mov	r0, r5
            oDiv = pllcfg.outputDiv;
10000878:	f89d 6002 	ldrb.w	r6, [sp, #2]
            if (enabled && /* If PLL is enabled and not bypassed */
1000087c:	b193      	cbz	r3, 100008a4 <Cy_SysClk_PllGetFrequency+0x90>
1000087e:	2d00      	cmp	r5, #0
10000880:	d0de      	beq.n	10000840 <Cy_SysClk_PllGetFrequency+0x2c>
            (0UL != rDiv) && (0UL != oDiv)) /* to avoid division by zero */
10000882:	b90e      	cbnz	r6, 10000888 <Cy_SysClk_PllGetFrequency+0x74>
    uint32_t freq=0UL;    /* PLL Frequency */
10000884:	4630      	mov	r0, r6
10000886:	e7db      	b.n	10000840 <Cy_SysClk_PllGetFrequency+0x2c>
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
10000888:	4620      	mov	r0, r4
1000088a:	f7ff fec7 	bl	1000061c <Cy_SysClk_ClkPathMuxGetFrequency>
                freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
1000088e:	fba0 7107 	umull	r7, r1, r0, r7
10000892:	fba5 2306 	umull	r2, r3, r5, r6
10000896:	0850      	lsrs	r0, r2, #1
10000898:	1838      	adds	r0, r7, r0
1000089a:	f141 0100 	adc.w	r1, r1, #0
1000089e:	f000 fb0f 	bl	10000ec0 <__aeabi_uldivmod>
100008a2:	e7cd      	b.n	10000840 <Cy_SysClk_PllGetFrequency+0x2c>
    uint32_t freq=0UL;    /* PLL Frequency */
100008a4:	2000      	movs	r0, #0
100008a6:	e7cb      	b.n	10000840 <Cy_SysClk_PllGetFrequency+0x2c>
100008a8:	2000      	movs	r0, #0
}
100008aa:	4770      	bx	lr
100008ac:	080001a0 	.word	0x080001a0

100008b0 <Cy_SysClk_ClkPathGetFrequency>:
{
100008b0:	b510      	push	{r4, lr}
100008b2:	4604      	mov	r4, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
100008b4:	4b0d      	ldr	r3, [pc, #52]	; (100008ec <Cy_SysClk_ClkPathGetFrequency+0x3c>)
100008b6:	681b      	ldr	r3, [r3, #0]
100008b8:	f893 303e 	ldrb.w	r3, [r3, #62]	; 0x3e
100008bc:	4283      	cmp	r3, r0
100008be:	d800      	bhi.n	100008c2 <Cy_SysClk_ClkPathGetFrequency+0x12>
100008c0:	be01      	bkpt	0x0001
    if (clkPath == (uint32_t)CY_SYSCLK_CLKHF_IN_CLKPATH0) /* FLL? (always path 0) */
100008c2:	b14c      	cbz	r4, 100008d8 <Cy_SysClk_ClkPathGetFrequency+0x28>
    else if (clkPath <= CY_SRSS_NUM_PLL) /* PLL? (always path 1...N)*/
100008c4:	4b09      	ldr	r3, [pc, #36]	; (100008ec <Cy_SysClk_ClkPathGetFrequency+0x3c>)
100008c6:	681b      	ldr	r3, [r3, #0]
100008c8:	f893 303f 	ldrb.w	r3, [r3, #63]	; 0x3f
100008cc:	42a3      	cmp	r3, r4
100008ce:	d208      	bcs.n	100008e2 <Cy_SysClk_ClkPathGetFrequency+0x32>
        freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
100008d0:	4620      	mov	r0, r4
100008d2:	f7ff fea3 	bl	1000061c <Cy_SysClk_ClkPathMuxGetFrequency>
}
100008d6:	bd10      	pop	{r4, pc}
        freq = Cy_SysClk_FllGetFrequency();
100008d8:	f7ff ff68 	bl	100007ac <Cy_SysClk_FllGetFrequency>
    if(freq==0UL)
100008dc:	2800      	cmp	r0, #0
100008de:	d1fa      	bne.n	100008d6 <Cy_SysClk_ClkPathGetFrequency+0x26>
100008e0:	e7f6      	b.n	100008d0 <Cy_SysClk_ClkPathGetFrequency+0x20>
        freq = Cy_SysClk_PllGetFrequency(clkPath);
100008e2:	4620      	mov	r0, r4
100008e4:	f7ff ff96 	bl	10000814 <Cy_SysClk_PllGetFrequency>
100008e8:	e7f8      	b.n	100008dc <Cy_SysClk_ClkPathGetFrequency+0x2c>
100008ea:	bf00      	nop
100008ec:	080001a0 	.word	0x080001a0

100008f0 <Cy_SysClk_ClkHfGetFrequency>:
{
100008f0:	b570      	push	{r4, r5, r6, lr}
100008f2:	4606      	mov	r6, r0
    uint32_t pDiv = 1UL << (uint32_t)Cy_SysClk_ClkHfGetDivider(clkHf); /* root prescaler (1/2/4/8) */
100008f4:	f7ff fe32 	bl	1000055c <Cy_SysClk_ClkHfGetDivider>
100008f8:	4604      	mov	r4, r0
100008fa:	2501      	movs	r5, #1
100008fc:	4085      	lsls	r5, r0
    uint32_t path = (uint32_t) Cy_SysClk_ClkHfGetSource(clkHf); /* path input for root 0 (clkHf[0]) */
100008fe:	4630      	mov	r0, r6
10000900:	f7ff fe1a 	bl	10000538 <Cy_SysClk_ClkHfGetSource>
    uint32_t freq = Cy_SysClk_ClkPathGetFrequency(path);
10000904:	f7ff ffd4 	bl	100008b0 <Cy_SysClk_ClkPathGetFrequency>
    return (CY_SYSLIB_DIV_ROUND(freq, pDiv));
10000908:	eb00 0055 	add.w	r0, r0, r5, lsr #1
}
1000090c:	40e0      	lsrs	r0, r4
1000090e:	bd70      	pop	{r4, r5, r6, pc}

10000910 <Cy_SysIpcPipeIsrCm0>:
*
* This is the interrupt service routine for the system pipe.
*
*******************************************************************************/
void Cy_SysIpcPipeIsrCm0(void)
{
10000910:	b508      	push	{r3, lr}
    Cy_IPC_Pipe_ExecuteCallback(CY_IPC_EP_CYPIPE_CM0_ADDR);
10000912:	2000      	movs	r0, #0
10000914:	f7ff fcda 	bl	100002cc <Cy_IPC_Pipe_ExecuteCallback>
}
10000918:	bd08      	pop	{r3, pc}

1000091a <Cy_SystemInit>:
}
1000091a:	4770      	bx	lr

1000091c <SystemCoreClockUpdate>:
{
1000091c:	b510      	push	{r4, lr}
    uint32 locHf0Clock = Cy_SysClk_ClkHfGetFrequency(0UL);
1000091e:	2000      	movs	r0, #0
10000920:	f7ff ffe6 	bl	100008f0 <Cy_SysClk_ClkHfGetFrequency>
    if (0UL != locHf0Clock)
10000924:	b900      	cbnz	r0, 10000928 <SystemCoreClockUpdate+0xc>
}
10000926:	bd10      	pop	{r4, pc}
10000928:	4604      	mov	r4, r0
        cy_Hfclk0FreqHz = locHf0Clock;
1000092a:	4b11      	ldr	r3, [pc, #68]	; (10000970 <SystemCoreClockUpdate+0x54>)
1000092c:	6018      	str	r0, [r3, #0]
        cy_PeriClkFreqHz = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkPeriGetDivider());
1000092e:	f7ff fdf9 	bl	10000524 <Cy_SysClk_ClkPeriGetDivider>
10000932:	3001      	adds	r0, #1
10000934:	fbb4 f4f0 	udiv	r4, r4, r0
10000938:	4b0e      	ldr	r3, [pc, #56]	; (10000974 <SystemCoreClockUpdate+0x58>)
1000093a:	601c      	str	r4, [r3, #0]
        SystemCoreClock = cy_PeriClkFreqHz / (1UL + (uint32_t)Cy_SysClk_ClkSlowGetDivider());
1000093c:	f7ff fde6 	bl	1000050c <Cy_SysClk_ClkSlowGetDivider>
10000940:	3001      	adds	r0, #1
10000942:	fbb4 f4f0 	udiv	r4, r4, r0
10000946:	4b0c      	ldr	r3, [pc, #48]	; (10000978 <SystemCoreClockUpdate+0x5c>)
10000948:	601c      	str	r4, [r3, #0]
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
1000094a:	3c01      	subs	r4, #1
1000094c:	4b0b      	ldr	r3, [pc, #44]	; (1000097c <SystemCoreClockUpdate+0x60>)
1000094e:	fba3 2304 	umull	r2, r3, r3, r4
10000952:	0c9b      	lsrs	r3, r3, #18
10000954:	3301      	adds	r3, #1
10000956:	4a0a      	ldr	r2, [pc, #40]	; (10000980 <SystemCoreClockUpdate+0x64>)
10000958:	7013      	strb	r3, [r2, #0]
        cy_delayFreqKhz = CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1K_THRESHOLD);
1000095a:	4b0a      	ldr	r3, [pc, #40]	; (10000984 <SystemCoreClockUpdate+0x68>)
1000095c:	fba3 2304 	umull	r2, r3, r3, r4
10000960:	099b      	lsrs	r3, r3, #6
10000962:	3301      	adds	r3, #1
10000964:	4a08      	ldr	r2, [pc, #32]	; (10000988 <SystemCoreClockUpdate+0x6c>)
10000966:	6013      	str	r3, [r2, #0]
        cy_delay32kMs   = CY_DELAY_MS_OVERFLOW_THRESHOLD * cy_delayFreqKhz;
10000968:	03db      	lsls	r3, r3, #15
1000096a:	4a08      	ldr	r2, [pc, #32]	; (1000098c <SystemCoreClockUpdate+0x70>)
1000096c:	6013      	str	r3, [r2, #0]
}
1000096e:	e7da      	b.n	10000926 <SystemCoreClockUpdate+0xa>
10000970:	08000084 	.word	0x08000084
10000974:	08000088 	.word	0x08000088
10000978:	08000080 	.word	0x08000080
1000097c:	431bde83 	.word	0x431bde83
10000980:	08000094 	.word	0x08000094
10000984:	10624dd3 	.word	0x10624dd3
10000988:	08000090 	.word	0x08000090
1000098c:	0800008c 	.word	0x0800008c

10000990 <SystemInit>:
{
10000990:	b510      	push	{r4, lr}
    Cy_PDL_Init(CY_DEVICE_CFG);
10000992:	4823      	ldr	r0, [pc, #140]	; (10000a20 <SystemInit+0x90>)
10000994:	f7ff fb94 	bl	100000c0 <Cy_PDL_Init>
    uint32_t copy = SRSS->CLK_FLL_CONFIG;
10000998:	4c22      	ldr	r4, [pc, #136]	; (10000a24 <SystemInit+0x94>)
1000099a:	f8d4 3580 	ldr.w	r3, [r4, #1408]	; 0x580
    copy &= ~SRSS_CLK_FLL_CONFIG_FLL_ENABLE_Msk;
1000099e:	f023 4300 	bic.w	r3, r3, #2147483648	; 0x80000000
    SRSS->CLK_FLL_CONFIG = copy;
100009a2:	f8c4 3580 	str.w	r3, [r4, #1408]	; 0x580
    copy = SRSS->CLK_ROOT_SELECT[0u];
100009a6:	f8d4 3380 	ldr.w	r3, [r4, #896]	; 0x380
    copy &= ~SRSS_CLK_ROOT_SELECT_ROOT_DIV_Msk; /* Set ROOT_DIV = 0*/
100009aa:	f023 0330 	bic.w	r3, r3, #48	; 0x30
    SRSS->CLK_ROOT_SELECT[0u] = copy;
100009ae:	f8c4 3380 	str.w	r3, [r4, #896]	; 0x380
    SRSS->CLK_FLL_CONFIG  = CY_FB_CLK_FLL_CONFIG_VALUE;
100009b2:	f04f 7380 	mov.w	r3, #16777216	; 0x1000000
100009b6:	f8c4 3580 	str.w	r3, [r4, #1408]	; 0x580
    SRSS->CLK_FLL_CONFIG2 = CY_FB_CLK_FLL_CONFIG2_VALUE;
100009ba:	4b1b      	ldr	r3, [pc, #108]	; (10000a28 <SystemInit+0x98>)
100009bc:	f8c4 3584 	str.w	r3, [r4, #1412]	; 0x584
    SRSS->CLK_FLL_CONFIG3 = CY_FB_CLK_FLL_CONFIG3_VALUE;
100009c0:	f44f 5320 	mov.w	r3, #10240	; 0x2800
100009c4:	f8c4 3588 	str.w	r3, [r4, #1416]	; 0x588
    SRSS->CLK_FLL_CONFIG4 = CY_FB_CLK_FLL_CONFIG4_VALUE;
100009c8:	23ff      	movs	r3, #255	; 0xff
100009ca:	f8c4 358c 	str.w	r3, [r4, #1420]	; 0x58c
    Cy_WDT_Unlock();
100009ce:	f7ff fd3b 	bl	10000448 <Cy_WDT_Unlock>
* disabled. Call the Cy_WDT_Unlock() API to unlock the WDT.
*
*******************************************************************************/
__STATIC_INLINE void Cy_WDT_Disable(void)
{
    SRSS_WDT_CTL &= ((uint32_t) ~(_VAL2FLD(SRSS_WDT_CTL_WDT_EN, 1U)));
100009d2:	f8d4 3180 	ldr.w	r3, [r4, #384]	; 0x180
100009d6:	f023 0301 	bic.w	r3, r3, #1
100009da:	f8c4 3180 	str.w	r3, [r4, #384]	; 0x180
    Cy_SystemInit();
100009de:	f7ff ff9c 	bl	1000091a <Cy_SystemInit>
    SystemCoreClockUpdate();
100009e2:	f7ff ff9b 	bl	1000091c <SystemCoreClockUpdate>
    REG_IPC_STRUCT_DATA(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT)) = 0UL;
100009e6:	4b11      	ldr	r3, [pc, #68]	; (10000a2c <SystemInit+0x9c>)
100009e8:	681a      	ldr	r2, [r3, #0]
100009ea:	6a11      	ldr	r1, [r2, #32]
100009ec:	f8b2 30ba 	ldrh.w	r3, [r2, #186]	; 0xba
100009f0:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
100009f4:	440b      	add	r3, r1
100009f6:	2000      	movs	r0, #0
100009f8:	60d8      	str	r0, [r3, #12]
    REG_IPC_STRUCT_RELEASE(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT)) = 0UL;
100009fa:	6a11      	ldr	r1, [r2, #32]
100009fc:	f8b2 30ba 	ldrh.w	r3, [r2, #186]	; 0xba
10000a00:	ebc3 03c3 	rsb	r3, r3, r3, lsl #3
10000a04:	440b      	add	r3, r1
10000a06:	6058      	str	r0, [r3, #4]
    (void) Cy_IPC_Sema_Init(CY_IPC_CHAN_SEMA, CY_IPC_SEMA_COUNT, ipcSemaArray);
10000a08:	4a09      	ldr	r2, [pc, #36]	; (10000a30 <SystemInit+0xa0>)
10000a0a:	2180      	movs	r1, #128	; 0x80
10000a0c:	2003      	movs	r0, #3
10000a0e:	f7ff fcef 	bl	100003f0 <Cy_IPC_Sema_Init>
    Cy_IPC_Pipe_Config(systemIpcPipeEpArray);
10000a12:	4808      	ldr	r0, [pc, #32]	; (10000a34 <SystemInit+0xa4>)
10000a14:	f7ff fb5a 	bl	100000cc <Cy_IPC_Pipe_Config>
    Cy_IPC_Pipe_Init(&systemIpcPipeConfigCm0);
10000a18:	4807      	ldr	r0, [pc, #28]	; (10000a38 <SystemInit+0xa8>)
10000a1a:	f7ff fbaf 	bl	1000017c <Cy_IPC_Pipe_Init>
}
10000a1e:	bd10      	pop	{r4, pc}
10000a20:	100011ec 	.word	0x100011ec
10000a24:	40260000 	.word	0x40260000
10000a28:	00020001 	.word	0x00020001
10000a2c:	080001a0 	.word	0x080001a0
10000a30:	080000dc 	.word	0x080000dc
10000a34:	080001b4 	.word	0x080001b4
10000a38:	100012ac 	.word	0x100012ac

10000a3c <Cy_OnResetUser>:
    .weak   Cy_OnResetUser
    .func   Cy_OnResetUser, Cy_OnResetUser
    .type   Cy_OnResetUser, %function

Cy_OnResetUser:
    bx lr
10000a3c:	4770      	bx	lr

10000a3e <Reset_Handler>:
    /* Reset handler */
    .weak    Reset_Handler
    .type    Reset_Handler, %function

Reset_Handler:
    bl Cy_OnResetUser
10000a3e:	f7ff fffd 	bl	10000a3c <Cy_OnResetUser>
    cpsid i
10000a42:	b672      	cpsid	i
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
10000a44:	4c0f      	ldr	r4, [pc, #60]	; (10000a84 <Reset_Handler+0x46>)
    ldr    r5, =__copy_table_end__
10000a46:	4d10      	ldr	r5, [pc, #64]	; (10000a88 <Reset_Handler+0x4a>)

.L_loop0:
    cmp    r4, r5
10000a48:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
10000a4a:	da09      	bge.n	10000a60 <Reset_Handler+0x22>
    ldr    r1, [r4]
10000a4c:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
10000a4e:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
10000a50:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
10000a52:	3b04      	subs	r3, #4
    blt    .L_loop0_0_done
10000a54:	db02      	blt.n	10000a5c <Reset_Handler+0x1e>
    ldr    r0, [r1, r3]
10000a56:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2, r3]
10000a58:	50d0      	str	r0, [r2, r3]
    b    .L_loop0_0
10000a5a:	e7fa      	b.n	10000a52 <Reset_Handler+0x14>

.L_loop0_0_done:
    adds    r4, #12
10000a5c:	340c      	adds	r4, #12
    b    .L_loop0
10000a5e:	e7f3      	b.n	10000a48 <Reset_Handler+0xa>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
    ldr    r1, =__bss_start__
10000a60:	490a      	ldr	r1, [pc, #40]	; (10000a8c <Reset_Handler+0x4e>)
    ldr    r2, =__bss_end__
10000a62:	4a0b      	ldr	r2, [pc, #44]	; (10000a90 <Reset_Handler+0x52>)

    movs    r0, 0
10000a64:	2000      	movs	r0, #0

    subs    r2, r1
10000a66:	1a52      	subs	r2, r2, r1
    ble    .L_loop3_done
10000a68:	dd02      	ble.n	10000a70 <Reset_Handler+0x32>

.L_loop3:
    subs    r2, #4
10000a6a:	3a04      	subs	r2, #4
    str    r0, [r1, r2]
10000a6c:	5088      	str	r0, [r1, r2]
    bgt    .L_loop3
10000a6e:	dcfc      	bgt.n	10000a6a <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

    /* Update Vector Table Offset Register. */
    ldr r0, =__ramVectors
10000a70:	4808      	ldr	r0, [pc, #32]	; (10000a94 <Reset_Handler+0x56>)
    ldr r1, =CY_CPU_VTOR_ADDR
10000a72:	4909      	ldr	r1, [pc, #36]	; (10000a98 <Reset_Handler+0x5a>)
    str r0, [r1]
10000a74:	6008      	str	r0, [r1, #0]
    dsb 0xF
10000a76:	f3bf 8f4f 	dsb	sy

#ifndef __NO_SYSTEM_INIT
    bl    SystemInit
10000a7a:	f7ff ff89 	bl	10000990 <SystemInit>
#endif

    bl    main
10000a7e:	f000 fa0b 	bl	10000e98 <main>

    /* Should never get here */
    b   .
10000a82:	e7fe      	b.n	10000a82 <Reset_Handler+0x44>
    ldr    r4, =__copy_table_start__
10000a84:	100012ec 	.word	0x100012ec
    ldr    r5, =__copy_table_end__
10000a88:	10001304 	.word	0x10001304
    ldr    r1, =__bss_start__
10000a8c:	08000184 	.word	0x08000184
    ldr    r2, =__bss_end__
10000a90:	08000334 	.word	0x08000334
    ldr r0, =__ramVectors
10000a94:	08000000 	.word	0x08000000
    ldr r1, =CY_CPU_VTOR_ADDR
10000a98:	e000ed08 	.word	0xe000ed08

10000a9c <Default_Handler>:
    .align    1
    .thumb_func
    .weak    Default_Handler
    .type    Default_Handler, %function
Default_Handler:
    b    .
10000a9c:	e7fe      	b.n	10000a9c <Default_Handler>
    .size    Default_Handler, . - Default_Handler
    .weak    Cy_SysLib_FaultHandler
    .type    Cy_SysLib_FaultHandler, %function

Cy_SysLib_FaultHandler:
    b    .
10000a9e:	e7fe      	b.n	10000a9e <Default_Handler+0x2>

10000aa0 <HardFault_Handler>:
    .size    Cy_SysLib_FaultHandler, . - Cy_SysLib_FaultHandler
    .type Fault_Handler, %function

Fault_Handler:
    /* Storing LR content for Creator call stack trace */
    push {LR}
10000aa0:	b500      	push	{lr}
    movs r0, #4
10000aa2:	2004      	movs	r0, #4
    mov r1, LR
10000aa4:	4671      	mov	r1, lr
    tst r0, r1
10000aa6:	4208      	tst	r0, r1
    beq .L_MSP
10000aa8:	d002      	beq.n	10000ab0 <HardFault_Handler+0x10>
    mrs r0, PSP
10000aaa:	f3ef 8009 	mrs	r0, PSP
    b .L_API_call
10000aae:	e002      	b.n	10000ab6 <HardFault_Handler+0x16>
.L_MSP:
    mrs r0, MSP
10000ab0:	f3ef 8008 	mrs	r0, MSP
    /* Compensation of stack pointer address due to pushing 4 bytes of LR */
    adds r0, r0, #4
10000ab4:	3004      	adds	r0, #4
.L_API_call:
    bl Cy_SysLib_FaultHandler
10000ab6:	f000 f98b 	bl	10000dd0 <Cy_SysLib_FaultHandler>
    b   .
10000aba:	e7fe      	b.n	10000aba <HardFault_Handler+0x1a>

10000abc <Cy_GPIO_SetHSIOM>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetHSIOM
*
*******************************************************************************/
void Cy_GPIO_SetHSIOM(GPIO_PRT_Type* base, uint32_t pinNum, en_hsiom_sel_t value)
{
10000abc:	b510      	push	{r4, lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000abe:	2907      	cmp	r1, #7
10000ac0:	d900      	bls.n	10000ac4 <Cy_GPIO_SetHSIOM+0x8>
10000ac2:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(value));
10000ac4:	f032 031f 	bics.w	r3, r2, #31
10000ac8:	d000      	beq.n	10000acc <Cy_GPIO_SetHSIOM+0x10>
10000aca:	be01      	bkpt	0x0001

    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
10000acc:	4b16      	ldr	r3, [pc, #88]	; (10000b28 <Cy_GPIO_SetHSIOM+0x6c>)
10000ace:	681b      	ldr	r3, [r3, #0]
10000ad0:	699c      	ldr	r4, [r3, #24]
10000ad2:	1b00      	subs	r0, r0, r4
10000ad4:	09c0      	lsrs	r0, r0, #7
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
10000ad6:	695b      	ldr	r3, [r3, #20]
10000ad8:	ea4f 1c00 	mov.w	ip, r0, lsl #4
10000adc:	eb03 1000 	add.w	r0, r3, r0, lsl #4

    #if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
        pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
    #endif

    if(pinNum < CY_GPIO_PRT_HALF)
10000ae0:	2903      	cmp	r1, #3
10000ae2:	d810      	bhi.n	10000b06 <Cy_GPIO_SetHSIOM+0x4a>
        {
            /* secure pin */
            tempReg = 0UL;
        }
    #else
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000ae4:	f853 000c 	ldr.w	r0, [r3, ip]
10000ae8:	00c9      	lsls	r1, r1, #3
10000aea:	f04f 0e1f 	mov.w	lr, #31
10000aee:	fa0e fe01 	lsl.w	lr, lr, r1
10000af2:	ea20 000e 	bic.w	r0, r0, lr
    #endif
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000af6:	f002 021f 	and.w	r2, r2, #31
10000afa:	fa02 f101 	lsl.w	r1, r2, r1
10000afe:	4301      	orrs	r1, r0
        else
        {
            /* Secure PIN can't be modified using register policy */
        }
    #else
        HSIOM_PRT_PORT_SEL0(portAddrHSIOM) = hsiomReg;
10000b00:	f843 100c 	str.w	r1, [r3, ip]
        }
    #else
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
    #endif
    }
}
10000b04:	bd10      	pop	{r4, pc}
        pinNum -= CY_GPIO_PRT_HALF;
10000b06:	3904      	subs	r1, #4
        tempReg = HSIOM_PRT_PORT_SEL1(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000b08:	6843      	ldr	r3, [r0, #4]
10000b0a:	00c9      	lsls	r1, r1, #3
10000b0c:	f04f 0c1f 	mov.w	ip, #31
10000b10:	fa0c fc01 	lsl.w	ip, ip, r1
10000b14:	ea23 030c 	bic.w	r3, r3, ip
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000b18:	f002 021f 	and.w	r2, r2, #31
10000b1c:	fa02 f101 	lsl.w	r1, r2, r1
10000b20:	4319      	orrs	r1, r3
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
10000b22:	6041      	str	r1, [r0, #4]
}
10000b24:	e7ee      	b.n	10000b04 <Cy_GPIO_SetHSIOM+0x48>
10000b26:	bf00      	nop
10000b28:	080001a0 	.word	0x080001a0

10000b2c <Cy_GPIO_Write>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000b2c:	2907      	cmp	r1, #7
10000b2e:	d900      	bls.n	10000b32 <Cy_GPIO_Write+0x6>
10000b30:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000b32:	2a01      	cmp	r2, #1
10000b34:	d900      	bls.n	10000b38 <Cy_GPIO_Write+0xc>
10000b36:	be01      	bkpt	0x0001

    outMask = CY_GPIO_OUT_MASK << pinNum;
10000b38:	2301      	movs	r3, #1
10000b3a:	fa03 f101 	lsl.w	r1, r3, r1
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    /* Thread-safe: Directly access the pin registers instead of base->OUT */
    if(0UL == value)
10000b3e:	b90a      	cbnz	r2, 10000b44 <Cy_GPIO_Write+0x18>
    {
        GPIO_PRT_OUT_CLR(base) = outMask;
10000b40:	6041      	str	r1, [r0, #4]
10000b42:	4770      	bx	lr
    }
    else
    {
        GPIO_PRT_OUT_SET(base) = outMask;
10000b44:	6081      	str	r1, [r0, #8]
    }
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000b46:	4770      	bx	lr

10000b48 <Cy_GPIO_Inv>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000b48:	2907      	cmp	r1, #7
10000b4a:	d900      	bls.n	10000b4e <Cy_GPIO_Inv+0x6>
10000b4c:	be01      	bkpt	0x0001

    outMask = CY_GPIO_OUT_MASK << pinNum;
10000b4e:	2301      	movs	r3, #1
10000b50:	fa03 f101 	lsl.w	r1, r3, r1
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_OUT_INV(base) = outMask;
10000b54:	60c1      	str	r1, [r0, #12]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000b56:	4770      	bx	lr

10000b58 <Cy_GPIO_SetDrivemode>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetDrivemode
*
*******************************************************************************/
void Cy_GPIO_SetDrivemode(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000b58:	b500      	push	{lr}
    uint32_t prtCfg;
#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000b5a:	2907      	cmp	r1, #7
10000b5c:	d900      	bls.n	10000b60 <Cy_GPIO_SetDrivemode+0x8>
10000b5e:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(value));
10000b60:	f032 030f 	bics.w	r3, r2, #15
10000b64:	d103      	bne.n	10000b6e <Cy_GPIO_SetDrivemode+0x16>
10000b66:	2a01      	cmp	r2, #1
10000b68:	d001      	beq.n	10000b6e <Cy_GPIO_SetDrivemode+0x16>
10000b6a:	2a09      	cmp	r2, #9
10000b6c:	d100      	bne.n	10000b70 <Cy_GPIO_SetDrivemode+0x18>
10000b6e:	be01      	bkpt	0x0001

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    pinLoc = pinNum << CY_GPIO_DRIVE_MODE_OFFSET;
10000b70:	0089      	lsls	r1, r1, #2
    {
        /* secure pin */
        tempReg = 0;
    }
#else
    tempReg = (GPIO_PRT_CFG(base) & ~(CY_GPIO_CFG_DM_MASK << pinLoc));
10000b72:	4b0a      	ldr	r3, [pc, #40]	; (10000b9c <Cy_GPIO_SetDrivemode+0x44>)
10000b74:	681b      	ldr	r3, [r3, #0]
10000b76:	f893 e081 	ldrb.w	lr, [r3, #129]	; 0x81
10000b7a:	f85e 3000 	ldr.w	r3, [lr, r0]
10000b7e:	f04f 0c0f 	mov.w	ip, #15
10000b82:	fa0c fc01 	lsl.w	ip, ip, r1
10000b86:	ea23 030c 	bic.w	r3, r3, ip
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */
    prtCfg = tempReg | ((value & CY_GPIO_CFG_DM_MASK) << pinLoc);
10000b8a:	f002 020f 	and.w	r2, r2, #15
10000b8e:	408a      	lsls	r2, r1
10000b90:	431a      	orrs	r2, r3
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_CFG(base) = prtCfg;
10000b92:	f84e 2000 	str.w	r2, [lr, r0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000b96:	f85d fb04 	ldr.w	pc, [sp], #4
10000b9a:	bf00      	nop
10000b9c:	080001a0 	.word	0x080001a0

10000ba0 <Cy_GPIO_SetVtrip>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetVtrip
*
*******************************************************************************/
void Cy_GPIO_SetVtrip(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000ba0:	b500      	push	{lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000ba2:	2907      	cmp	r1, #7
10000ba4:	d900      	bls.n	10000ba8 <Cy_GPIO_SetVtrip+0x8>
10000ba6:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000ba8:	2a01      	cmp	r2, #1
10000baa:	d900      	bls.n	10000bae <Cy_GPIO_SetVtrip+0xe>
10000bac:	be01      	bkpt	0x0001
    }
#else
    tempReg = GPIO_PRT_CFG_IN(base) & ~(CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK << pinNum);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg = GPIO_PRT_CFG_IN(base) & ~(CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK << pinNum);
10000bae:	4b0a      	ldr	r3, [pc, #40]	; (10000bd8 <Cy_GPIO_SetVtrip+0x38>)
10000bb0:	681b      	ldr	r3, [r3, #0]
10000bb2:	f893 e082 	ldrb.w	lr, [r3, #130]	; 0x82
10000bb6:	f85e 3000 	ldr.w	r3, [lr, r0]
10000bba:	f04f 0c01 	mov.w	ip, #1
10000bbe:	fa0c fc01 	lsl.w	ip, ip, r1
10000bc2:	ea23 030c 	bic.w	r3, r3, ip
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    cfgIn = tempReg | ((value & CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK) << pinNum);
10000bc6:	f002 0201 	and.w	r2, r2, #1
10000bca:	408a      	lsls	r2, r1
10000bcc:	431a      	orrs	r2, r3
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_CFG_IN(base) = cfgIn;
10000bce:	f84e 2000 	str.w	r2, [lr, r0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000bd2:	f85d fb04 	ldr.w	pc, [sp], #4
10000bd6:	bf00      	nop
10000bd8:	080001a0 	.word	0x080001a0

10000bdc <Cy_GPIO_SetInterruptMask>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10000bdc:	2908      	cmp	r1, #8
10000bde:	d900      	bls.n	10000be2 <Cy_GPIO_SetInterruptMask+0x6>
10000be0:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000be2:	2a01      	cmp	r2, #1
10000be4:	d900      	bls.n	10000be8 <Cy_GPIO_SetInterruptMask+0xc>
10000be6:	be01      	bkpt	0x0001
    }
#else
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
10000be8:	6983      	ldr	r3, [r0, #24]
10000bea:	f04f 0c01 	mov.w	ip, #1
10000bee:	fa0c fc01 	lsl.w	ip, ip, r1
10000bf2:	ea23 030c 	bic.w	r3, r3, ip
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    intrMask = tempReg | ((value & CY_GPIO_INTR_EN_MASK) << pinNum);
10000bf6:	f002 0201 	and.w	r2, r2, #1
10000bfa:	408a      	lsls	r2, r1
10000bfc:	431a      	orrs	r2, r3
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_INTR_MASK(base) = intrMask;
10000bfe:	6182      	str	r2, [r0, #24]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000c00:	4770      	bx	lr
	...

10000c04 <Cy_GPIO_SetInterruptEdge>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetInterruptEdge
*
*******************************************************************************/
void Cy_GPIO_SetInterruptEdge(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000c04:	b500      	push	{lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10000c06:	2908      	cmp	r1, #8
10000c08:	d900      	bls.n	10000c0c <Cy_GPIO_SetInterruptEdge+0x8>
10000c0a:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_INT_EDGE_VALID(value));
10000c0c:	2a03      	cmp	r2, #3
10000c0e:	d900      	bls.n	10000c12 <Cy_GPIO_SetInterruptEdge+0xe>
10000c10:	be01      	bkpt	0x0001

    pinLoc = pinNum << CY_GPIO_INTR_CFG_OFFSET;
10000c12:	0049      	lsls	r1, r1, #1
    }
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
10000c14:	4b09      	ldr	r3, [pc, #36]	; (10000c3c <Cy_GPIO_SetInterruptEdge+0x38>)
10000c16:	681b      	ldr	r3, [r3, #0]
10000c18:	f893 e080 	ldrb.w	lr, [r3, #128]	; 0x80
10000c1c:	f85e 3000 	ldr.w	r3, [lr, r0]
10000c20:	f04f 0c03 	mov.w	ip, #3
10000c24:	fa0c fc01 	lsl.w	ip, ip, r1
10000c28:	ea23 030c 	bic.w	r3, r3, ip
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    intrCfg = tempReg | ((value & CY_GPIO_INTR_EDGE_MASK) << pinLoc);
10000c2c:	f002 0203 	and.w	r2, r2, #3
10000c30:	408a      	lsls	r2, r1
10000c32:	431a      	orrs	r2, r3
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_INTR_CFG(base) = intrCfg;
10000c34:	f84e 2000 	str.w	r2, [lr, r0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000c38:	f85d fb04 	ldr.w	pc, [sp], #4
10000c3c:	080001a0 	.word	0x080001a0

10000c40 <Cy_GPIO_Pin_Init>:
    if ((NULL != base) && (NULL != config))
10000c40:	2800      	cmp	r0, #0
10000c42:	f000 80a2 	beq.w	10000d8a <Cy_GPIO_Pin_Init+0x14a>
{
10000c46:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10000c48:	460d      	mov	r5, r1
10000c4a:	4614      	mov	r4, r2
10000c4c:	4606      	mov	r6, r0
    if ((NULL != base) && (NULL != config))
10000c4e:	2a00      	cmp	r2, #0
10000c50:	f000 809d 	beq.w	10000d8e <Cy_GPIO_Pin_Init+0x14e>
        CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000c54:	2907      	cmp	r1, #7
10000c56:	d900      	bls.n	10000c5a <Cy_GPIO_Pin_Init+0x1a>
10000c58:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->outVal));
10000c5a:	6823      	ldr	r3, [r4, #0]
10000c5c:	2b01      	cmp	r3, #1
10000c5e:	d900      	bls.n	10000c62 <Cy_GPIO_Pin_Init+0x22>
10000c60:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(config->driveMode));
10000c62:	6863      	ldr	r3, [r4, #4]
10000c64:	f033 020f 	bics.w	r2, r3, #15
10000c68:	d103      	bne.n	10000c72 <Cy_GPIO_Pin_Init+0x32>
10000c6a:	2b01      	cmp	r3, #1
10000c6c:	d001      	beq.n	10000c72 <Cy_GPIO_Pin_Init+0x32>
10000c6e:	2b09      	cmp	r3, #9
10000c70:	d100      	bne.n	10000c74 <Cy_GPIO_Pin_Init+0x34>
10000c72:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(config->hsiom));
10000c74:	7a23      	ldrb	r3, [r4, #8]
10000c76:	f033 031f 	bics.w	r3, r3, #31
10000c7a:	d000      	beq.n	10000c7e <Cy_GPIO_Pin_Init+0x3e>
10000c7c:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_INT_EDGE_VALID(config->intEdge));
10000c7e:	68e3      	ldr	r3, [r4, #12]
10000c80:	2b03      	cmp	r3, #3
10000c82:	d900      	bls.n	10000c86 <Cy_GPIO_Pin_Init+0x46>
10000c84:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->intMask));
10000c86:	6923      	ldr	r3, [r4, #16]
10000c88:	2b01      	cmp	r3, #1
10000c8a:	d900      	bls.n	10000c8e <Cy_GPIO_Pin_Init+0x4e>
10000c8c:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vtrip));
10000c8e:	6963      	ldr	r3, [r4, #20]
10000c90:	2b01      	cmp	r3, #1
10000c92:	d900      	bls.n	10000c96 <Cy_GPIO_Pin_Init+0x56>
10000c94:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vregEn));
10000c96:	6a23      	ldr	r3, [r4, #32]
10000c98:	2b01      	cmp	r3, #1
10000c9a:	d900      	bls.n	10000c9e <Cy_GPIO_Pin_Init+0x5e>
10000c9c:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->ibufMode));
10000c9e:	6a63      	ldr	r3, [r4, #36]	; 0x24
10000ca0:	2b01      	cmp	r3, #1
10000ca2:	d900      	bls.n	10000ca6 <Cy_GPIO_Pin_Init+0x66>
10000ca4:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vtripSel));
10000ca6:	6aa3      	ldr	r3, [r4, #40]	; 0x28
10000ca8:	2b01      	cmp	r3, #1
10000caa:	d900      	bls.n	10000cae <Cy_GPIO_Pin_Init+0x6e>
10000cac:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VREF_SEL_VALID(config->vrefSel));
10000cae:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10000cb0:	2b03      	cmp	r3, #3
10000cb2:	d900      	bls.n	10000cb6 <Cy_GPIO_Pin_Init+0x76>
10000cb4:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VOH_SEL_VALID(config->vohSel));
10000cb6:	6b23      	ldr	r3, [r4, #48]	; 0x30
10000cb8:	2b07      	cmp	r3, #7
10000cba:	d900      	bls.n	10000cbe <Cy_GPIO_Pin_Init+0x7e>
10000cbc:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_DRIVE_SEL_VALID(config->driveSel));
10000cbe:	69e3      	ldr	r3, [r4, #28]
10000cc0:	2b03      	cmp	r3, #3
10000cc2:	d900      	bls.n	10000cc6 <Cy_GPIO_Pin_Init+0x86>
10000cc4:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->slewRate));
10000cc6:	69a3      	ldr	r3, [r4, #24]
10000cc8:	2b01      	cmp	r3, #1
10000cca:	d900      	bls.n	10000cce <Cy_GPIO_Pin_Init+0x8e>
10000ccc:	be01      	bkpt	0x0001
        maskCfgOut = (CY_GPIO_CFG_OUT_SLOW_MASK << pinNum)
10000cce:	2101      	movs	r1, #1
10000cd0:	40a9      	lsls	r1, r5
                     | (CY_GPIO_CFG_OUT_DRIVE_SEL_MASK << ((uint32_t)(pinNum << 1U) + CY_GPIO_CFG_OUT_DRIVE_OFFSET));
10000cd2:	006a      	lsls	r2, r5, #1
10000cd4:	f102 0c10 	add.w	ip, r2, #16
10000cd8:	2303      	movs	r3, #3
10000cda:	fa03 f30c 	lsl.w	r3, r3, ip
        maskCfgOut = (CY_GPIO_CFG_OUT_SLOW_MASK << pinNum)
10000cde:	4319      	orrs	r1, r3
        tempReg = GPIO_PRT_CFG_OUT(base) & ~(maskCfgOut);
10000ce0:	4f2c      	ldr	r7, [pc, #176]	; (10000d94 <Cy_GPIO_Pin_Init+0x154>)
10000ce2:	683b      	ldr	r3, [r7, #0]
10000ce4:	f893 0083 	ldrb.w	r0, [r3, #131]	; 0x83
10000ce8:	5983      	ldr	r3, [r0, r6]
10000cea:	ea23 0101 	bic.w	r1, r3, r1
        tempReg2 = tempReg | ((config->slewRate & CY_GPIO_CFG_OUT_SLOW_MASK) << pinNum)
10000cee:	69a3      	ldr	r3, [r4, #24]
10000cf0:	f003 0301 	and.w	r3, r3, #1
10000cf4:	40ab      	lsls	r3, r5
10000cf6:	430b      	orrs	r3, r1
                            | ((config->driveSel & CY_GPIO_CFG_OUT_DRIVE_SEL_MASK) << ((uint32_t)(pinNum << 1U) + CY_GPIO_CFG_OUT_DRIVE_OFFSET));
10000cf8:	69e2      	ldr	r2, [r4, #28]
10000cfa:	f002 0203 	and.w	r2, r2, #3
10000cfe:	fa02 f20c 	lsl.w	r2, r2, ip
        tempReg2 = tempReg | ((config->slewRate & CY_GPIO_CFG_OUT_SLOW_MASK) << pinNum)
10000d02:	4313      	orrs	r3, r2
        GPIO_PRT_CFG_OUT(base) = tempReg2;
10000d04:	5183      	str	r3, [r0, r6]
        Cy_GPIO_SetHSIOM(base, pinNum, config->hsiom);
10000d06:	7a22      	ldrb	r2, [r4, #8]
10000d08:	4629      	mov	r1, r5
10000d0a:	4630      	mov	r0, r6
10000d0c:	f7ff fed6 	bl	10000abc <Cy_GPIO_SetHSIOM>
        Cy_GPIO_SetDrivemode(base, pinNum, config->driveMode);
10000d10:	6862      	ldr	r2, [r4, #4]
10000d12:	4629      	mov	r1, r5
10000d14:	4630      	mov	r0, r6
10000d16:	f7ff ff1f 	bl	10000b58 <Cy_GPIO_SetDrivemode>
        Cy_GPIO_SetInterruptEdge(base, pinNum, config->intEdge);
10000d1a:	68e2      	ldr	r2, [r4, #12]
10000d1c:	4629      	mov	r1, r5
10000d1e:	4630      	mov	r0, r6
10000d20:	f7ff ff70 	bl	10000c04 <Cy_GPIO_SetInterruptEdge>
        Cy_GPIO_SetInterruptMask(base, pinNum, config->intMask);
10000d24:	6922      	ldr	r2, [r4, #16]
10000d26:	4629      	mov	r1, r5
10000d28:	4630      	mov	r0, r6
10000d2a:	f7ff ff57 	bl	10000bdc <Cy_GPIO_SetInterruptMask>
        Cy_GPIO_SetVtrip(base, pinNum, config->vtrip);
10000d2e:	6962      	ldr	r2, [r4, #20]
10000d30:	4629      	mov	r1, r5
10000d32:	4630      	mov	r0, r6
10000d34:	f7ff ff34 	bl	10000ba0 <Cy_GPIO_SetVtrip>
        tempReg = GPIO_PRT_CFG_SIO(base) & ~(CY_GPIO_SIO_PIN_MASK);
10000d38:	683b      	ldr	r3, [r7, #0]
10000d3a:	f893 1084 	ldrb.w	r1, [r3, #132]	; 0x84
10000d3e:	5870      	ldr	r0, [r6, r1]
10000d40:	f020 00ff 	bic.w	r0, r0, #255	; 0xff
        tempReg2 = tempReg | (((config->vregEn & CY_GPIO_VREG_EN_MASK)
10000d44:	6a23      	ldr	r3, [r4, #32]
10000d46:	f003 0301 	and.w	r3, r3, #1
                                         | ((config->ibufMode & CY_GPIO_IBUF_MASK) << CY_GPIO_IBUF_SHIFT)
10000d4a:	6a62      	ldr	r2, [r4, #36]	; 0x24
10000d4c:	0052      	lsls	r2, r2, #1
10000d4e:	f002 0202 	and.w	r2, r2, #2
10000d52:	4313      	orrs	r3, r2
                                         | ((config->vtripSel & CY_GPIO_VTRIP_SEL_MASK) << CY_GPIO_VTRIP_SEL_SHIFT)
10000d54:	6aa2      	ldr	r2, [r4, #40]	; 0x28
10000d56:	0092      	lsls	r2, r2, #2
10000d58:	f002 0204 	and.w	r2, r2, #4
10000d5c:	4313      	orrs	r3, r2
                                         | ((config->vrefSel & CY_GPIO_VREF_SEL_MASK)  << CY_GPIO_VREF_SEL_SHIFT)
10000d5e:	6ae2      	ldr	r2, [r4, #44]	; 0x2c
10000d60:	00d2      	lsls	r2, r2, #3
10000d62:	f002 0218 	and.w	r2, r2, #24
10000d66:	4313      	orrs	r3, r2
                                         | ((config->vohSel & CY_GPIO_VOH_SEL_MASK) << CY_GPIO_VOH_SEL_SHIFT))
10000d68:	6b22      	ldr	r2, [r4, #48]	; 0x30
10000d6a:	0152      	lsls	r2, r2, #5
10000d6c:	b2d2      	uxtb	r2, r2
10000d6e:	4313      	orrs	r3, r2
                                           << ((pinNum & CY_GPIO_SIO_ODD_PIN_MASK) << CY_GPIO_CFG_SIO_OFFSET));
10000d70:	00aa      	lsls	r2, r5, #2
10000d72:	f402 727e 	and.w	r2, r2, #1016	; 0x3f8
10000d76:	4093      	lsls	r3, r2
        tempReg2 = tempReg | (((config->vregEn & CY_GPIO_VREG_EN_MASK)
10000d78:	4303      	orrs	r3, r0
        GPIO_PRT_CFG_SIO(base) = tempReg2;
10000d7a:	5073      	str	r3, [r6, r1]
        Cy_GPIO_Write(base, pinNum, config->outVal);
10000d7c:	6822      	ldr	r2, [r4, #0]
10000d7e:	4629      	mov	r1, r5
10000d80:	4630      	mov	r0, r6
10000d82:	f7ff fed3 	bl	10000b2c <Cy_GPIO_Write>
        status = CY_GPIO_SUCCESS;
10000d86:	2000      	movs	r0, #0
}
10000d88:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cy_en_gpio_status_t status = CY_GPIO_BAD_PARAM;
10000d8a:	4803      	ldr	r0, [pc, #12]	; (10000d98 <Cy_GPIO_Pin_Init+0x158>)
}
10000d8c:	4770      	bx	lr
    cy_en_gpio_status_t status = CY_GPIO_BAD_PARAM;
10000d8e:	4802      	ldr	r0, [pc, #8]	; (10000d98 <Cy_GPIO_Pin_Init+0x158>)
    return(status);
10000d90:	e7fa      	b.n	10000d88 <Cy_GPIO_Pin_Init+0x148>
10000d92:	bf00      	nop
10000d94:	080001a0 	.word	0x080001a0
10000d98:	005a0001 	.word	0x005a0001

10000d9c <Cy_SysLib_Delay>:
#ifndef CY_SYSLIB_DELAY_CALIBRATION_FACTOR
#define CY_SYSLIB_DELAY_CALIBRATION_FACTOR     1U
#endif

void Cy_SysLib_Delay(uint32_t milliseconds)
{
10000d9c:	b510      	push	{r4, lr}
10000d9e:	4604      	mov	r4, r0
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
10000da0:	e005      	b.n	10000dae <Cy_SysLib_Delay+0x12>
    {
        /* This loop prevents an overflow in value passed to Cy_SysLib_DelayCycles() API.
         * At 100 MHz, (milliseconds * cy_delayFreqKhz) product overflows
         * in case if milliseconds parameter is more than 42 seconds.
         */
        Cy_SysLib_DelayCycles(cy_delay32kMs);
10000da2:	4b08      	ldr	r3, [pc, #32]	; (10000dc4 <Cy_SysLib_Delay+0x28>)
10000da4:	6818      	ldr	r0, [r3, #0]
10000da6:	f000 f867 	bl	10000e78 <Cy_SysLib_DelayCycles>
        milliseconds -= CY_DELAY_MS_OVERFLOW;
10000daa:	f5a4 4400 	sub.w	r4, r4, #32768	; 0x8000
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
10000dae:	f5b4 4f00 	cmp.w	r4, #32768	; 0x8000
10000db2:	d8f6      	bhi.n	10000da2 <Cy_SysLib_Delay+0x6>
    }

    Cy_SysLib_DelayCycles(milliseconds * cy_delayFreqKhz * CY_SYSLIB_DELAY_CALIBRATION_FACTOR);
10000db4:	4b04      	ldr	r3, [pc, #16]	; (10000dc8 <Cy_SysLib_Delay+0x2c>)
10000db6:	6818      	ldr	r0, [r3, #0]
10000db8:	fb04 f000 	mul.w	r0, r4, r0
10000dbc:	f000 f85c 	bl	10000e78 <Cy_SysLib_DelayCycles>
}
10000dc0:	bd10      	pop	{r4, pc}
10000dc2:	bf00      	nop
10000dc4:	0800008c 	.word	0x0800008c
10000dc8:	08000090 	.word	0x08000090

10000dcc <Cy_SysLib_ProcessingFault>:
         * Otherwise, the compiler destroys the call stack,
         * because treats this API as a no return function.
         */
        Cy_SysLib_AsmInfiniteLoop();
    #else
        while(true) {}
10000dcc:	e7fe      	b.n	10000dcc <Cy_SysLib_ProcessingFault>
	...

10000dd0 <Cy_SysLib_FaultHandler>:
{
10000dd0:	b508      	push	{r3, lr}
    cy_faultFrame.r0  = faultStackAddr[CY_R0_Pos];
10000dd2:	6802      	ldr	r2, [r0, #0]
10000dd4:	4b25      	ldr	r3, [pc, #148]	; (10000e6c <Cy_SysLib_FaultHandler+0x9c>)
10000dd6:	61da      	str	r2, [r3, #28]
    cy_faultFrame.r1  = faultStackAddr[CY_R1_Pos];
10000dd8:	6842      	ldr	r2, [r0, #4]
10000dda:	621a      	str	r2, [r3, #32]
    cy_faultFrame.r2  = faultStackAddr[CY_R2_Pos];
10000ddc:	6882      	ldr	r2, [r0, #8]
10000dde:	625a      	str	r2, [r3, #36]	; 0x24
    cy_faultFrame.r3  = faultStackAddr[CY_R3_Pos];
10000de0:	68c2      	ldr	r2, [r0, #12]
10000de2:	629a      	str	r2, [r3, #40]	; 0x28
    cy_faultFrame.r12 = faultStackAddr[CY_R12_Pos];
10000de4:	6902      	ldr	r2, [r0, #16]
10000de6:	62da      	str	r2, [r3, #44]	; 0x2c
    cy_faultFrame.lr  = faultStackAddr[CY_LR_Pos];
10000de8:	6942      	ldr	r2, [r0, #20]
10000dea:	631a      	str	r2, [r3, #48]	; 0x30
    cy_faultFrame.pc  = faultStackAddr[CY_PC_Pos];
10000dec:	6982      	ldr	r2, [r0, #24]
10000dee:	635a      	str	r2, [r3, #52]	; 0x34
    cy_faultFrame.psr = faultStackAddr[CY_PSR_Pos];
10000df0:	69c2      	ldr	r2, [r0, #28]
10000df2:	639a      	str	r2, [r3, #56]	; 0x38
    cy_faultFrame.cfsr.cfsrReg = SCB->CFSR;
10000df4:	4a1e      	ldr	r2, [pc, #120]	; (10000e70 <Cy_SysLib_FaultHandler+0xa0>)
10000df6:	6a91      	ldr	r1, [r2, #40]	; 0x28
10000df8:	63d9      	str	r1, [r3, #60]	; 0x3c
    cy_faultFrame.hfsr.hfsrReg = SCB->HFSR;
10000dfa:	6ad1      	ldr	r1, [r2, #44]	; 0x2c
10000dfc:	6419      	str	r1, [r3, #64]	; 0x40
    cy_faultFrame.shcsr.shcsrReg = SCB->SHCSR;
10000dfe:	6a51      	ldr	r1, [r2, #36]	; 0x24
10000e00:	6459      	str	r1, [r3, #68]	; 0x44
    cy_faultFrame.mmfar = SCB->MMFAR;
10000e02:	6b51      	ldr	r1, [r2, #52]	; 0x34
10000e04:	6499      	str	r1, [r3, #72]	; 0x48
    cy_faultFrame.bfar = SCB->BFAR;
10000e06:	6b92      	ldr	r2, [r2, #56]	; 0x38
10000e08:	64da      	str	r2, [r3, #76]	; 0x4c
     (defined (__FPU_USED   ) && (__FPU_USED    == 1U))     )
#if __has_builtin(__builtin_arm_get_fpscr) 
// Re-enable using built-in when GCC has been fixed
// || (__GNUC__ > 7) || (__GNUC__ == 7 && __GNUC_MINOR__ >= 2)
  /* see https://gcc.gnu.org/ml/gcc-patches/2017-04/msg00443.html */
  return __builtin_arm_get_fpscr();
10000e0a:	eef1 3a10 	vmrs	r3, fpscr
    if(0U != (__get_FPSCR() & (CY_FPSCR_IXC_Msk | CY_FPSCR_IDC_Msk)))
10000e0e:	f013 0f90 	tst.w	r3, #144	; 0x90
10000e12:	d027      	beq.n	10000e64 <Cy_SysLib_FaultHandler+0x94>
        cy_faultFrame.s0    = faultStackAddr[CY_S0_Pos];
10000e14:	6a02      	ldr	r2, [r0, #32]
10000e16:	4b15      	ldr	r3, [pc, #84]	; (10000e6c <Cy_SysLib_FaultHandler+0x9c>)
10000e18:	651a      	str	r2, [r3, #80]	; 0x50
        cy_faultFrame.s1    = faultStackAddr[CY_S1_Pos];
10000e1a:	6a42      	ldr	r2, [r0, #36]	; 0x24
10000e1c:	655a      	str	r2, [r3, #84]	; 0x54
        cy_faultFrame.s2    = faultStackAddr[CY_S2_Pos];
10000e1e:	6a82      	ldr	r2, [r0, #40]	; 0x28
10000e20:	659a      	str	r2, [r3, #88]	; 0x58
        cy_faultFrame.s3    = faultStackAddr[CY_S3_Pos];
10000e22:	6ac2      	ldr	r2, [r0, #44]	; 0x2c
10000e24:	65da      	str	r2, [r3, #92]	; 0x5c
        cy_faultFrame.s4    = faultStackAddr[CY_S4_Pos];
10000e26:	6b02      	ldr	r2, [r0, #48]	; 0x30
10000e28:	661a      	str	r2, [r3, #96]	; 0x60
        cy_faultFrame.s5    = faultStackAddr[CY_S5_Pos];
10000e2a:	6b42      	ldr	r2, [r0, #52]	; 0x34
10000e2c:	665a      	str	r2, [r3, #100]	; 0x64
        cy_faultFrame.s6    = faultStackAddr[CY_S6_Pos];
10000e2e:	6b82      	ldr	r2, [r0, #56]	; 0x38
10000e30:	669a      	str	r2, [r3, #104]	; 0x68
        cy_faultFrame.s7    = faultStackAddr[CY_S7_Pos];
10000e32:	6bc2      	ldr	r2, [r0, #60]	; 0x3c
10000e34:	66da      	str	r2, [r3, #108]	; 0x6c
        cy_faultFrame.s8    = faultStackAddr[CY_S8_Pos];
10000e36:	6c02      	ldr	r2, [r0, #64]	; 0x40
10000e38:	671a      	str	r2, [r3, #112]	; 0x70
        cy_faultFrame.s9    = faultStackAddr[CY_S9_Pos];
10000e3a:	6c42      	ldr	r2, [r0, #68]	; 0x44
10000e3c:	675a      	str	r2, [r3, #116]	; 0x74
        cy_faultFrame.s10   = faultStackAddr[CY_S10_Pos];
10000e3e:	6c82      	ldr	r2, [r0, #72]	; 0x48
10000e40:	679a      	str	r2, [r3, #120]	; 0x78
        cy_faultFrame.s11   = faultStackAddr[CY_S11_Pos];
10000e42:	6cc2      	ldr	r2, [r0, #76]	; 0x4c
10000e44:	67da      	str	r2, [r3, #124]	; 0x7c
        cy_faultFrame.s12   = faultStackAddr[CY_S12_Pos];
10000e46:	6d02      	ldr	r2, [r0, #80]	; 0x50
10000e48:	f8c3 2080 	str.w	r2, [r3, #128]	; 0x80
        cy_faultFrame.s13   = faultStackAddr[CY_S13_Pos];
10000e4c:	6d42      	ldr	r2, [r0, #84]	; 0x54
10000e4e:	f8c3 2084 	str.w	r2, [r3, #132]	; 0x84
        cy_faultFrame.s14   = faultStackAddr[CY_S14_Pos];
10000e52:	6d82      	ldr	r2, [r0, #88]	; 0x58
10000e54:	f8c3 2088 	str.w	r2, [r3, #136]	; 0x88
        cy_faultFrame.s15   = faultStackAddr[CY_S15_Pos];
10000e58:	6dc2      	ldr	r2, [r0, #92]	; 0x5c
10000e5a:	f8c3 208c 	str.w	r2, [r3, #140]	; 0x8c
        cy_faultFrame.fpscr = faultStackAddr[CY_FPSCR_Pos];
10000e5e:	6e02      	ldr	r2, [r0, #96]	; 0x60
10000e60:	f8c3 2090 	str.w	r2, [r3, #144]	; 0x90
    Cy_SysLib_ProcessingFault();
10000e64:	f7ff ffb2 	bl	10000dcc <Cy_SysLib_ProcessingFault>
}
10000e68:	bd08      	pop	{r3, pc}
10000e6a:	bf00      	nop
10000e6c:	080000f0 	.word	0x080000f0
10000e70:	e000ed00 	.word	0xe000ed00
10000e74:	00000000 	.word	0x00000000

10000e78 <Cy_SysLib_DelayCycles>:
.func Cy_SysLib_DelayCycles, Cy_SysLib_DelayCycles
.type Cy_SysLib_DelayCycles, %function
.thumb_func
Cy_SysLib_DelayCycles:      /* cycles bytes */

    ADDS r0, r0, #2         /*    1    2    Round to nearest multiple of 4 */
10000e78:	3002      	adds	r0, #2
    LSRS r0, r0, #2         /*    1    2    Divide by 4 and set flags */
10000e7a:	0880      	lsrs	r0, r0, #2
    BEQ Cy_DelayCycles_done /*    2    2    Skip if 0 */
10000e7c:	d003      	beq.n	10000e86 <Cy_DelayCycles_done>

10000e7e <Cy_DelayCycles_loop>:

Cy_DelayCycles_loop:
    ADDS r0, r0, #1         /*    1    2    Increment counter */
10000e7e:	3001      	adds	r0, #1
    SUBS r0, r0, #2         /*    1    2    Decrement counter by 2 */
10000e80:	3802      	subs	r0, #2
    BNE Cy_DelayCycles_loop /*   (1)2  2    2 CPU cycles (if branch is taken) */
10000e82:	d1fc      	bne.n	10000e7e <Cy_DelayCycles_loop>
    NOP                     /*    1    2    Loop alignment padding */
10000e84:	bf00      	nop

10000e86 <Cy_DelayCycles_done>:

Cy_DelayCycles_done:
    NOP                     /*    1    2    Loop alignment padding */
10000e86:	bf00      	nop
    BX lr                   /*    3    2 */
10000e88:	4770      	bx	lr

10000e8a <Cy_SysLib_EnterCriticalSection>:
.func Cy_SysLib_EnterCriticalSection, Cy_SysLib_EnterCriticalSection
.type Cy_SysLib_EnterCriticalSection, %function
.thumb_func

Cy_SysLib_EnterCriticalSection:
    MRS r0, PRIMASK         /* Save and return interrupt state */
10000e8a:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid i                 /* Disable interrupts */
10000e8e:	b672      	cpsid	i
    BX lr
10000e90:	4770      	bx	lr

10000e92 <Cy_SysLib_ExitCriticalSection>:
.func Cy_SysLib_ExitCriticalSection, Cy_SysLib_ExitCriticalSection
.type Cy_SysLib_ExitCriticalSection, %function
.thumb_func

Cy_SysLib_ExitCriticalSection:
    MSR PRIMASK, r0         /* Restore interrupt state */
10000e92:	f380 8810 	msr	PRIMASK, r0
    BX lr
10000e96:	4770      	bx	lr

10000e98 <main>:
        /*.vohSel =*/       0UL                     /* SIO-specific setting - ignored */
    };
    

int main(void)
{
10000e98:	b508      	push	{r3, lr}
  __ASM volatile ("cpsie i" : : : "memory");
10000e9a:	b662      	cpsie	i
    /* Enable global interrupts */
    __enable_irq();

    Cy_GPIO_Pin_Init(P13_7_PORT, P13_7_PIN, &pinConfig);
10000e9c:	4a06      	ldr	r2, [pc, #24]	; (10000eb8 <main+0x20>)
10000e9e:	2107      	movs	r1, #7
10000ea0:	4806      	ldr	r0, [pc, #24]	; (10000ebc <main+0x24>)
10000ea2:	f7ff fecd 	bl	10000c40 <Cy_GPIO_Pin_Init>

    
    while (1) {
        Cy_GPIO_Inv(P13_7_PORT, P13_7_PIN);
10000ea6:	2107      	movs	r1, #7
10000ea8:	4804      	ldr	r0, [pc, #16]	; (10000ebc <main+0x24>)
10000eaa:	f7ff fe4d 	bl	10000b48 <Cy_GPIO_Inv>
        Cy_SysLib_Delay(1000);
10000eae:	f44f 707a 	mov.w	r0, #1000	; 0x3e8
10000eb2:	f7ff ff73 	bl	10000d9c <Cy_SysLib_Delay>
    while (1) {
10000eb6:	e7f6      	b.n	10000ea6 <main+0xe>
10000eb8:	08000098 	.word	0x08000098
10000ebc:	40310680 	.word	0x40310680

10000ec0 <__aeabi_uldivmod>:
10000ec0:	b953      	cbnz	r3, 10000ed8 <__aeabi_uldivmod+0x18>
10000ec2:	b94a      	cbnz	r2, 10000ed8 <__aeabi_uldivmod+0x18>
10000ec4:	2900      	cmp	r1, #0
10000ec6:	bf08      	it	eq
10000ec8:	2800      	cmpeq	r0, #0
10000eca:	bf1c      	itt	ne
10000ecc:	f04f 31ff 	movne.w	r1, #4294967295
10000ed0:	f04f 30ff 	movne.w	r0, #4294967295
10000ed4:	f000 b974 	b.w	100011c0 <__aeabi_idiv0>
10000ed8:	f1ad 0c08 	sub.w	ip, sp, #8
10000edc:	e96d ce04 	strd	ip, lr, [sp, #-16]!
10000ee0:	f000 f806 	bl	10000ef0 <__udivmoddi4>
10000ee4:	f8dd e004 	ldr.w	lr, [sp, #4]
10000ee8:	e9dd 2302 	ldrd	r2, r3, [sp, #8]
10000eec:	b004      	add	sp, #16
10000eee:	4770      	bx	lr

10000ef0 <__udivmoddi4>:
10000ef0:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
10000ef4:	9e08      	ldr	r6, [sp, #32]
10000ef6:	460d      	mov	r5, r1
10000ef8:	4604      	mov	r4, r0
10000efa:	4688      	mov	r8, r1
10000efc:	2b00      	cmp	r3, #0
10000efe:	d14d      	bne.n	10000f9c <__udivmoddi4+0xac>
10000f00:	428a      	cmp	r2, r1
10000f02:	4694      	mov	ip, r2
10000f04:	d968      	bls.n	10000fd8 <__udivmoddi4+0xe8>
10000f06:	fab2 f282 	clz	r2, r2
10000f0a:	b152      	cbz	r2, 10000f22 <__udivmoddi4+0x32>
10000f0c:	fa01 f302 	lsl.w	r3, r1, r2
10000f10:	f1c2 0120 	rsb	r1, r2, #32
10000f14:	fa20 f101 	lsr.w	r1, r0, r1
10000f18:	fa0c fc02 	lsl.w	ip, ip, r2
10000f1c:	ea41 0803 	orr.w	r8, r1, r3
10000f20:	4094      	lsls	r4, r2
10000f22:	ea4f 451c 	mov.w	r5, ip, lsr #16
10000f26:	0c21      	lsrs	r1, r4, #16
10000f28:	fbb8 fef5 	udiv	lr, r8, r5
10000f2c:	fa1f f78c 	uxth.w	r7, ip
10000f30:	fb05 831e 	mls	r3, r5, lr, r8
10000f34:	ea41 4303 	orr.w	r3, r1, r3, lsl #16
10000f38:	fb0e f107 	mul.w	r1, lr, r7
10000f3c:	4299      	cmp	r1, r3
10000f3e:	d90b      	bls.n	10000f58 <__udivmoddi4+0x68>
10000f40:	eb1c 0303 	adds.w	r3, ip, r3
10000f44:	f10e 30ff 	add.w	r0, lr, #4294967295
10000f48:	f080 811e 	bcs.w	10001188 <__udivmoddi4+0x298>
10000f4c:	4299      	cmp	r1, r3
10000f4e:	f240 811b 	bls.w	10001188 <__udivmoddi4+0x298>
10000f52:	f1ae 0e02 	sub.w	lr, lr, #2
10000f56:	4463      	add	r3, ip
10000f58:	1a5b      	subs	r3, r3, r1
10000f5a:	b2a4      	uxth	r4, r4
10000f5c:	fbb3 f0f5 	udiv	r0, r3, r5
10000f60:	fb05 3310 	mls	r3, r5, r0, r3
10000f64:	ea44 4403 	orr.w	r4, r4, r3, lsl #16
10000f68:	fb00 f707 	mul.w	r7, r0, r7
10000f6c:	42a7      	cmp	r7, r4
10000f6e:	d90a      	bls.n	10000f86 <__udivmoddi4+0x96>
10000f70:	eb1c 0404 	adds.w	r4, ip, r4
10000f74:	f100 33ff 	add.w	r3, r0, #4294967295
10000f78:	f080 8108 	bcs.w	1000118c <__udivmoddi4+0x29c>
10000f7c:	42a7      	cmp	r7, r4
10000f7e:	f240 8105 	bls.w	1000118c <__udivmoddi4+0x29c>
10000f82:	4464      	add	r4, ip
10000f84:	3802      	subs	r0, #2
10000f86:	1be4      	subs	r4, r4, r7
10000f88:	ea40 400e 	orr.w	r0, r0, lr, lsl #16
10000f8c:	2100      	movs	r1, #0
10000f8e:	b11e      	cbz	r6, 10000f98 <__udivmoddi4+0xa8>
10000f90:	40d4      	lsrs	r4, r2
10000f92:	2300      	movs	r3, #0
10000f94:	e9c6 4300 	strd	r4, r3, [r6]
10000f98:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
10000f9c:	428b      	cmp	r3, r1
10000f9e:	d908      	bls.n	10000fb2 <__udivmoddi4+0xc2>
10000fa0:	2e00      	cmp	r6, #0
10000fa2:	f000 80ee 	beq.w	10001182 <__udivmoddi4+0x292>
10000fa6:	2100      	movs	r1, #0
10000fa8:	e9c6 0500 	strd	r0, r5, [r6]
10000fac:	4608      	mov	r0, r1
10000fae:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
10000fb2:	fab3 f183 	clz	r1, r3
10000fb6:	2900      	cmp	r1, #0
10000fb8:	d14a      	bne.n	10001050 <__udivmoddi4+0x160>
10000fba:	42ab      	cmp	r3, r5
10000fbc:	d302      	bcc.n	10000fc4 <__udivmoddi4+0xd4>
10000fbe:	4282      	cmp	r2, r0
10000fc0:	f200 80f9 	bhi.w	100011b6 <__udivmoddi4+0x2c6>
10000fc4:	1a84      	subs	r4, r0, r2
10000fc6:	eb65 0303 	sbc.w	r3, r5, r3
10000fca:	2001      	movs	r0, #1
10000fcc:	4698      	mov	r8, r3
10000fce:	2e00      	cmp	r6, #0
10000fd0:	d0e2      	beq.n	10000f98 <__udivmoddi4+0xa8>
10000fd2:	e9c6 4800 	strd	r4, r8, [r6]
10000fd6:	e7df      	b.n	10000f98 <__udivmoddi4+0xa8>
10000fd8:	b902      	cbnz	r2, 10000fdc <__udivmoddi4+0xec>
10000fda:	deff      	udf	#255	; 0xff
10000fdc:	fab2 f282 	clz	r2, r2
10000fe0:	2a00      	cmp	r2, #0
10000fe2:	f040 8091 	bne.w	10001108 <__udivmoddi4+0x218>
10000fe6:	eba1 050c 	sub.w	r5, r1, ip
10000fea:	ea4f 471c 	mov.w	r7, ip, lsr #16
10000fee:	fa1f fe8c 	uxth.w	lr, ip
10000ff2:	2101      	movs	r1, #1
10000ff4:	fbb5 f3f7 	udiv	r3, r5, r7
10000ff8:	fb07 5013 	mls	r0, r7, r3, r5
10000ffc:	0c25      	lsrs	r5, r4, #16
10000ffe:	ea45 4500 	orr.w	r5, r5, r0, lsl #16
10001002:	fb0e f003 	mul.w	r0, lr, r3
10001006:	42a8      	cmp	r0, r5
10001008:	d908      	bls.n	1000101c <__udivmoddi4+0x12c>
1000100a:	eb1c 0505 	adds.w	r5, ip, r5
1000100e:	f103 38ff 	add.w	r8, r3, #4294967295
10001012:	d202      	bcs.n	1000101a <__udivmoddi4+0x12a>
10001014:	42a8      	cmp	r0, r5
10001016:	f200 80cb 	bhi.w	100011b0 <__udivmoddi4+0x2c0>
1000101a:	4643      	mov	r3, r8
1000101c:	1a2d      	subs	r5, r5, r0
1000101e:	b2a4      	uxth	r4, r4
10001020:	fbb5 f0f7 	udiv	r0, r5, r7
10001024:	fb07 5510 	mls	r5, r7, r0, r5
10001028:	ea44 4405 	orr.w	r4, r4, r5, lsl #16
1000102c:	fb0e fe00 	mul.w	lr, lr, r0
10001030:	45a6      	cmp	lr, r4
10001032:	d908      	bls.n	10001046 <__udivmoddi4+0x156>
10001034:	eb1c 0404 	adds.w	r4, ip, r4
10001038:	f100 35ff 	add.w	r5, r0, #4294967295
1000103c:	d202      	bcs.n	10001044 <__udivmoddi4+0x154>
1000103e:	45a6      	cmp	lr, r4
10001040:	f200 80bb 	bhi.w	100011ba <__udivmoddi4+0x2ca>
10001044:	4628      	mov	r0, r5
10001046:	eba4 040e 	sub.w	r4, r4, lr
1000104a:	ea40 4003 	orr.w	r0, r0, r3, lsl #16
1000104e:	e79e      	b.n	10000f8e <__udivmoddi4+0x9e>
10001050:	f1c1 0720 	rsb	r7, r1, #32
10001054:	408b      	lsls	r3, r1
10001056:	fa22 fc07 	lsr.w	ip, r2, r7
1000105a:	ea4c 0c03 	orr.w	ip, ip, r3
1000105e:	fa20 f407 	lsr.w	r4, r0, r7
10001062:	fa05 f301 	lsl.w	r3, r5, r1
10001066:	431c      	orrs	r4, r3
10001068:	40fd      	lsrs	r5, r7
1000106a:	ea4f 491c 	mov.w	r9, ip, lsr #16
1000106e:	fa00 f301 	lsl.w	r3, r0, r1
10001072:	fbb5 f8f9 	udiv	r8, r5, r9
10001076:	0c20      	lsrs	r0, r4, #16
10001078:	fa1f fe8c 	uxth.w	lr, ip
1000107c:	fb09 5518 	mls	r5, r9, r8, r5
10001080:	ea40 4505 	orr.w	r5, r0, r5, lsl #16
10001084:	fb08 f00e 	mul.w	r0, r8, lr
10001088:	42a8      	cmp	r0, r5
1000108a:	fa02 f201 	lsl.w	r2, r2, r1
1000108e:	d90b      	bls.n	100010a8 <__udivmoddi4+0x1b8>
10001090:	eb1c 0505 	adds.w	r5, ip, r5
10001094:	f108 3aff 	add.w	sl, r8, #4294967295
10001098:	f080 8088 	bcs.w	100011ac <__udivmoddi4+0x2bc>
1000109c:	42a8      	cmp	r0, r5
1000109e:	f240 8085 	bls.w	100011ac <__udivmoddi4+0x2bc>
100010a2:	f1a8 0802 	sub.w	r8, r8, #2
100010a6:	4465      	add	r5, ip
100010a8:	1a2d      	subs	r5, r5, r0
100010aa:	b2a4      	uxth	r4, r4
100010ac:	fbb5 f0f9 	udiv	r0, r5, r9
100010b0:	fb09 5510 	mls	r5, r9, r0, r5
100010b4:	ea44 4505 	orr.w	r5, r4, r5, lsl #16
100010b8:	fb00 fe0e 	mul.w	lr, r0, lr
100010bc:	45ae      	cmp	lr, r5
100010be:	d908      	bls.n	100010d2 <__udivmoddi4+0x1e2>
100010c0:	eb1c 0505 	adds.w	r5, ip, r5
100010c4:	f100 34ff 	add.w	r4, r0, #4294967295
100010c8:	d26c      	bcs.n	100011a4 <__udivmoddi4+0x2b4>
100010ca:	45ae      	cmp	lr, r5
100010cc:	d96a      	bls.n	100011a4 <__udivmoddi4+0x2b4>
100010ce:	3802      	subs	r0, #2
100010d0:	4465      	add	r5, ip
100010d2:	ea40 4008 	orr.w	r0, r0, r8, lsl #16
100010d6:	fba0 9402 	umull	r9, r4, r0, r2
100010da:	eba5 050e 	sub.w	r5, r5, lr
100010de:	42a5      	cmp	r5, r4
100010e0:	46c8      	mov	r8, r9
100010e2:	46a6      	mov	lr, r4
100010e4:	d356      	bcc.n	10001194 <__udivmoddi4+0x2a4>
100010e6:	d053      	beq.n	10001190 <__udivmoddi4+0x2a0>
100010e8:	b15e      	cbz	r6, 10001102 <__udivmoddi4+0x212>
100010ea:	ebb3 0208 	subs.w	r2, r3, r8
100010ee:	eb65 050e 	sbc.w	r5, r5, lr
100010f2:	fa05 f707 	lsl.w	r7, r5, r7
100010f6:	fa22 f301 	lsr.w	r3, r2, r1
100010fa:	40cd      	lsrs	r5, r1
100010fc:	431f      	orrs	r7, r3
100010fe:	e9c6 7500 	strd	r7, r5, [r6]
10001102:	2100      	movs	r1, #0
10001104:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
10001108:	f1c2 0320 	rsb	r3, r2, #32
1000110c:	fa20 f103 	lsr.w	r1, r0, r3
10001110:	fa0c fc02 	lsl.w	ip, ip, r2
10001114:	fa25 f303 	lsr.w	r3, r5, r3
10001118:	4095      	lsls	r5, r2
1000111a:	430d      	orrs	r5, r1
1000111c:	ea4f 471c 	mov.w	r7, ip, lsr #16
10001120:	fa1f fe8c 	uxth.w	lr, ip
10001124:	fbb3 f1f7 	udiv	r1, r3, r7
10001128:	fb07 3011 	mls	r0, r7, r1, r3
1000112c:	0c2b      	lsrs	r3, r5, #16
1000112e:	ea43 4300 	orr.w	r3, r3, r0, lsl #16
10001132:	fb01 f00e 	mul.w	r0, r1, lr
10001136:	4298      	cmp	r0, r3
10001138:	fa04 f402 	lsl.w	r4, r4, r2
1000113c:	d908      	bls.n	10001150 <__udivmoddi4+0x260>
1000113e:	eb1c 0303 	adds.w	r3, ip, r3
10001142:	f101 38ff 	add.w	r8, r1, #4294967295
10001146:	d22f      	bcs.n	100011a8 <__udivmoddi4+0x2b8>
10001148:	4298      	cmp	r0, r3
1000114a:	d92d      	bls.n	100011a8 <__udivmoddi4+0x2b8>
1000114c:	3902      	subs	r1, #2
1000114e:	4463      	add	r3, ip
10001150:	1a1b      	subs	r3, r3, r0
10001152:	b2ad      	uxth	r5, r5
10001154:	fbb3 f0f7 	udiv	r0, r3, r7
10001158:	fb07 3310 	mls	r3, r7, r0, r3
1000115c:	ea45 4503 	orr.w	r5, r5, r3, lsl #16
10001160:	fb00 f30e 	mul.w	r3, r0, lr
10001164:	42ab      	cmp	r3, r5
10001166:	d908      	bls.n	1000117a <__udivmoddi4+0x28a>
10001168:	eb1c 0505 	adds.w	r5, ip, r5
1000116c:	f100 38ff 	add.w	r8, r0, #4294967295
10001170:	d216      	bcs.n	100011a0 <__udivmoddi4+0x2b0>
10001172:	42ab      	cmp	r3, r5
10001174:	d914      	bls.n	100011a0 <__udivmoddi4+0x2b0>
10001176:	3802      	subs	r0, #2
10001178:	4465      	add	r5, ip
1000117a:	1aed      	subs	r5, r5, r3
1000117c:	ea40 4101 	orr.w	r1, r0, r1, lsl #16
10001180:	e738      	b.n	10000ff4 <__udivmoddi4+0x104>
10001182:	4631      	mov	r1, r6
10001184:	4630      	mov	r0, r6
10001186:	e707      	b.n	10000f98 <__udivmoddi4+0xa8>
10001188:	4686      	mov	lr, r0
1000118a:	e6e5      	b.n	10000f58 <__udivmoddi4+0x68>
1000118c:	4618      	mov	r0, r3
1000118e:	e6fa      	b.n	10000f86 <__udivmoddi4+0x96>
10001190:	454b      	cmp	r3, r9
10001192:	d2a9      	bcs.n	100010e8 <__udivmoddi4+0x1f8>
10001194:	ebb9 0802 	subs.w	r8, r9, r2
10001198:	eb64 0e0c 	sbc.w	lr, r4, ip
1000119c:	3801      	subs	r0, #1
1000119e:	e7a3      	b.n	100010e8 <__udivmoddi4+0x1f8>
100011a0:	4640      	mov	r0, r8
100011a2:	e7ea      	b.n	1000117a <__udivmoddi4+0x28a>
100011a4:	4620      	mov	r0, r4
100011a6:	e794      	b.n	100010d2 <__udivmoddi4+0x1e2>
100011a8:	4641      	mov	r1, r8
100011aa:	e7d1      	b.n	10001150 <__udivmoddi4+0x260>
100011ac:	46d0      	mov	r8, sl
100011ae:	e77b      	b.n	100010a8 <__udivmoddi4+0x1b8>
100011b0:	3b02      	subs	r3, #2
100011b2:	4465      	add	r5, ip
100011b4:	e732      	b.n	1000101c <__udivmoddi4+0x12c>
100011b6:	4608      	mov	r0, r1
100011b8:	e709      	b.n	10000fce <__udivmoddi4+0xde>
100011ba:	4464      	add	r4, ip
100011bc:	3802      	subs	r0, #2
100011be:	e742      	b.n	10001046 <__udivmoddi4+0x156>

100011c0 <__aeabi_idiv0>:
100011c0:	4770      	bx	lr
100011c2:	bf00      	nop

100011c4 <memset>:
100011c4:	4402      	add	r2, r0
100011c6:	4603      	mov	r3, r0
100011c8:	4293      	cmp	r3, r2
100011ca:	d100      	bne.n	100011ce <memset+0xa>
100011cc:	4770      	bx	lr
100011ce:	f803 1b01 	strb.w	r1, [r3], #1
100011d2:	e7f9      	b.n	100011c8 <memset+0x4>

100011d4 <_init>:
100011d4:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100011d6:	bf00      	nop
100011d8:	bcf8      	pop	{r3, r4, r5, r6, r7}
100011da:	bc08      	pop	{r3}
100011dc:	469e      	mov	lr, r3
100011de:	4770      	bx	lr

100011e0 <_fini>:
100011e0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
100011e2:	bf00      	nop
100011e4:	bcf8      	pop	{r3, r4, r5, r6, r7}
100011e6:	bc08      	pop	{r3}
100011e8:	469e      	mov	lr, r3
100011ea:	4770      	bx	lr

100011ec <cy_deviceIpBlockCfgPSoC6_02>:
100011ec:	0000 4020 0000 4024 0000 4000 0000 0000     .. @..$@...@....
100011fc:	0000 4023 0000 4030 0000 4031 0000 409f     ..#@..0@..1@...@
1000120c:	0000 4022 0000 4010 0000 409d 2020 2020     .."@...@...@    
1000121c:	1020 1010 1d10 801d 0017 0075 03ff 0206      .........u.....
1000122c:	0006 0436 2010 0000 c07f 0000 0400 0000     ..6.. ..........
1000123c:	0000 0000 1900 4b32 7d64 0000 0000 8000     ......2Kd}......
1000124c:	0040 0b08 0010 0000 0000 01ff 0220 1f00     @........... ...
1000125c:	8000 0400 08ff 1810 1000 1400 1800 1c00     ................
1000126c:	4440 4c48 0050 0000 1008 0000 0008 0000     @DHLP...........
1000127c:	0004 0000 1004 0000 1200 0000 2104 0000     .............!..
1000128c:	2100 0000 1600 0000 1140 0240 13c4 1300     .!......@.@.....
1000129c:	1380 13a0 1340 1388 13a8 0020 001c 0000     ....@..... .....

100012ac <systemIpcPipeConfigCm0.1>:
100012ac:	0003 0000 0001 0000 0001 0000 0000 0000     ................
100012bc:	0305 0060 0004 0000 0001 0000 0000 0000     ..`.............
100012cc:	0001 0000 0406 0060 0008 0000 0314 0800     ......`.........
100012dc:	0911 1000                                   ....

100012e0 <__EH_FRAME_BEGIN__>:
100012e0:	0000 0000                                   ....
