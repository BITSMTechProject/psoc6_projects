
out/psoc6_cm0.elf:     file format elf32-littlearm


Disassembly of section .text:

10000000 <__Vectors>:
10000000:	08002000 	.word	0x08002000
10000004:	10000bb7 	.word	0x10000bb7
10000008:	0000000d 	.word	0x0000000d
1000000c:	10000c19 	.word	0x10000c19
	...
1000002c:	10000c15 	.word	0x10000c15
	...
10000038:	10000c15 	.word	0x10000c15
1000003c:	10000c15 	.word	0x10000c15
10000040:	10000c15 	.word	0x10000c15
10000044:	10000c15 	.word	0x10000c15
10000048:	10000c15 	.word	0x10000c15
1000004c:	10000c15 	.word	0x10000c15
10000050:	10000c15 	.word	0x10000c15
10000054:	10000c15 	.word	0x10000c15
10000058:	10000c15 	.word	0x10000c15
1000005c:	10000c15 	.word	0x10000c15
10000060:	10000c15 	.word	0x10000c15
10000064:	10000c15 	.word	0x10000c15
10000068:	10000c15 	.word	0x10000c15
1000006c:	10000c15 	.word	0x10000c15
10000070:	10000c15 	.word	0x10000c15
10000074:	10000c15 	.word	0x10000c15
10000078:	10000c15 	.word	0x10000c15
1000007c:	10000c15 	.word	0x10000c15

10000080 <__do_global_dtors_aux>:
10000080:	b510      	push	{r4, lr}
10000082:	4c06      	ldr	r4, [pc, #24]	; (1000009c <__do_global_dtors_aux+0x1c>)
10000084:	7823      	ldrb	r3, [r4, #0]
10000086:	2b00      	cmp	r3, #0
10000088:	d107      	bne.n	1000009a <__do_global_dtors_aux+0x1a>
1000008a:	4b05      	ldr	r3, [pc, #20]	; (100000a0 <__do_global_dtors_aux+0x20>)
1000008c:	2b00      	cmp	r3, #0
1000008e:	d002      	beq.n	10000096 <__do_global_dtors_aux+0x16>
10000090:	4804      	ldr	r0, [pc, #16]	; (100000a4 <__do_global_dtors_aux+0x24>)
10000092:	e000      	b.n	10000096 <__do_global_dtors_aux+0x16>
10000094:	bf00      	nop
10000096:	2301      	movs	r3, #1
10000098:	7023      	strb	r3, [r4, #0]
1000009a:	bd10      	pop	{r4, pc}
1000009c:	0800012c 	.word	0x0800012c
100000a0:	00000000 	.word	0x00000000
100000a4:	1000147c 	.word	0x1000147c

100000a8 <frame_dummy>:
100000a8:	4b04      	ldr	r3, [pc, #16]	; (100000bc <frame_dummy+0x14>)
100000aa:	b510      	push	{r4, lr}
100000ac:	2b00      	cmp	r3, #0
100000ae:	d003      	beq.n	100000b8 <frame_dummy+0x10>
100000b0:	4903      	ldr	r1, [pc, #12]	; (100000c0 <frame_dummy+0x18>)
100000b2:	4804      	ldr	r0, [pc, #16]	; (100000c4 <frame_dummy+0x1c>)
100000b4:	e000      	b.n	100000b8 <frame_dummy+0x10>
100000b6:	bf00      	nop
100000b8:	bd10      	pop	{r4, pc}
100000ba:	46c0      	nop			; (mov r8, r8)
100000bc:	00000000 	.word	0x00000000
100000c0:	08000130 	.word	0x08000130
100000c4:	1000147c 	.word	0x1000147c

100000c8 <Cy_PDL_Init>:
* This function must be called prior calling any function in PDL.
*
*******************************************************************************/
void Cy_PDL_Init(const cy_stc_device_t * device)
{
    cy_device = device;
100000c8:	4b01      	ldr	r3, [pc, #4]	; (100000d0 <Cy_PDL_Init+0x8>)
100000ca:	6018      	str	r0, [r3, #0]
}
100000cc:	4770      	bx	lr
100000ce:	46c0      	nop			; (mov r8, r8)
100000d0:	08000148 	.word	0x08000148

100000d4 <Cy_IPC_Pipe_Config>:
*
*******************************************************************************/
void Cy_IPC_Pipe_Config(cy_stc_ipc_pipe_ep_t * theEpArray)
{
    /* Keep copy of this endpoint */
    if (cy_ipc_pipe_epArray == NULL)
100000d4:	4b03      	ldr	r3, [pc, #12]	; (100000e4 <Cy_IPC_Pipe_Config+0x10>)
100000d6:	681b      	ldr	r3, [r3, #0]
100000d8:	2b00      	cmp	r3, #0
100000da:	d000      	beq.n	100000de <Cy_IPC_Pipe_Config+0xa>
    {
        cy_ipc_pipe_epArray = theEpArray;
    }
}
100000dc:	4770      	bx	lr
        cy_ipc_pipe_epArray = theEpArray;
100000de:	4b01      	ldr	r3, [pc, #4]	; (100000e4 <Cy_IPC_Pipe_Config+0x10>)
100000e0:	6018      	str	r0, [r3, #0]
}
100000e2:	e7fb      	b.n	100000dc <Cy_IPC_Pipe_Config+0x8>
100000e4:	0800014c 	.word	0x0800014c

100000e8 <Cy_IPC_Pipe_EndpointInit>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Pipe_EndpointInit
*
*******************************************************************************/
void Cy_IPC_Pipe_EndpointInit(uint32_t epAddr, cy_ipc_pipe_callback_array_ptr_t cbArray,
                              uint32_t cbCnt, uint32_t epConfig, cy_stc_sysint_t const *epInterrupt)
{
100000e8:	b570      	push	{r4, r5, r6, lr}
100000ea:	0004      	movs	r4, r0
    cy_stc_ipc_pipe_ep_t * endpoint;

    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
100000ec:	4823      	ldr	r0, [pc, #140]	; (1000017c <Cy_IPC_Pipe_EndpointInit+0x94>)
100000ee:	6800      	ldr	r0, [r0, #0]
100000f0:	2800      	cmp	r0, #0
100000f2:	d040      	beq.n	10000176 <Cy_IPC_Pipe_EndpointInit+0x8e>

    endpoint = &cy_ipc_pipe_epArray[epAddr];
100000f4:	4821      	ldr	r0, [pc, #132]	; (1000017c <Cy_IPC_Pipe_EndpointInit+0x94>)
100000f6:	6805      	ldr	r5, [r0, #0]
100000f8:	202c      	movs	r0, #44	; 0x2c
100000fa:	4360      	muls	r0, r4
100000fc:	1828      	adds	r0, r5, r0

    /* Extract the channel, interrupt and interrupt mask */
    endpoint->ipcChan         = _FLD2VAL(CY_IPC_PIPE_CFG_CHAN,  epConfig);
100000fe:	24ff      	movs	r4, #255	; 0xff
10000100:	0025      	movs	r5, r4
10000102:	401d      	ands	r5, r3
10000104:	6005      	str	r5, [r0, #0]
    endpoint->intrChan        = _FLD2VAL(CY_IPC_PIPE_CFG_INTR,  epConfig);
10000106:	0a1e      	lsrs	r6, r3, #8
10000108:	4034      	ands	r4, r6
1000010a:	6044      	str	r4, [r0, #4]
    endpoint->pipeIntMask     = _FLD2VAL(CY_IPC_PIPE_CFG_IMASK, epConfig);
1000010c:	0c1b      	lsrs	r3, r3, #16
1000010e:	6083      	str	r3, [r0, #8]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_SendMsgWord
*
*******************************************************************************/
__STATIC_INLINE IPC_STRUCT_Type* Cy_IPC_Drv_GetIpcBaseAddress (uint32_t ipcIndex)
{
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000110:	4b1b      	ldr	r3, [pc, #108]	; (10000180 <Cy_IPC_Pipe_EndpointInit+0x98>)
10000112:	681c      	ldr	r4, [r3, #0]
10000114:	2333      	movs	r3, #51	; 0x33
10000116:	5ce3      	ldrb	r3, [r4, r3]
10000118:	429d      	cmp	r5, r3
1000011a:	d300      	bcc.n	1000011e <Cy_IPC_Pipe_EndpointInit+0x36>

/** Halt the processor in the debug state
 */
static inline void CY_HALT(void)
{
    __asm("    bkpt    1");
1000011c:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
1000011e:	4b18      	ldr	r3, [pc, #96]	; (10000180 <Cy_IPC_Pipe_EndpointInit+0x98>)
10000120:	681c      	ldr	r4, [r3, #0]
10000122:	23ba      	movs	r3, #186	; 0xba
10000124:	5ae3      	ldrh	r3, [r4, r3]
10000126:	436b      	muls	r3, r5
10000128:	6a25      	ldr	r5, [r4, #32]
1000012a:	46ac      	mov	ip, r5
1000012c:	4463      	add	r3, ip

    /* Assign IPC channel to this endpoint */
    endpoint->ipcPtr   = Cy_IPC_Drv_GetIpcBaseAddress (endpoint->ipcChan);
1000012e:	6103      	str	r3, [r0, #16]

    /* Assign interrupt structure to endpoint and Initialize the interrupt mask for this endpoint */
    endpoint->ipcIntrPtr = Cy_IPC_Drv_GetIntrBaseAddr(endpoint->intrChan);
10000130:	6843      	ldr	r3, [r0, #4]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_GetInterruptStatus
*
*******************************************************************************/
__STATIC_INLINE IPC_INTR_STRUCT_Type* Cy_IPC_Drv_GetIntrBaseAddr (uint32_t ipcIntrIndex)
{
    CY_ASSERT_L1(CY_IPC_INTERRUPTS > ipcIntrIndex);
10000132:	2534      	movs	r5, #52	; 0x34
10000134:	5d64      	ldrb	r4, [r4, r5]
10000136:	42a3      	cmp	r3, r4
10000138:	d300      	bcc.n	1000013c <Cy_IPC_Pipe_EndpointInit+0x54>
1000013a:	be01      	bkpt	0x0001
    return ( (IPC_INTR_STRUCT_Type*) CY_IPC_INTR_STRUCT_PTR(ipcIntrIndex));
1000013c:	4c10      	ldr	r4, [pc, #64]	; (10000180 <Cy_IPC_Pipe_EndpointInit+0x98>)
1000013e:	6824      	ldr	r4, [r4, #0]
10000140:	6a24      	ldr	r4, [r4, #32]
10000142:	3380      	adds	r3, #128	; 0x80
10000144:	015b      	lsls	r3, r3, #5
10000146:	18e4      	adds	r4, r4, r3
10000148:	6144      	str	r4, [r0, #20]

    /* Only allow notify and release interrupts from endpoints in this pipe. */
    Cy_IPC_Drv_SetInterruptMask(endpoint->ipcIntrPtr, endpoint->pipeIntMask, endpoint->pipeIntMask);
1000014a:	6883      	ldr	r3, [r0, #8]
*
*******************************************************************************/
__STATIC_INLINE void  Cy_IPC_Drv_SetInterruptMask (IPC_INTR_STRUCT_Type* base,
                                              uint32_t ipcReleaseMask, uint32_t ipcAcquireMask)
{
    CY_ASSERT_L1(0UL == (ipcAcquireMask & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
1000014c:	0c1d      	lsrs	r5, r3, #16
1000014e:	d000      	beq.n	10000152 <Cy_IPC_Pipe_EndpointInit+0x6a>
10000150:	be01      	bkpt	0x0001
    CY_ASSERT_L1(0UL == (ipcReleaseMask & ~(uint32_t)(IPC_STRUCT_RELEASE_INTR_RELEASE_Msk)));
10000152:	0c1d      	lsrs	r5, r3, #16
10000154:	d000      	beq.n	10000158 <Cy_IPC_Pipe_EndpointInit+0x70>
10000156:	be01      	bkpt	0x0001
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
10000158:	041b      	lsls	r3, r3, #16
                      _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_RELEASE, ipcReleaseMask);
1000015a:	0c1d      	lsrs	r5, r3, #16
    REG_IPC_INTR_STRUCT_INTR_MASK(base) = _VAL2FLD( IPC_INTR_STRUCT_INTR_MASK_NOTIFY,  ipcAcquireMask) |
1000015c:	432b      	orrs	r3, r5
1000015e:	60a3      	str	r3, [r4, #8]

    /* Save the Client count and the callback array pointer */
    endpoint->clientCount   = cbCnt;
10000160:	61c2      	str	r2, [r0, #28]
    endpoint->callbackArray = cbArray;
10000162:	6201      	str	r1, [r0, #32]
    endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
10000164:	2300      	movs	r3, #0
10000166:	6183      	str	r3, [r0, #24]

    if (NULL != epInterrupt)
10000168:	9b04      	ldr	r3, [sp, #16]
1000016a:	2b00      	cmp	r3, #0
1000016c:	d002      	beq.n	10000174 <Cy_IPC_Pipe_EndpointInit+0x8c>
    {
        endpoint->pipeIntrSrc     = epInterrupt->intrSrc;
1000016e:	2200      	movs	r2, #0
10000170:	5e9b      	ldrsh	r3, [r3, r2]
10000172:	8183      	strh	r3, [r0, #12]
    }
}
10000174:	bd70      	pop	{r4, r5, r6, pc}
10000176:	be01      	bkpt	0x0001
}
10000178:	e7bc      	b.n	100000f4 <Cy_IPC_Pipe_EndpointInit+0xc>
1000017a:	46c0      	nop			; (mov r8, r8)
1000017c:	0800014c 	.word	0x0800014c
10000180:	08000148 	.word	0x08000148

10000184 <Cy_IPC_Pipe_Init>:
{
10000184:	b5f0      	push	{r4, r5, r6, r7, lr}
10000186:	b08f      	sub	sp, #60	; 0x3c
10000188:	1e04      	subs	r4, r0, #0
    CY_ASSERT_L1(NULL != config);
1000018a:	d041      	beq.n	10000210 <Cy_IPC_Pipe_Init+0x8c>
    CY_ASSERT_L2((uint32_t)(1UL << __NVIC_PRIO_BITS) > config->ep0ConfigData.ipcNotifierPriority);
1000018c:	6863      	ldr	r3, [r4, #4]
1000018e:	2b03      	cmp	r3, #3
10000190:	d900      	bls.n	10000194 <Cy_IPC_Pipe_Init+0x10>
    __asm("    bkpt    1");
10000192:	be01      	bkpt	0x0001
    CY_ASSERT_L1(NULL != config->endpointsCallbacksArray);
10000194:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10000196:	2b00      	cmp	r3, #0
10000198:	d03c      	beq.n	10000214 <Cy_IPC_Pipe_Init+0x90>
    CY_ASSERT_L1(NULL != config->userPipeIsrHandler);
1000019a:	6b23      	ldr	r3, [r4, #48]	; 0x30
1000019c:	2b00      	cmp	r3, #0
1000019e:	d03b      	beq.n	10000218 <Cy_IPC_Pipe_Init+0x94>
    epConfigDataA = config->ep0ConfigData;
100001a0:	aa07      	add	r2, sp, #28
100001a2:	0013      	movs	r3, r2
100001a4:	0021      	movs	r1, r4
100001a6:	c961      	ldmia	r1!, {r0, r5, r6}
100001a8:	c361      	stmia	r3!, {r0, r5, r6}
100001aa:	c921      	ldmia	r1!, {r0, r5}
100001ac:	c321      	stmia	r3!, {r0, r5}
    epConfigDataB = config->ep1ConfigData;
100001ae:	ae02      	add	r6, sp, #8
100001b0:	0023      	movs	r3, r4
100001b2:	3314      	adds	r3, #20
100001b4:	0031      	movs	r1, r6
100001b6:	cba1      	ldmia	r3!, {r0, r5, r7}
100001b8:	c1a1      	stmia	r1!, {r0, r5, r7}
100001ba:	cb21      	ldmia	r3!, {r0, r5}
100001bc:	c121      	stmia	r1!, {r0, r5}
    ipc_intr_cypipeConfig.intrSrc          = (IRQn_Type)epConfigDataA.ipcNotifierMuxNumber;
100001be:	2108      	movs	r1, #8
100001c0:	5e53      	ldrsh	r3, [r2, r1]
100001c2:	ad0c      	add	r5, sp, #48	; 0x30
100001c4:	802b      	strh	r3, [r5, #0]
    ipc_intr_cypipeConfig.cm0pSrc          = (cy_en_intr_t)((int32_t)cpuss_interrupts_ipc_0_IRQn + (int32_t)epConfigDataA.ipcNotifierNumber);
100001c6:	9b07      	ldr	r3, [sp, #28]
100001c8:	b29b      	uxth	r3, r3
100001ca:	3317      	adds	r3, #23
100001cc:	806b      	strh	r3, [r5, #2]
    ipc_intr_cypipeConfig.intrPriority     = epConfigDataA.ipcNotifierPriority;
100001ce:	9b08      	ldr	r3, [sp, #32]
100001d0:	930d      	str	r3, [sp, #52]	; 0x34
    Cy_IPC_Pipe_EndpointInit(epConfigDataA.epAddress,
100001d2:	9b0b      	ldr	r3, [sp, #44]	; 0x2c
100001d4:	980a      	ldr	r0, [sp, #40]	; 0x28
100001d6:	9500      	str	r5, [sp, #0]
100001d8:	6aa2      	ldr	r2, [r4, #40]	; 0x28
100001da:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
100001dc:	f7ff ff84 	bl	100000e8 <Cy_IPC_Pipe_EndpointInit>
    Cy_IPC_Pipe_EndpointInit(epConfigDataB.epAddress, NULL, 0UL, epConfigDataB.epConfig, NULL);
100001e0:	9b06      	ldr	r3, [sp, #24]
100001e2:	9805      	ldr	r0, [sp, #20]
100001e4:	2200      	movs	r2, #0
100001e6:	9200      	str	r2, [sp, #0]
100001e8:	2100      	movs	r1, #0
100001ea:	f7ff ff7d 	bl	100000e8 <Cy_IPC_Pipe_EndpointInit>
    (void)Cy_SysInt_Init(&ipc_intr_cypipeConfig, config->userPipeIsrHandler);
100001ee:	6b21      	ldr	r1, [r4, #48]	; 0x30
100001f0:	0028      	movs	r0, r5
100001f2:	f000 f995 	bl	10000520 <Cy_SysInt_Init>
    NVIC_EnableIRQ(ipc_intr_cypipeConfig.intrSrc);
100001f6:	2200      	movs	r2, #0
100001f8:	5eab      	ldrsh	r3, [r5, r2]
  \param [in]      IRQn  Device specific interrupt number.
  \note    IRQn must not be negative.
 */
__STATIC_INLINE void __NVIC_EnableIRQ(IRQn_Type IRQn)
{
  if ((int32_t)(IRQn) >= 0)
100001fa:	2b00      	cmp	r3, #0
100001fc:	db06      	blt.n	1000020c <Cy_IPC_Pipe_Init+0x88>
  {
    __COMPILER_BARRIER();
    NVIC->ISER[0U] = (uint32_t)(1UL << (((uint32_t)IRQn) & 0x1FUL));
100001fe:	221f      	movs	r2, #31
10000200:	4013      	ands	r3, r2
10000202:	3a1e      	subs	r2, #30
10000204:	409a      	lsls	r2, r3
10000206:	0013      	movs	r3, r2
10000208:	4a04      	ldr	r2, [pc, #16]	; (1000021c <Cy_IPC_Pipe_Init+0x98>)
1000020a:	6013      	str	r3, [r2, #0]
}
1000020c:	b00f      	add	sp, #60	; 0x3c
1000020e:	bdf0      	pop	{r4, r5, r6, r7, pc}
10000210:	be01      	bkpt	0x0001
}
10000212:	e7bb      	b.n	1000018c <Cy_IPC_Pipe_Init+0x8>
    __asm("    bkpt    1");
10000214:	be01      	bkpt	0x0001
}
10000216:	e7c0      	b.n	1000019a <Cy_IPC_Pipe_Init+0x16>
    __asm("    bkpt    1");
10000218:	be01      	bkpt	0x0001
}
1000021a:	e7c1      	b.n	100001a0 <Cy_IPC_Pipe_Init+0x1c>
1000021c:	e000e100 	.word	0xe000e100

10000220 <Cy_IPC_Pipe_ExecCallback>:
* \note This function is obsolete and will be removed in the next releases.
*       Please use Cy_IPC_Pipe_ExecuteCallback() instead.
*
*******************************************************************************/
void Cy_IPC_Pipe_ExecCallback(cy_stc_ipc_pipe_ep_t * endpoint)
{
10000220:	b570      	push	{r4, r5, r6, lr}
10000222:	b082      	sub	sp, #8
10000224:	0004      	movs	r4, r0
    uint32_t *msgPtr = NULL;
10000226:	2300      	movs	r3, #0
10000228:	9301      	str	r3, [sp, #4]
    uint32_t releaseMask = (uint32_t)0;

    cy_ipc_pipe_callback_ptr_t callbackPtr;

    /* Parameters checking begin */
    CY_ASSERT_L1(NULL != endpoint);
1000022a:	2800      	cmp	r0, #0
1000022c:	d02b      	beq.n	10000286 <Cy_IPC_Pipe_ExecCallback+0x66>
    CY_ASSERT_L1(NULL != endpoint->ipcPtr);
1000022e:	6923      	ldr	r3, [r4, #16]
10000230:	2b00      	cmp	r3, #0
10000232:	d02a      	beq.n	1000028a <Cy_IPC_Pipe_ExecCallback+0x6a>
    CY_ASSERT_L1(NULL != endpoint->ipcIntrPtr);
10000234:	6963      	ldr	r3, [r4, #20]
10000236:	2b00      	cmp	r3, #0
10000238:	d029      	beq.n	1000028e <Cy_IPC_Pipe_ExecCallback+0x6e>
    CY_ASSERT_L1(NULL != endpoint->callbackArray);
1000023a:	6a23      	ldr	r3, [r4, #32]
1000023c:	2b00      	cmp	r3, #0
1000023e:	d028      	beq.n	10000292 <Cy_IPC_Pipe_ExecCallback+0x72>
    /* Parameters checking end */

    shadowIntr = Cy_IPC_Drv_GetInterruptStatusMasked(endpoint->ipcIntrPtr);
10000240:	6963      	ldr	r3, [r4, #20]
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_GetInterruptStatusMasked
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_IPC_Drv_GetInterruptStatusMasked (IPC_INTR_STRUCT_Type const * base)
{
    return REG_IPC_INTR_STRUCT_INTR_MASKED(base);
10000242:	68dd      	ldr	r5, [r3, #12]
* Acquire mask value.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_IPC_Drv_ExtractAcquireMask (uint32_t intMask)
{
    return _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_NOTIFY, intMask);
10000244:	0c2a      	lsrs	r2, r5, #16

    /* Check to make sure the interrupt was a notify interrupt */
    if (0UL != Cy_IPC_Drv_ExtractAcquireMask(shadowIntr))
10000246:	d00b      	beq.n	10000260 <Cy_IPC_Pipe_ExecCallback+0x40>
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
10000248:	0412      	lsls	r2, r2, #16
1000024a:	601a      	str	r2, [r3, #0]
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
1000024c:	681b      	ldr	r3, [r3, #0]
    {
        /* Clear the notify interrupt.  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, CY_IPC_NO_NOTIFICATION, Cy_IPC_Drv_ExtractAcquireMask(shadowIntr));

        if ( Cy_IPC_Drv_IsLockAcquired (endpoint->ipcPtr) )
1000024e:	6920      	ldr	r0, [r4, #16]
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
10000250:	4b20      	ldr	r3, [pc, #128]	; (100002d4 <Cy_IPC_Pipe_ExecCallback+0xb4>)
10000252:	681a      	ldr	r2, [r3, #0]
10000254:	23bc      	movs	r3, #188	; 0xbc
10000256:	58d3      	ldr	r3, [r2, r3]
10000258:	181b      	adds	r3, r3, r0
1000025a:	681b      	ldr	r3, [r3, #0]
1000025c:	2b00      	cmp	r3, #0
1000025e:	db1a      	blt.n	10000296 <Cy_IPC_Pipe_ExecCallback+0x76>
* Release mask value.
*
*******************************************************************************/
__STATIC_INLINE uint32_t Cy_IPC_Drv_ExtractReleaseMask (uint32_t intMask)
{
    return _FLD2VAL(IPC_INTR_STRUCT_INTR_MASK_RELEASE, intMask);
10000260:	042d      	lsls	r5, r5, #16
10000262:	0c2a      	lsrs	r2, r5, #16
            (void)Cy_IPC_Drv_LockRelease (endpoint->ipcPtr, releaseMask);
        }
    }

    /* Check to make sure the interrupt was a release interrupt */
    if (0UL != Cy_IPC_Drv_ExtractReleaseMask(shadowIntr))  /* Check for a Release interrupt */
10000264:	2d00      	cmp	r5, #0
10000266:	d00a      	beq.n	1000027e <Cy_IPC_Pipe_ExecCallback+0x5e>
    {
        /* Clear the release interrupt  */
        Cy_IPC_Drv_ClearInterrupt(endpoint->ipcIntrPtr, Cy_IPC_Drv_ExtractReleaseMask(shadowIntr), CY_IPC_NO_NOTIFICATION);
10000268:	6963      	ldr	r3, [r4, #20]
    REG_IPC_INTR_STRUCT_INTR(base) =  _VAL2FLD(IPC_INTR_STRUCT_INTR_NOTIFY,  ipcAcquireMask) |
1000026a:	601a      	str	r2, [r3, #0]
    (void)REG_IPC_INTR_STRUCT_INTR(base);  /* Read the register to flush the cache */
1000026c:	681b      	ldr	r3, [r3, #0]

        if (endpoint->releaseCallbackPtr != NULL)
1000026e:	6a63      	ldr	r3, [r4, #36]	; 0x24
10000270:	2b00      	cmp	r3, #0
10000272:	d02a      	beq.n	100002ca <Cy_IPC_Pipe_ExecCallback+0xaa>
        {
            endpoint->releaseCallbackPtr();
10000274:	4798      	blx	r3

            /* Clear the pointer after it was called */
            endpoint->releaseCallbackPtr = NULL;
10000276:	2300      	movs	r3, #0
10000278:	6263      	str	r3, [r4, #36]	; 0x24
                endpoint->defaultReleaseCallbackPtr();
            }
        }

        /* Clear the busy flag when release is detected */
        endpoint->busy = CY_IPC_PIPE_ENDPOINT_NOTBUSY;
1000027a:	2300      	movs	r3, #0
1000027c:	61a3      	str	r3, [r4, #24]
    }

    (void)Cy_IPC_Drv_GetInterruptStatus(endpoint->ipcIntrPtr);
1000027e:	6963      	ldr	r3, [r4, #20]
    return REG_IPC_INTR_STRUCT_INTR(base);
10000280:	681b      	ldr	r3, [r3, #0]
}
10000282:	b002      	add	sp, #8
10000284:	bd70      	pop	{r4, r5, r6, pc}
    __asm("    bkpt    1");
10000286:	be01      	bkpt	0x0001
}
10000288:	e7d1      	b.n	1000022e <Cy_IPC_Pipe_ExecCallback+0xe>
    __asm("    bkpt    1");
1000028a:	be01      	bkpt	0x0001
}
1000028c:	e7d2      	b.n	10000234 <Cy_IPC_Pipe_ExecCallback+0x14>
    __asm("    bkpt    1");
1000028e:	be01      	bkpt	0x0001
}
10000290:	e7d3      	b.n	1000023a <Cy_IPC_Pipe_ExecCallback+0x1a>
    __asm("    bkpt    1");
10000292:	be01      	bkpt	0x0001
}
10000294:	e7d4      	b.n	10000240 <Cy_IPC_Pipe_ExecCallback+0x20>
*
*******************************************************************************/
__STATIC_INLINE  cy_en_ipcdrv_status_t  Cy_IPC_Drv_ReadMsgPtr (IPC_STRUCT_Type const * base, void ** msgPtr)
{
    CY_ASSERT_L1(NULL != msgPtr);
    return Cy_IPC_Drv_ReadMsgWord(base, (uint32_t *)msgPtr);
10000296:	a901      	add	r1, sp, #4
10000298:	f000 f856 	bl	10000348 <Cy_IPC_Drv_ReadMsgWord>
            if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_ReadMsgPtr (endpoint->ipcPtr, (void **)&msgPtr))
1000029c:	2800      	cmp	r0, #0
1000029e:	d10e      	bne.n	100002be <Cy_IPC_Pipe_ExecCallback+0x9e>
                releaseMask = _FLD2VAL(CY_IPC_PIPE_MSG_RELEASE, *msgPtr);
100002a0:	9801      	ldr	r0, [sp, #4]
100002a2:	6802      	ldr	r2, [r0, #0]
100002a4:	0c16      	lsrs	r6, r2, #16
                clientID    = _FLD2VAL(CY_IPC_PIPE_MSG_CLIENT,  *msgPtr);
100002a6:	23ff      	movs	r3, #255	; 0xff
100002a8:	4013      	ands	r3, r2
                if (endpoint->clientCount > clientID)
100002aa:	69e2      	ldr	r2, [r4, #28]
100002ac:	429a      	cmp	r2, r3
100002ae:	d907      	bls.n	100002c0 <Cy_IPC_Pipe_ExecCallback+0xa0>
                    callbackPtr = endpoint->callbackArray[clientID];  /* Get the callback function */
100002b0:	009b      	lsls	r3, r3, #2
100002b2:	6a22      	ldr	r2, [r4, #32]
100002b4:	58d3      	ldr	r3, [r2, r3]
                    if (callbackPtr != NULL)
100002b6:	2b00      	cmp	r3, #0
100002b8:	d002      	beq.n	100002c0 <Cy_IPC_Pipe_ExecCallback+0xa0>
                        callbackPtr(msgPtr);   /* Call the function pointer for "clientID" */
100002ba:	4798      	blx	r3
100002bc:	e000      	b.n	100002c0 <Cy_IPC_Pipe_ExecCallback+0xa0>
    uint32_t releaseMask = (uint32_t)0;
100002be:	2600      	movs	r6, #0
            (void)Cy_IPC_Drv_LockRelease (endpoint->ipcPtr, releaseMask);
100002c0:	0031      	movs	r1, r6
100002c2:	6920      	ldr	r0, [r4, #16]
100002c4:	f000 f81a 	bl	100002fc <Cy_IPC_Drv_LockRelease>
100002c8:	e7ca      	b.n	10000260 <Cy_IPC_Pipe_ExecCallback+0x40>
            if (endpoint->defaultReleaseCallbackPtr != NULL)
100002ca:	6aa3      	ldr	r3, [r4, #40]	; 0x28
100002cc:	2b00      	cmp	r3, #0
100002ce:	d0d4      	beq.n	1000027a <Cy_IPC_Pipe_ExecCallback+0x5a>
                endpoint->defaultReleaseCallbackPtr();
100002d0:	4798      	blx	r3
100002d2:	e7d2      	b.n	1000027a <Cy_IPC_Pipe_ExecCallback+0x5a>
100002d4:	08000148 	.word	0x08000148

100002d8 <Cy_IPC_Pipe_ExecuteCallback>:
{
100002d8:	b510      	push	{r4, lr}
100002da:	0002      	movs	r2, r0
    CY_ASSERT_L1(NULL != cy_ipc_pipe_epArray);
100002dc:	4b06      	ldr	r3, [pc, #24]	; (100002f8 <Cy_IPC_Pipe_ExecuteCallback+0x20>)
100002de:	681b      	ldr	r3, [r3, #0]
100002e0:	2b00      	cmp	r3, #0
100002e2:	d007      	beq.n	100002f4 <Cy_IPC_Pipe_ExecuteCallback+0x1c>
    endpoint = &cy_ipc_pipe_epArray[epAddr];
100002e4:	4b04      	ldr	r3, [pc, #16]	; (100002f8 <Cy_IPC_Pipe_ExecuteCallback+0x20>)
100002e6:	6818      	ldr	r0, [r3, #0]
100002e8:	232c      	movs	r3, #44	; 0x2c
100002ea:	4353      	muls	r3, r2
100002ec:	18c0      	adds	r0, r0, r3
    Cy_IPC_Pipe_ExecCallback(endpoint);
100002ee:	f7ff ff97 	bl	10000220 <Cy_IPC_Pipe_ExecCallback>
}
100002f2:	bd10      	pop	{r4, pc}
    __asm("    bkpt    1");
100002f4:	be01      	bkpt	0x0001
}
100002f6:	e7f5      	b.n	100002e4 <Cy_IPC_Pipe_ExecuteCallback+0xc>
100002f8:	0800014c 	.word	0x0800014c

100002fc <Cy_IPC_Drv_LockRelease>:
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
100002fc:	4b08      	ldr	r3, [pc, #32]	; (10000320 <Cy_IPC_Drv_LockRelease+0x24>)
100002fe:	681a      	ldr	r2, [r3, #0]
10000300:	23bc      	movs	r3, #188	; 0xbc
10000302:	58d3      	ldr	r3, [r2, r3]
10000304:	181b      	adds	r3, r3, r0
10000306:	681b      	ldr	r3, [r3, #0]
cy_en_ipcdrv_status_t Cy_IPC_Drv_LockRelease (IPC_STRUCT_Type* base, uint32_t releaseEventIntr)
{
    cy_en_ipcdrv_status_t retStatus;

    /* Check to make sure the IPC is Acquired */
    if( Cy_IPC_Drv_IsLockAcquired(base) )
10000308:	2b00      	cmp	r3, #0
1000030a:	da07      	bge.n	1000031c <Cy_IPC_Drv_LockRelease+0x20>
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_INTR_STRUCT_INTR_RELEASE_Msk)));
1000030c:	0c0b      	lsrs	r3, r1, #16
1000030e:	d000      	beq.n	10000312 <Cy_IPC_Drv_LockRelease+0x16>
    __asm("    bkpt    1");
10000310:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_RELEASE(base) = _VAL2FLD(IPC_INTR_STRUCT_INTR_RELEASE, notifyEventIntr);
10000312:	0409      	lsls	r1, r1, #16
10000314:	0c09      	lsrs	r1, r1, #16
10000316:	6041      	str	r1, [r0, #4]
    {
        /* The IPC was acquired, release the IPC channel */
        Cy_IPC_Drv_ReleaseNotify(base, releaseEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
10000318:	2000      	movs	r0, #0
    {
        retStatus = CY_IPC_DRV_ERROR;
    }

    return (retStatus);
}
1000031a:	4770      	bx	lr
        retStatus = CY_IPC_DRV_ERROR;
1000031c:	4801      	ldr	r0, [pc, #4]	; (10000324 <Cy_IPC_Drv_LockRelease+0x28>)
    return (retStatus);
1000031e:	e7fc      	b.n	1000031a <Cy_IPC_Drv_LockRelease+0x1e>
10000320:	08000148 	.word	0x08000148
10000324:	008a0001 	.word	0x008a0001

10000328 <Cy_IPC_Drv_SendMsgWord>:
* \snippet ipc/snippet/main.c snippet_Cy_IPC_Drv_LockAcquire
*
*******************************************************************************/
__STATIC_INLINE cy_en_ipcdrv_status_t Cy_IPC_Drv_LockAcquire (IPC_STRUCT_Type const * base)
{
    return ( 0UL != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_ACQUIRE(base))) ? CY_IPC_DRV_SUCCESS : CY_IPC_DRV_ERROR;
10000328:	6803      	ldr	r3, [r0, #0]
1000032a:	2b00      	cmp	r3, #0
1000032c:	da08      	bge.n	10000340 <Cy_IPC_Drv_SendMsgWord+0x18>
    REG_IPC_STRUCT_DATA(base) = dataValue;
1000032e:	60c2      	str	r2, [r0, #12]
    CY_ASSERT_L1(0UL == (notifyEventIntr  & ~(uint32_t)(IPC_STRUCT_NOTIFY_INTR_NOTIFY_Msk)));
10000330:	0c0b      	lsrs	r3, r1, #16
10000332:	d000      	beq.n	10000336 <Cy_IPC_Drv_SendMsgWord+0xe>
10000334:	be01      	bkpt	0x0001
    REG_IPC_STRUCT_NOTIFY(base) = _VAL2FLD(IPC_STRUCT_NOTIFY_INTR_NOTIFY, notifyEventIntr);
10000336:	0409      	lsls	r1, r1, #16
10000338:	0c09      	lsrs	r1, r1, #16
1000033a:	6081      	str	r1, [r0, #8]
        /* If the channel was acquired, send the message. */
        Cy_IPC_Drv_WriteDataValue(base, message);

        Cy_IPC_Drv_AcquireNotify(base, notifyEventIntr);

        retStatus = CY_IPC_DRV_SUCCESS;
1000033c:	2000      	movs	r0, #0
    {
        /* Channel was already acquired, return Error */
        retStatus = CY_IPC_DRV_ERROR;
    }
    return (retStatus);
}
1000033e:	4770      	bx	lr
        retStatus = CY_IPC_DRV_ERROR;
10000340:	4800      	ldr	r0, [pc, #0]	; (10000344 <Cy_IPC_Drv_SendMsgWord+0x1c>)
    return (retStatus);
10000342:	e7fc      	b.n	1000033e <Cy_IPC_Drv_SendMsgWord+0x16>
10000344:	008a0001 	.word	0x008a0001

10000348 <Cy_IPC_Drv_ReadMsgWord>:
*******************************************************************************/
cy_en_ipcdrv_status_t  Cy_IPC_Drv_ReadMsgWord (IPC_STRUCT_Type const * base, uint32_t * message)
{
    cy_en_ipcdrv_status_t retStatus;

    CY_ASSERT_L1(NULL != message);
10000348:	2900      	cmp	r1, #0
1000034a:	d00b      	beq.n	10000364 <Cy_IPC_Drv_ReadMsgWord+0x1c>
    return ( 0u != _FLD2VAL(IPC_STRUCT_ACQUIRE_SUCCESS, REG_IPC_STRUCT_LOCK_STATUS(base)) );
1000034c:	4b07      	ldr	r3, [pc, #28]	; (1000036c <Cy_IPC_Drv_ReadMsgWord+0x24>)
1000034e:	681a      	ldr	r2, [r3, #0]
10000350:	23bc      	movs	r3, #188	; 0xbc
10000352:	58d3      	ldr	r3, [r2, r3]
10000354:	181b      	adds	r3, r3, r0
10000356:	681b      	ldr	r3, [r3, #0]

    if ( Cy_IPC_Drv_IsLockAcquired(base) )
10000358:	2b00      	cmp	r3, #0
1000035a:	da05      	bge.n	10000368 <Cy_IPC_Drv_ReadMsgWord+0x20>
    return REG_IPC_STRUCT_DATA(base);
1000035c:	68c3      	ldr	r3, [r0, #12]
    {
        /* The channel is locked; message is valid. */
        *message = Cy_IPC_Drv_ReadDataValue(base);
1000035e:	600b      	str	r3, [r1, #0]

        retStatus = CY_IPC_DRV_SUCCESS;
10000360:	2000      	movs	r0, #0
    {
        /* The channel is not locked so channel is invalid. */
        retStatus = CY_IPC_DRV_ERROR;
    }
    return(retStatus);
}
10000362:	4770      	bx	lr
10000364:	be01      	bkpt	0x0001
}
10000366:	e7f1      	b.n	1000034c <Cy_IPC_Drv_ReadMsgWord+0x4>
        retStatus = CY_IPC_DRV_ERROR;
10000368:	4801      	ldr	r0, [pc, #4]	; (10000370 <Cy_IPC_Drv_ReadMsgWord+0x28>)
    return(retStatus);
1000036a:	e7fa      	b.n	10000362 <Cy_IPC_Drv_ReadMsgWord+0x1a>
1000036c:	08000148 	.word	0x08000148
10000370:	008a0001 	.word	0x008a0001

10000374 <Cy_IPC_Sema_InitExt>:
*                             or count not multiple of 32
*    \retval CY_IPC_SEMA_ERROR_LOCKED:  Could not acquire semaphores IPC channel
*
*******************************************************************************/
cy_en_ipcsema_status_t Cy_IPC_Sema_InitExt(uint32_t ipcChannel, cy_stc_ipc_sema_t *ipcSema)
{
10000374:	b570      	push	{r4, r5, r6, lr}
10000376:	000c      	movs	r4, r1
    cy_en_ipcsema_status_t retStatus = CY_IPC_SEMA_BAD_PARAM;

    if (ipcChannel >= CY_IPC_CHANNELS)
10000378:	4b1d      	ldr	r3, [pc, #116]	; (100003f0 <Cy_IPC_Sema_InitExt+0x7c>)
1000037a:	681a      	ldr	r2, [r3, #0]
1000037c:	2333      	movs	r3, #51	; 0x33
1000037e:	5cd3      	ldrb	r3, [r2, r3]
10000380:	4283      	cmp	r3, r0
10000382:	d930      	bls.n	100003e6 <Cy_IPC_Sema_InitExt+0x72>
    {
        retStatus = CY_IPC_SEMA_BAD_PARAM;
    }
    else
    {
        if(NULL != ipcSema)
10000384:	2900      	cmp	r1, #0
10000386:	d030      	beq.n	100003ea <Cy_IPC_Sema_InitExt+0x76>
        {
            /* Check if semaphore count is a multiple of 32 */
            if( 0UL == (ipcSema->maxSema & CY_IPC_SEMA_PER_WORD_MASK))
10000388:	680b      	ldr	r3, [r1, #0]
1000038a:	06db      	lsls	r3, r3, #27
1000038c:	d001      	beq.n	10000392 <Cy_IPC_Sema_InitExt+0x1e>
                    retStatus = CY_IPC_SEMA_ERROR_LOCKED;
                }
            }
            else
            {
                retStatus = CY_IPC_SEMA_BAD_PARAM;
1000038e:	4819      	ldr	r0, [pc, #100]	; (100003f4 <Cy_IPC_Sema_InitExt+0x80>)
10000390:	e02a      	b.n	100003e8 <Cy_IPC_Sema_InitExt+0x74>
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000392:	2333      	movs	r3, #51	; 0x33
10000394:	5cd3      	ldrb	r3, [r2, r3]
10000396:	4298      	cmp	r0, r3
10000398:	d300      	bcc.n	1000039c <Cy_IPC_Sema_InitExt+0x28>
    __asm("    bkpt    1");
1000039a:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
1000039c:	4b14      	ldr	r3, [pc, #80]	; (100003f0 <Cy_IPC_Sema_InitExt+0x7c>)
1000039e:	681b      	ldr	r3, [r3, #0]
100003a0:	6a1d      	ldr	r5, [r3, #32]
100003a2:	22ba      	movs	r2, #186	; 0xba
100003a4:	5a9b      	ldrh	r3, [r3, r2]
100003a6:	4358      	muls	r0, r3
100003a8:	182d      	adds	r5, r5, r0
                cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
100003aa:	4e13      	ldr	r6, [pc, #76]	; (100003f8 <Cy_IPC_Sema_InitExt+0x84>)
100003ac:	6035      	str	r5, [r6, #0]
                (void)memset(ipcSema->arrayPtr, 0, (ipcSema->maxSema /8u));
100003ae:	6823      	ldr	r3, [r4, #0]
100003b0:	08da      	lsrs	r2, r3, #3
100003b2:	2100      	movs	r1, #0
100003b4:	6860      	ldr	r0, [r4, #4]
100003b6:	f000 ffd3 	bl	10001360 <memset>
                (void) Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION);
100003ba:	2100      	movs	r1, #0
100003bc:	0028      	movs	r0, r5
100003be:	f7ff ff9d 	bl	100002fc <Cy_IPC_Drv_LockRelease>
                if( CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_SendMsgPtr (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION, ipcSema))
100003c2:	6830      	ldr	r0, [r6, #0]
    return Cy_IPC_Drv_SendMsgWord(base, notifyEventIntr, (uint32_t)msgPtr);
100003c4:	0022      	movs	r2, r4
100003c6:	2100      	movs	r1, #0
100003c8:	f7ff ffae 	bl	10000328 <Cy_IPC_Drv_SendMsgWord>
100003cc:	2800      	cmp	r0, #0
100003ce:	d001      	beq.n	100003d4 <Cy_IPC_Sema_InitExt+0x60>
                    retStatus = CY_IPC_SEMA_ERROR_LOCKED;
100003d0:	480a      	ldr	r0, [pc, #40]	; (100003fc <Cy_IPC_Sema_InitExt+0x88>)
100003d2:	e009      	b.n	100003e8 <Cy_IPC_Sema_InitExt+0x74>
                    if(CY_IPC_DRV_SUCCESS == Cy_IPC_Drv_LockRelease (cy_semaIpcStruct, CY_IPC_NO_NOTIFICATION))
100003d4:	4b08      	ldr	r3, [pc, #32]	; (100003f8 <Cy_IPC_Sema_InitExt+0x84>)
100003d6:	6818      	ldr	r0, [r3, #0]
100003d8:	2100      	movs	r1, #0
100003da:	f7ff ff8f 	bl	100002fc <Cy_IPC_Drv_LockRelease>
100003de:	2800      	cmp	r0, #0
100003e0:	d002      	beq.n	100003e8 <Cy_IPC_Sema_InitExt+0x74>
                        retStatus = CY_IPC_SEMA_ERROR_LOCKED;
100003e2:	4806      	ldr	r0, [pc, #24]	; (100003fc <Cy_IPC_Sema_InitExt+0x88>)
        {
            retStatus = CY_IPC_SEMA_BAD_PARAM;
        }
    }

    return(retStatus);
100003e4:	e000      	b.n	100003e8 <Cy_IPC_Sema_InitExt+0x74>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
100003e6:	4803      	ldr	r0, [pc, #12]	; (100003f4 <Cy_IPC_Sema_InitExt+0x80>)
}
100003e8:	bd70      	pop	{r4, r5, r6, pc}
            retStatus = CY_IPC_SEMA_BAD_PARAM;
100003ea:	4802      	ldr	r0, [pc, #8]	; (100003f4 <Cy_IPC_Sema_InitExt+0x80>)
100003ec:	e7fc      	b.n	100003e8 <Cy_IPC_Sema_InitExt+0x74>
100003ee:	46c0      	nop			; (mov r8, r8)
100003f0:	08000148 	.word	0x08000148
100003f4:	008a0103 	.word	0x008a0103
100003f8:	08000150 	.word	0x08000150
100003fc:	008a0101 	.word	0x008a0101

10000400 <Cy_IPC_Sema_Init>:
{
10000400:	b510      	push	{r4, lr}
10000402:	000b      	movs	r3, r1
    if( (NULL == memPtr) && (0u == count))
10000404:	2a00      	cmp	r2, #0
10000406:	d005      	beq.n	10000414 <Cy_IPC_Sema_Init+0x14>
    else if ((NULL != memPtr) && (0u != count))
10000408:	2a00      	cmp	r2, #0
1000040a:	d01d      	beq.n	10000448 <Cy_IPC_Sema_Init+0x48>
1000040c:	2b00      	cmp	r3, #0
1000040e:	d115      	bne.n	1000043c <Cy_IPC_Sema_Init+0x3c>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
10000410:	480e      	ldr	r0, [pc, #56]	; (1000044c <Cy_IPC_Sema_Init+0x4c>)
}
10000412:	bd10      	pop	{r4, pc}
    if( (NULL == memPtr) && (0u == count))
10000414:	2900      	cmp	r1, #0
10000416:	d1f7      	bne.n	10000408 <Cy_IPC_Sema_Init+0x8>
    CY_ASSERT_L1(CY_IPC_CHANNELS > ipcIndex);
10000418:	4a0d      	ldr	r2, [pc, #52]	; (10000450 <Cy_IPC_Sema_Init+0x50>)
1000041a:	6811      	ldr	r1, [r2, #0]
1000041c:	2233      	movs	r2, #51	; 0x33
1000041e:	5c8a      	ldrb	r2, [r1, r2]
10000420:	4290      	cmp	r0, r2
10000422:	d300      	bcc.n	10000426 <Cy_IPC_Sema_Init+0x26>
10000424:	be01      	bkpt	0x0001
    return ( (IPC_STRUCT_Type*) CY_IPC_STRUCT_PTR(ipcIndex));
10000426:	4a0a      	ldr	r2, [pc, #40]	; (10000450 <Cy_IPC_Sema_Init+0x50>)
10000428:	6811      	ldr	r1, [r2, #0]
1000042a:	6a0a      	ldr	r2, [r1, #32]
1000042c:	24ba      	movs	r4, #186	; 0xba
1000042e:	5b09      	ldrh	r1, [r1, r4]
10000430:	4348      	muls	r0, r1
10000432:	1812      	adds	r2, r2, r0
        cy_semaIpcStruct = Cy_IPC_Drv_GetIpcBaseAddress(ipcChannel);
10000434:	4907      	ldr	r1, [pc, #28]	; (10000454 <Cy_IPC_Sema_Init+0x54>)
10000436:	600a      	str	r2, [r1, #0]
        retStatus = CY_IPC_SEMA_SUCCESS;
10000438:	0018      	movs	r0, r3
1000043a:	e7ea      	b.n	10000412 <Cy_IPC_Sema_Init+0x12>
        cy_semaData.maxSema  = count;
1000043c:	4906      	ldr	r1, [pc, #24]	; (10000458 <Cy_IPC_Sema_Init+0x58>)
1000043e:	600b      	str	r3, [r1, #0]
        cy_semaData.arrayPtr = memPtr;
10000440:	604a      	str	r2, [r1, #4]
        retStatus = Cy_IPC_Sema_InitExt(ipcChannel, &cy_semaData);
10000442:	f7ff ff97 	bl	10000374 <Cy_IPC_Sema_InitExt>
10000446:	e7e4      	b.n	10000412 <Cy_IPC_Sema_Init+0x12>
        retStatus = CY_IPC_SEMA_BAD_PARAM;
10000448:	4800      	ldr	r0, [pc, #0]	; (1000044c <Cy_IPC_Sema_Init+0x4c>)
1000044a:	e7e2      	b.n	10000412 <Cy_IPC_Sema_Init+0x12>
1000044c:	008a0103 	.word	0x008a0103
10000450:	08000148 	.word	0x08000148
10000454:	08000150 	.word	0x08000150
10000458:	080000d4 	.word	0x080000d4

1000045c <Cy_WDT_Unlock>:
*
*******************************************************************************/
void Cy_WDT_Unlock(void)
{
    /* The WDT lock is to be removed by two writes */
    SRSS_WDT_CTL = ((SRSS_WDT_CTL & (uint32_t)(~SRSS_WDT_CTL_WDT_LOCK_Msk)) | CY_SRSS_WDT_LOCK_BIT0);
1000045c:	4907      	ldr	r1, [pc, #28]	; (1000047c <Cy_WDT_Unlock+0x20>)
1000045e:	22c0      	movs	r2, #192	; 0xc0
10000460:	0052      	lsls	r2, r2, #1
10000462:	588b      	ldr	r3, [r1, r2]
10000464:	009b      	lsls	r3, r3, #2
10000466:	089b      	lsrs	r3, r3, #2
10000468:	2080      	movs	r0, #128	; 0x80
1000046a:	05c0      	lsls	r0, r0, #23
1000046c:	4303      	orrs	r3, r0
1000046e:	508b      	str	r3, [r1, r2]

    SRSS_WDT_CTL |= CY_SRSS_WDT_LOCK_BIT1;
10000470:	5888      	ldr	r0, [r1, r2]
10000472:	2380      	movs	r3, #128	; 0x80
10000474:	061b      	lsls	r3, r3, #24
10000476:	4303      	orrs	r3, r0
10000478:	508b      	str	r3, [r1, r2]
}
1000047a:	4770      	bx	lr
1000047c:	40260000 	.word	0x40260000

10000480 <Cy_SysInt_SetInterruptSource>:
}


#if (CY_CPU_CORTEX_M0P) || defined(CY_IP_M7CPUSS) || defined (CY_DOXYGEN)
void Cy_SysInt_SetInterruptSource(IRQn_Type IRQn, cy_en_intr_t devIntrSrc)
{
10000480:	b530      	push	{r4, r5, lr}
#if defined (CY_IP_M4CPUSS)
    if (CY_CPUSS_V1)
10000482:	4b19      	ldr	r3, [pc, #100]	; (100004e8 <Cy_SysInt_SetInterruptSource+0x68>)
10000484:	681b      	ldr	r3, [r3, #0]
10000486:	222c      	movs	r2, #44	; 0x2c
10000488:	5c9a      	ldrb	r2, [r3, r2]
1000048a:	2a1f      	cmp	r2, #31
1000048c:	d815      	bhi.n	100004ba <Cy_SysInt_SetInterruptSource+0x3a>
    {
        uint32_t regPos = ((uint32_t)IRQn >> CY_SYSINT_CM0P_MUX_SHIFT);
1000048e:	0884      	lsrs	r4, r0, #2
        if(0UL == (regPos & (uint32_t)~CY_SYSINT_MUX_REG_MSK))
10000490:	2207      	movs	r2, #7
10000492:	0025      	movs	r5, r4
10000494:	4395      	bics	r5, r2
10000496:	1e2a      	subs	r2, r5, #0
10000498:	d122      	bne.n	100004e0 <Cy_SysInt_SetInterruptSource+0x60>
        {
            uint32_t bitfield_Pos = (uint32_t)((uint32_t)IRQn - (uint32_t)(regPos << CY_SYSINT_CM0P_MUX_SHIFT)) << CY_SYSINT_CM0P_MUX_SCALE;
1000049a:	3203      	adds	r2, #3
1000049c:	4010      	ands	r0, r2
1000049e:	00c0      	lsls	r0, r0, #3
            uint32_t bitfield_Msk = (uint32_t)(CY_SYSINT_CM0P_MUX_MASK << bitfield_Pos);
100004a0:	32fc      	adds	r2, #252	; 0xfc
100004a2:	4082      	lsls	r2, r0

            CY_REG32_CLR_SET(CPUSS_CM0_INT_CTL[regPos], bitfield, devIntrSrc);
100004a4:	681b      	ldr	r3, [r3, #0]
100004a6:	3320      	adds	r3, #32
100004a8:	00a4      	lsls	r4, r4, #2
100004aa:	191b      	adds	r3, r3, r4
100004ac:	681c      	ldr	r4, [r3, #0]
100004ae:	4081      	lsls	r1, r0
100004b0:	4061      	eors	r1, r4
100004b2:	4011      	ands	r1, r2
100004b4:	4061      	eors	r1, r4
100004b6:	6019      	str	r1, [r3, #0]
100004b8:	e012      	b.n	100004e0 <Cy_SysInt_SetInterruptSource+0x60>
        }
    }
    else /* CPUSS_V2 */
    {
        CY_ASSERT_L1(CY_CPUSS_DISCONNECTED_IRQN != devIntrSrc); /* Disconnection feature doesn't work for CPUSS_V2 */
100004ba:	223c      	movs	r2, #60	; 0x3c
100004bc:	5e9a      	ldrsh	r2, [r3, r2]
100004be:	b20b      	sxth	r3, r1
100004c0:	429a      	cmp	r2, r3
100004c2:	d00e      	beq.n	100004e2 <Cy_SysInt_SetInterruptSource+0x62>

        CPUSS_CM0_SYSTEM_INT_CTL[devIntrSrc] = _VAL2FLD(CPUSS_V2_CM0_SYSTEM_INT_CTL_CPU_INT_IDX, IRQn)
100004c4:	2307      	movs	r3, #7
100004c6:	4003      	ands	r3, r0
100004c8:	4a07      	ldr	r2, [pc, #28]	; (100004e8 <Cy_SysInt_SetInterruptSource+0x68>)
100004ca:	6812      	ldr	r2, [r2, #0]
100004cc:	6812      	ldr	r2, [r2, #0]
                                                      | CPUSS_V2_CM0_SYSTEM_INT_CTL_CPU_INT_VALID_Msk;
100004ce:	2080      	movs	r0, #128	; 0x80
100004d0:	0600      	lsls	r0, r0, #24
100004d2:	4318      	orrs	r0, r3
        CPUSS_CM0_SYSTEM_INT_CTL[devIntrSrc] = _VAL2FLD(CPUSS_V2_CM0_SYSTEM_INT_CTL_CPU_INT_IDX, IRQn)
100004d4:	2380      	movs	r3, #128	; 0x80
100004d6:	019b      	lsls	r3, r3, #6
100004d8:	469c      	mov	ip, r3
100004da:	4461      	add	r1, ip
100004dc:	0089      	lsls	r1, r1, #2
100004de:	5088      	str	r0, [r1, r2]
        else
            CPUSS_CM7_1_SYSTEM_INT_CTL[devIntrSrc] = _VAL2FLD(CPUSS_CM7_1_SYSTEM_INT_CTL_CPU_INT_IDX, IRQn)
                                                            | CPUSS_CM7_1_SYSTEM_INT_CTL_CPU_INT_VALID_Msk;
    #endif
#endif
}
100004e0:	bd30      	pop	{r4, r5, pc}
100004e2:	be01      	bkpt	0x0001
}
100004e4:	e7ee      	b.n	100004c4 <Cy_SysInt_SetInterruptSource+0x44>
100004e6:	46c0      	nop			; (mov r8, r8)
100004e8:	08000148 	.word	0x08000148

100004ec <Cy_SysInt_SetVector>:
cy_israddress Cy_SysInt_SetVector(IRQn_Type IRQn, cy_israddress userIsr)
{
    cy_israddress prevIsr;

    /* Set the new vector only if it was moved to __ramVectors */
    if (SCB->VTOR == (uint32_t)&__ramVectors)
100004ec:	4b09      	ldr	r3, [pc, #36]	; (10000514 <Cy_SysInt_SetVector+0x28>)
100004ee:	689a      	ldr	r2, [r3, #8]
100004f0:	4b09      	ldr	r3, [pc, #36]	; (10000518 <Cy_SysInt_SetVector+0x2c>)
100004f2:	429a      	cmp	r2, r3
100004f4:	d004      	beq.n	10000500 <Cy_SysInt_SetVector+0x14>
            #endif
        #endif
    }
    else
    {
        prevIsr = __Vectors[CY_INT_IRQ_BASE + (uint32_t)IRQn];
100004f6:	3010      	adds	r0, #16
100004f8:	0080      	lsls	r0, r0, #2
100004fa:	4b08      	ldr	r3, [pc, #32]	; (1000051c <Cy_SysInt_SetVector+0x30>)
100004fc:	58c0      	ldr	r0, [r0, r3]
    }

    return (prevIsr);
}
100004fe:	4770      	bx	lr
        CY_ASSERT_L1(CY_SYSINT_IS_VECTOR_VALID(userIsr));
10000500:	2900      	cmp	r1, #0
10000502:	d005      	beq.n	10000510 <Cy_SysInt_SetVector+0x24>
        prevIsr = __ramVectors[CY_INT_IRQ_BASE + (uint32_t)IRQn];
10000504:	3010      	adds	r0, #16
10000506:	4a04      	ldr	r2, [pc, #16]	; (10000518 <Cy_SysInt_SetVector+0x2c>)
10000508:	0083      	lsls	r3, r0, #2
1000050a:	5898      	ldr	r0, [r3, r2]
        __ramVectors[CY_INT_IRQ_BASE + (uint32_t)IRQn] = userIsr;
1000050c:	5099      	str	r1, [r3, r2]
1000050e:	e7f6      	b.n	100004fe <Cy_SysInt_SetVector+0x12>
    __asm("    bkpt    1");
10000510:	be01      	bkpt	0x0001
}
10000512:	e7f7      	b.n	10000504 <Cy_SysInt_SetVector+0x18>
10000514:	e000ed00 	.word	0xe000ed00
10000518:	08000000 	.word	0x08000000
1000051c:	10000000 	.word	0x10000000

10000520 <Cy_SysInt_Init>:
{
10000520:	b5f0      	push	{r4, r5, r6, r7, lr}
10000522:	46c6      	mov	lr, r8
10000524:	b500      	push	{lr}
10000526:	b082      	sub	sp, #8
10000528:	1e04      	subs	r4, r0, #0
1000052a:	9101      	str	r1, [sp, #4]
    if(NULL != config)
1000052c:	d04f      	beq.n	100005ce <Cy_SysInt_Init+0xae>
        CY_ASSERT_L3(CY_SYSINT_IS_PRIORITY_VALID(config->intrPriority));
1000052e:	6843      	ldr	r3, [r0, #4]
10000530:	2b03      	cmp	r3, #3
10000532:	d900      	bls.n	10000536 <Cy_SysInt_Init+0x16>
    __asm("    bkpt    1");
10000534:	be01      	bkpt	0x0001
                if (config->intrSrc > SysTick_IRQn)
10000536:	2300      	movs	r3, #0
10000538:	5ee0      	ldrsh	r0, [r4, r3]
1000053a:	2800      	cmp	r0, #0
1000053c:	da25      	bge.n	1000058a <Cy_SysInt_Init+0x6a>
                    status = CY_SYSINT_BAD_PARAM;
1000053e:	4e25      	ldr	r6, [pc, #148]	; (100005d4 <Cy_SysInt_Init+0xb4>)
                NVIC_SetPriority(config->intrSrc, config->intrPriority);
10000540:	2300      	movs	r3, #0
10000542:	5ee2      	ldrsh	r2, [r4, r3]
10000544:	6861      	ldr	r1, [r4, #4]
  \param [in]  priority  Priority to set.
  \note    The priority cannot be set for every processor exception.
 */
__STATIC_INLINE void __NVIC_SetPriority(IRQn_Type IRQn, uint32_t priority)
{
  if ((int32_t)(IRQn) >= 0)
10000546:	2a00      	cmp	r2, #0
10000548:	db24      	blt.n	10000594 <Cy_SysInt_Init+0x74>
  {
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
1000054a:	0893      	lsrs	r3, r2, #2
1000054c:	4d22      	ldr	r5, [pc, #136]	; (100005d8 <Cy_SysInt_Init+0xb8>)
1000054e:	33c0      	adds	r3, #192	; 0xc0
10000550:	009b      	lsls	r3, r3, #2
10000552:	5958      	ldr	r0, [r3, r5]
10000554:	4680      	mov	r8, r0
10000556:	2703      	movs	r7, #3
10000558:	403a      	ands	r2, r7
1000055a:	00d2      	lsls	r2, r2, #3
1000055c:	20ff      	movs	r0, #255	; 0xff
1000055e:	4684      	mov	ip, r0
10000560:	0007      	movs	r7, r0
10000562:	4097      	lsls	r7, r2
10000564:	4640      	mov	r0, r8
10000566:	43b8      	bics	r0, r7
10000568:	0007      	movs	r7, r0
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
1000056a:	0189      	lsls	r1, r1, #6
1000056c:	4660      	mov	r0, ip
1000056e:	4008      	ands	r0, r1
10000570:	4090      	lsls	r0, r2
    NVIC->IP[_IP_IDX(IRQn)]  = ((uint32_t)(NVIC->IP[_IP_IDX(IRQn)]  & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10000572:	4338      	orrs	r0, r7
10000574:	5158      	str	r0, [r3, r5]
                if (SCB->VTOR == (uint32_t)&__ramVectors)
10000576:	4b19      	ldr	r3, [pc, #100]	; (100005dc <Cy_SysInt_Init+0xbc>)
10000578:	689a      	ldr	r2, [r3, #8]
1000057a:	4b19      	ldr	r3, [pc, #100]	; (100005e0 <Cy_SysInt_Init+0xc0>)
1000057c:	429a      	cmp	r2, r3
1000057e:	d020      	beq.n	100005c2 <Cy_SysInt_Init+0xa2>
}
10000580:	0030      	movs	r0, r6
10000582:	b002      	add	sp, #8
10000584:	bc80      	pop	{r7}
10000586:	46b8      	mov	r8, r7
10000588:	bdf0      	pop	{r4, r5, r6, r7, pc}
                    Cy_SysInt_SetInterruptSource(config->intrSrc, config->cm0pSrc);
1000058a:	8861      	ldrh	r1, [r4, #2]
1000058c:	f7ff ff78 	bl	10000480 <Cy_SysInt_SetInterruptSource>
    cy_en_sysint_status_t status = CY_SYSINT_SUCCESS;
10000590:	2600      	movs	r6, #0
10000592:	e7d5      	b.n	10000540 <Cy_SysInt_Init+0x20>
  }
  else
  {
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
10000594:	230f      	movs	r3, #15
10000596:	4013      	ands	r3, r2
10000598:	3b08      	subs	r3, #8
1000059a:	089b      	lsrs	r3, r3, #2
1000059c:	3306      	adds	r3, #6
1000059e:	009b      	lsls	r3, r3, #2
100005a0:	480e      	ldr	r0, [pc, #56]	; (100005dc <Cy_SysInt_Init+0xbc>)
100005a2:	4684      	mov	ip, r0
100005a4:	4463      	add	r3, ip
100005a6:	685f      	ldr	r7, [r3, #4]
100005a8:	2003      	movs	r0, #3
100005aa:	4002      	ands	r2, r0
100005ac:	00d2      	lsls	r2, r2, #3
100005ae:	30fc      	adds	r0, #252	; 0xfc
100005b0:	0005      	movs	r5, r0
100005b2:	4095      	lsls	r5, r2
100005b4:	43af      	bics	r7, r5
       (((priority << (8U - __NVIC_PRIO_BITS)) & (uint32_t)0xFFUL) << _BIT_SHIFT(IRQn)));
100005b6:	0189      	lsls	r1, r1, #6
100005b8:	4008      	ands	r0, r1
100005ba:	4090      	lsls	r0, r2
    SCB->SHP[_SHP_IDX(IRQn)] = ((uint32_t)(SCB->SHP[_SHP_IDX(IRQn)] & ~(0xFFUL << _BIT_SHIFT(IRQn))) |
100005bc:	4338      	orrs	r0, r7
100005be:	6058      	str	r0, [r3, #4]
100005c0:	e7d9      	b.n	10000576 <Cy_SysInt_Init+0x56>
                    (void)Cy_SysInt_SetVector(config->intrSrc, userIsr);
100005c2:	2300      	movs	r3, #0
100005c4:	5ee0      	ldrsh	r0, [r4, r3]
100005c6:	9901      	ldr	r1, [sp, #4]
100005c8:	f7ff ff90 	bl	100004ec <Cy_SysInt_SetVector>
100005cc:	e7d8      	b.n	10000580 <Cy_SysInt_Init+0x60>
        status = CY_SYSINT_BAD_PARAM;
100005ce:	4e01      	ldr	r6, [pc, #4]	; (100005d4 <Cy_SysInt_Init+0xb4>)
    return(status);
100005d0:	e7d6      	b.n	10000580 <Cy_SysInt_Init+0x60>
100005d2:	46c0      	nop			; (mov r8, r8)
100005d4:	00560001 	.word	0x00560001
100005d8:	e000e100 	.word	0xe000e100
100005dc:	e000ed00 	.word	0xe000ed00
100005e0:	08000000 	.word	0x08000000

100005e4 <Cy_SysClk_ClkSlowGetDivider>:
}


uint8_t Cy_SysClk_ClkSlowGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_SLOW_INT_DIV, CPUSS_CM0_CLOCK_CTL));
100005e4:	4b04      	ldr	r3, [pc, #16]	; (100005f8 <Cy_SysClk_ClkSlowGetDivider+0x14>)
100005e6:	681a      	ldr	r2, [r3, #0]
100005e8:	6813      	ldr	r3, [r2, #0]
100005ea:	2188      	movs	r1, #136	; 0x88
100005ec:	5852      	ldr	r2, [r2, r1]
100005ee:	189b      	adds	r3, r3, r2
100005f0:	6818      	ldr	r0, [r3, #0]
100005f2:	0a00      	lsrs	r0, r0, #8
100005f4:	b2c0      	uxtb	r0, r0
}
100005f6:	4770      	bx	lr
100005f8:	08000148 	.word	0x08000148

100005fc <Cy_SysClk_ClkPeriGetDivider>:
}


uint8_t Cy_SysClk_ClkPeriGetDivider(void)
{
    return ((uint8_t)_FLD2VAL(CPUSS_CM0_CLOCK_CTL_PERI_INT_DIV, CPUSS_CM0_CLOCK_CTL));
100005fc:	4b04      	ldr	r3, [pc, #16]	; (10000610 <Cy_SysClk_ClkPeriGetDivider+0x14>)
100005fe:	681a      	ldr	r2, [r3, #0]
10000600:	6813      	ldr	r3, [r2, #0]
10000602:	2188      	movs	r1, #136	; 0x88
10000604:	5852      	ldr	r2, [r2, r1]
10000606:	189b      	adds	r3, r3, r2
10000608:	6818      	ldr	r0, [r3, #0]
1000060a:	0e00      	lsrs	r0, r0, #24
}
1000060c:	4770      	bx	lr
1000060e:	46c0      	nop			; (mov r8, r8)
10000610:	08000148 	.word	0x08000148

10000614 <Cy_SysClk_ClkHfGetSource>:
}


cy_en_clkhf_in_sources_t Cy_SysClk_ClkHfGetSource(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
10000614:	4b06      	ldr	r3, [pc, #24]	; (10000630 <Cy_SysClk_ClkHfGetSource+0x1c>)
10000616:	681a      	ldr	r2, [r3, #0]
10000618:	2340      	movs	r3, #64	; 0x40
1000061a:	5cd3      	ldrb	r3, [r2, r3]
1000061c:	4283      	cmp	r3, r0
1000061e:	d800      	bhi.n	10000622 <Cy_SysClk_ClkHfGetSource+0xe>
10000620:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_in_sources_t)((uint32_t)(_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_MUX, SRSS_CLK_ROOT_SELECT[clkHf]))));
10000622:	30e0      	adds	r0, #224	; 0xe0
10000624:	0080      	lsls	r0, r0, #2
10000626:	4b03      	ldr	r3, [pc, #12]	; (10000634 <Cy_SysClk_ClkHfGetSource+0x20>)
10000628:	58c3      	ldr	r3, [r0, r3]
1000062a:	200f      	movs	r0, #15
1000062c:	4018      	ands	r0, r3
}
1000062e:	4770      	bx	lr
10000630:	08000148 	.word	0x08000148
10000634:	40260000 	.word	0x40260000

10000638 <Cy_SysClk_ClkHfGetDivider>:
}


cy_en_clkhf_dividers_t Cy_SysClk_ClkHfGetDivider(uint32_t clkHf)
{
    CY_ASSERT_L1(clkHf < CY_SRSS_NUM_HFROOT);
10000638:	4b07      	ldr	r3, [pc, #28]	; (10000658 <Cy_SysClk_ClkHfGetDivider+0x20>)
1000063a:	681a      	ldr	r2, [r3, #0]
1000063c:	2340      	movs	r3, #64	; 0x40
1000063e:	5cd3      	ldrb	r3, [r2, r3]
10000640:	4283      	cmp	r3, r0
10000642:	d800      	bhi.n	10000646 <Cy_SysClk_ClkHfGetDivider+0xe>
10000644:	be01      	bkpt	0x0001
    return ((cy_en_clkhf_dividers_t)(((uint32_t)_FLD2VAL(SRSS_CLK_ROOT_SELECT_ROOT_DIV, SRSS_CLK_ROOT_SELECT[clkHf]))));
10000646:	30e0      	adds	r0, #224	; 0xe0
10000648:	0080      	lsls	r0, r0, #2
1000064a:	4b04      	ldr	r3, [pc, #16]	; (1000065c <Cy_SysClk_ClkHfGetDivider+0x24>)
1000064c:	58c3      	ldr	r3, [r0, r3]
1000064e:	091b      	lsrs	r3, r3, #4
10000650:	2003      	movs	r0, #3
10000652:	4018      	ands	r0, r3
}
10000654:	4770      	bx	lr
10000656:	46c0      	nop			; (mov r8, r8)
10000658:	08000148 	.word	0x08000148
1000065c:	40260000 	.word	0x40260000

10000660 <Cy_SysClk_WcoOkay>:
}


bool Cy_SysClk_WcoOkay(void)
{
    return (_FLD2BOOL(BACKUP_STATUS_WCO_OK, BACKUP_STATUS));
10000660:	4b03      	ldr	r3, [pc, #12]	; (10000670 <Cy_SysClk_WcoOkay+0x10>)
10000662:	691b      	ldr	r3, [r3, #16]
10000664:	2004      	movs	r0, #4
10000666:	4018      	ands	r0, r3
10000668:	1e43      	subs	r3, r0, #1
1000066a:	4198      	sbcs	r0, r3
1000066c:	b2c0      	uxtb	r0, r0
}
1000066e:	4770      	bx	lr
10000670:	40270000 	.word	0x40270000

10000674 <Cy_SysClk_AltHfGetFrequency>:
    #if defined(CY_IP_MXBLESS)
        return (cy_BleEcoClockFreqHz);
    #else /* CY_IP_MXBLESS */
        return (0UL);
    #endif /* CY_IP_MXBLESS */
}
10000674:	2000      	movs	r0, #0
10000676:	4770      	bx	lr

10000678 <Cy_SysClk_AltLfGetFrequency>:


uint32_t Cy_SysClk_AltLfGetFrequency(void)
{
    return (0UL);
}
10000678:	2000      	movs	r0, #0
1000067a:	4770      	bx	lr

1000067c <Cy_SysClk_ExtClkGetFrequency>:
}


uint32_t Cy_SysClk_ExtClkGetFrequency(void)
{
    return (cySysClkExtFreq);
1000067c:	4b01      	ldr	r3, [pc, #4]	; (10000684 <Cy_SysClk_ExtClkGetFrequency+0x8>)
1000067e:	6818      	ldr	r0, [r3, #0]
}
10000680:	4770      	bx	lr
10000682:	46c0      	nop			; (mov r8, r8)
10000684:	08000154 	.word	0x08000154

10000688 <Cy_SysClk_EcoGetStatus>:


uint32_t Cy_SysClk_EcoGetStatus(void)
{
    /* if ECO is not ready, just report the ECO_OK bit. Otherwise report 2 = ECO ready */
    return ((SRSS_CLK_ECO_STATUS_Msk == (SRSS_CLK_ECO_STATUS_Msk & SRSS_CLK_ECO_STATUS)) ?
10000688:	4a08      	ldr	r2, [pc, #32]	; (100006ac <Cy_SysClk_EcoGetStatus+0x24>)
1000068a:	23a6      	movs	r3, #166	; 0xa6
1000068c:	00db      	lsls	r3, r3, #3
1000068e:	58d2      	ldr	r2, [r2, r3]
10000690:	2303      	movs	r3, #3
10000692:	4013      	ands	r3, r2
      CY_SYSCLK_ECOSTAT_STABLE : (SRSS_CLK_ECO_STATUS_ECO_OK_Msk & SRSS_CLK_ECO_STATUS));
10000694:	2b03      	cmp	r3, #3
10000696:	d006      	beq.n	100006a6 <Cy_SysClk_EcoGetStatus+0x1e>
10000698:	4a04      	ldr	r2, [pc, #16]	; (100006ac <Cy_SysClk_EcoGetStatus+0x24>)
1000069a:	23a6      	movs	r3, #166	; 0xa6
1000069c:	00db      	lsls	r3, r3, #3
1000069e:	58d3      	ldr	r3, [r2, r3]
100006a0:	2001      	movs	r0, #1
100006a2:	4018      	ands	r0, r3
}
100006a4:	4770      	bx	lr
      CY_SYSCLK_ECOSTAT_STABLE : (SRSS_CLK_ECO_STATUS_ECO_OK_Msk & SRSS_CLK_ECO_STATUS));
100006a6:	2002      	movs	r0, #2
100006a8:	e7fc      	b.n	100006a4 <Cy_SysClk_EcoGetStatus+0x1c>
100006aa:	46c0      	nop			; (mov r8, r8)
100006ac:	40260000 	.word	0x40260000

100006b0 <Cy_SysClk_EcoGetFrequency>:
    return (retVal);
}


uint32_t Cy_SysClk_EcoGetFrequency(void)
{
100006b0:	b510      	push	{r4, lr}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
100006b2:	f7ff ffe9 	bl	10000688 <Cy_SysClk_EcoGetStatus>
100006b6:	2802      	cmp	r0, #2
100006b8:	d001      	beq.n	100006be <Cy_SysClk_EcoGetFrequency+0xe>
100006ba:	2000      	movs	r0, #0
}
100006bc:	bd10      	pop	{r4, pc}
    return ((CY_SYSCLK_ECOSTAT_STABLE == Cy_SysClk_EcoGetStatus()) ? ecoFrequency : 0UL);
100006be:	4b01      	ldr	r3, [pc, #4]	; (100006c4 <Cy_SysClk_EcoGetFrequency+0x14>)
100006c0:	6818      	ldr	r0, [r3, #0]
100006c2:	e7fb      	b.n	100006bc <Cy_SysClk_EcoGetFrequency+0xc>
100006c4:	08000158 	.word	0x08000158

100006c8 <Cy_SysClk_ClkPathGetSource>:

}


cy_en_clkpath_in_sources_t Cy_SysClk_ClkPathGetSource(uint32_t clkPath)
{
100006c8:	0003      	movs	r3, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
100006ca:	4a0c      	ldr	r2, [pc, #48]	; (100006fc <Cy_SysClk_ClkPathGetSource+0x34>)
100006cc:	6811      	ldr	r1, [r2, #0]
100006ce:	223e      	movs	r2, #62	; 0x3e
100006d0:	5c8a      	ldrb	r2, [r1, r2]
100006d2:	4282      	cmp	r2, r0
100006d4:	d800      	bhi.n	100006d8 <Cy_SysClk_ClkPathGetSource+0x10>
100006d6:	be01      	bkpt	0x0001
    cy_en_clkpath_in_sources_t retVal =
        (cy_en_clkpath_in_sources_t )((uint32_t)_FLD2VAL(SRSS_CLK_PATH_SELECT_PATH_MUX, SRSS_CLK_PATH_SELECT[clkPath]));
100006d8:	001a      	movs	r2, r3
100006da:	32d0      	adds	r2, #208	; 0xd0
100006dc:	0092      	lsls	r2, r2, #2
100006de:	4908      	ldr	r1, [pc, #32]	; (10000700 <Cy_SysClk_ClkPathGetSource+0x38>)
100006e0:	5850      	ldr	r0, [r2, r1]
    cy_en_clkpath_in_sources_t retVal =
100006e2:	2207      	movs	r2, #7
100006e4:	4010      	ands	r0, r2
    if (retVal == CY_SYSCLK_CLKPATH_IN_DSIMUX)
100006e6:	2804      	cmp	r0, #4
100006e8:	d000      	beq.n	100006ec <Cy_SysClk_ClkPathGetSource+0x24>
    {
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
    }
    return (retVal);
}
100006ea:	4770      	bx	lr
                    ((uint32_t)(_FLD2VAL(SRSS_CLK_DSI_SELECT_DSI_MUX, SRSS_CLK_DSI_SELECT[clkPath])))));
100006ec:	33c0      	adds	r3, #192	; 0xc0
100006ee:	009b      	lsls	r3, r3, #2
100006f0:	585b      	ldr	r3, [r3, r1]
100006f2:	301b      	adds	r0, #27
100006f4:	4003      	ands	r3, r0
        retVal = (cy_en_clkpath_in_sources_t)((uint32_t)(((uint32_t)CY_SYSCLK_CLKPATH_IN_DSI) |
100006f6:	30e1      	adds	r0, #225	; 0xe1
100006f8:	4318      	orrs	r0, r3
100006fa:	e7f6      	b.n	100006ea <Cy_SysClk_ClkPathGetSource+0x22>
100006fc:	08000148 	.word	0x08000148
10000700:	40260000 	.word	0x40260000

10000704 <Cy_SysClk_ClkPathMuxGetFrequency>:


uint32_t Cy_SysClk_ClkPathMuxGetFrequency(uint32_t clkPath)
{
10000704:	b510      	push	{r4, lr}
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10000706:	4b2a      	ldr	r3, [pc, #168]	; (100007b0 <Cy_SysClk_ClkPathMuxGetFrequency+0xac>)
10000708:	681a      	ldr	r2, [r3, #0]
1000070a:	233e      	movs	r3, #62	; 0x3e
1000070c:	5cd3      	ldrb	r3, [r2, r3]
1000070e:	4283      	cmp	r3, r0
10000710:	d800      	bhi.n	10000714 <Cy_SysClk_ClkPathMuxGetFrequency+0x10>
10000712:	be01      	bkpt	0x0001

    uint32_t freq = 0UL;    /* The path mux output frequency in Hz, 0 = an unknown frequency */

    /* Get the frequency of the source, i.e., the path mux input */
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10000714:	f7ff ffd8 	bl	100006c8 <Cy_SysClk_ClkPathGetSource>
10000718:	2388      	movs	r3, #136	; 0x88
1000071a:	005b      	lsls	r3, r3, #1
1000071c:	4298      	cmp	r0, r3
1000071e:	d031      	beq.n	10000784 <Cy_SysClk_ClkPathMuxGetFrequency+0x80>
10000720:	d812      	bhi.n	10000748 <Cy_SysClk_ClkPathMuxGetFrequency+0x44>
10000722:	2802      	cmp	r0, #2
10000724:	d02b      	beq.n	1000077e <Cy_SysClk_ClkPathMuxGetFrequency+0x7a>
10000726:	d904      	bls.n	10000732 <Cy_SysClk_ClkPathMuxGetFrequency+0x2e>
10000728:	2803      	cmp	r0, #3
1000072a:	d10b      	bne.n	10000744 <Cy_SysClk_ClkPathMuxGetFrequency+0x40>
        case CY_SYSCLK_CLKPATH_IN_ECO:
            freq = Cy_SysClk_EcoGetFrequency();
            break;

        case CY_SYSCLK_CLKPATH_IN_ALTHF:
            freq = Cy_SysClk_AltHfGetFrequency();
1000072c:	f7ff ffa2 	bl	10000674 <Cy_SysClk_AltHfGetFrequency>
            break;
10000730:	e03c      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10000732:	2800      	cmp	r0, #0
10000734:	d039      	beq.n	100007aa <Cy_SysClk_ClkPathMuxGetFrequency+0xa6>
10000736:	2801      	cmp	r0, #1
10000738:	d102      	bne.n	10000740 <Cy_SysClk_ClkPathMuxGetFrequency+0x3c>
            freq = Cy_SysClk_ExtClkGetFrequency();
1000073a:	f7ff ff9f 	bl	1000067c <Cy_SysClk_ExtClkGetFrequency>
            break;
1000073e:	e035      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10000740:	2000      	movs	r0, #0
10000742:	e033      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
10000744:	2000      	movs	r0, #0
10000746:	e031      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
10000748:	2389      	movs	r3, #137	; 0x89
1000074a:	005b      	lsls	r3, r3, #1
1000074c:	4298      	cmp	r0, r3
1000074e:	d029      	beq.n	100007a4 <Cy_SysClk_ClkPathMuxGetFrequency+0xa0>
10000750:	2314      	movs	r3, #20
10000752:	33ff      	adds	r3, #255	; 0xff
10000754:	4298      	cmp	r0, r3
10000756:	d106      	bne.n	10000766 <Cy_SysClk_ClkPathMuxGetFrequency+0x62>
        case CY_SYSCLK_CLKPATH_IN_WCO:
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
            break;

        case CY_SYSCLK_CLKPATH_IN_PILO:
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
10000758:	4a16      	ldr	r2, [pc, #88]	; (100007b4 <Cy_SysClk_ClkPathMuxGetFrequency+0xb0>)
1000075a:	4b17      	ldr	r3, [pc, #92]	; (100007b8 <Cy_SysClk_ClkPathMuxGetFrequency+0xb4>)
1000075c:	58d3      	ldr	r3, [r2, r3]
1000075e:	2b00      	cmp	r3, #0
10000760:	db1d      	blt.n	1000079e <Cy_SysClk_ClkPathMuxGetFrequency+0x9a>
10000762:	2000      	movs	r0, #0
        default:
            /* Don't know the frequency of dsi_out, leave freq = 0UL */
            break;
    }

    return (freq);
10000764:	e022      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
10000766:	2312      	movs	r3, #18
10000768:	33ff      	adds	r3, #255	; 0xff
1000076a:	4298      	cmp	r0, r3
1000076c:	d105      	bne.n	1000077a <Cy_SysClk_ClkPathMuxGetFrequency+0x76>
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
1000076e:	f7ff ff77 	bl	10000660 <Cy_SysClk_WcoOkay>
10000772:	2800      	cmp	r0, #0
10000774:	d110      	bne.n	10000798 <Cy_SysClk_ClkPathMuxGetFrequency+0x94>
10000776:	2000      	movs	r0, #0
10000778:	e018      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
    switch(Cy_SysClk_ClkPathGetSource(clkPath))
1000077a:	2000      	movs	r0, #0
1000077c:	e016      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = Cy_SysClk_EcoGetFrequency();
1000077e:	f7ff ff97 	bl	100006b0 <Cy_SysClk_EcoGetFrequency>
            break;
10000782:	e013      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = (0UL != (SRSS_CLK_ILO_CONFIG & SRSS_CLK_ILO_CONFIG_ENABLE_Msk)) ? CY_SYSCLK_ILO_FREQ : 0UL;
10000784:	4a0b      	ldr	r2, [pc, #44]	; (100007b4 <Cy_SysClk_ClkPathMuxGetFrequency+0xb0>)
10000786:	4b0d      	ldr	r3, [pc, #52]	; (100007bc <Cy_SysClk_ClkPathMuxGetFrequency+0xb8>)
10000788:	58d3      	ldr	r3, [r2, r3]
1000078a:	2b00      	cmp	r3, #0
1000078c:	db01      	blt.n	10000792 <Cy_SysClk_ClkPathMuxGetFrequency+0x8e>
1000078e:	2000      	movs	r0, #0
10000790:	e00c      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
10000792:	2080      	movs	r0, #128	; 0x80
10000794:	0200      	lsls	r0, r0, #8
10000796:	e009      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = (Cy_SysClk_WcoOkay()) ? CY_SYSCLK_WCO_FREQ : 0UL;
10000798:	2080      	movs	r0, #128	; 0x80
1000079a:	0200      	lsls	r0, r0, #8
1000079c:	e006      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = (0UL != (SRSS_CLK_PILO_CONFIG & SRSS_CLK_PILO_CONFIG_PILO_EN_Msk)) ? CY_SYSCLK_PILO_FREQ : 0UL;
1000079e:	2080      	movs	r0, #128	; 0x80
100007a0:	0200      	lsls	r0, r0, #8
100007a2:	e003      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = Cy_SysClk_AltLfGetFrequency();
100007a4:	f7ff ff68 	bl	10000678 <Cy_SysClk_AltLfGetFrequency>
            break;
100007a8:	e000      	b.n	100007ac <Cy_SysClk_ClkPathMuxGetFrequency+0xa8>
            freq = CY_SYSCLK_IMO_FREQ;
100007aa:	4805      	ldr	r0, [pc, #20]	; (100007c0 <Cy_SysClk_ClkPathMuxGetFrequency+0xbc>)
}
100007ac:	bd10      	pop	{r4, pc}
100007ae:	46c0      	nop			; (mov r8, r8)
100007b0:	08000148 	.word	0x08000148
100007b4:	40260000 	.word	0x40260000
100007b8:	0000053c 	.word	0x0000053c
100007bc:	0000050c 	.word	0x0000050c
100007c0:	007a1200 	.word	0x007a1200

100007c4 <Cy_SysClk_FllIsEnabled>:
#define MARGIN_SCALE            (100000ULL) /* 10 ^ 5 */
/** \endcond */

bool Cy_SysClk_FllIsEnabled(void)
{
    return (_FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_ENABLE, SRSS_CLK_FLL_CONFIG));
100007c4:	4a02      	ldr	r2, [pc, #8]	; (100007d0 <Cy_SysClk_FllIsEnabled+0xc>)
100007c6:	23b0      	movs	r3, #176	; 0xb0
100007c8:	00db      	lsls	r3, r3, #3
100007ca:	58d0      	ldr	r0, [r2, r3]
100007cc:	0fc0      	lsrs	r0, r0, #31
}
100007ce:	4770      	bx	lr
100007d0:	40260000 	.word	0x40260000

100007d4 <Cy_SysClk_FllGetConfiguration>:
    return (retVal);
}


void Cy_SysClk_FllGetConfiguration(cy_stc_fll_manual_config_t *config)
{
100007d4:	b510      	push	{r4, lr}
    CY_ASSERT_L1(config != NULL);
100007d6:	2800      	cmp	r0, #0
100007d8:	d032      	beq.n	10000840 <Cy_SysClk_FllGetConfiguration+0x6c>
    /* read 2 parameters from CLK_FLL_CONFIG register */
    uint32_t tempReg = SRSS_CLK_FLL_CONFIG;
100007da:	491a      	ldr	r1, [pc, #104]	; (10000844 <Cy_SysClk_FllGetConfiguration+0x70>)
100007dc:	23b0      	movs	r3, #176	; 0xb0
100007de:	00db      	lsls	r3, r3, #3
100007e0:	58cb      	ldr	r3, [r1, r3]
    config->fllMult         = _FLD2VAL(SRSS_CLK_FLL_CONFIG_FLL_MULT, tempReg);
100007e2:	039a      	lsls	r2, r3, #14
100007e4:	0b92      	lsrs	r2, r2, #14
100007e6:	6002      	str	r2, [r0, #0]
    config->enableOutputDiv = _FLD2BOOL(SRSS_CLK_FLL_CONFIG_FLL_OUTPUT_DIV, tempReg);
100007e8:	2280      	movs	r2, #128	; 0x80
100007ea:	0452      	lsls	r2, r2, #17
100007ec:	4013      	ands	r3, r2
100007ee:	1e5a      	subs	r2, r3, #1
100007f0:	4193      	sbcs	r3, r2
100007f2:	71c3      	strb	r3, [r0, #7]
    /* read 2 parameters from CLK_FLL_CONFIG2 register */
    tempReg = SRSS_CLK_FLL_CONFIG2;
100007f4:	4b14      	ldr	r3, [pc, #80]	; (10000848 <Cy_SysClk_FllGetConfiguration+0x74>)
100007f6:	58cb      	ldr	r3, [r1, r3]
    config->refDiv          = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_FLL_REF_DIV, tempReg);
100007f8:	04da      	lsls	r2, r3, #19
100007fa:	0cd2      	lsrs	r2, r2, #19
100007fc:	8082      	strh	r2, [r0, #4]
    config->lockTolerance   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG2_LOCK_TOL, tempReg);
100007fe:	0c1b      	lsrs	r3, r3, #16
10000800:	05db      	lsls	r3, r3, #23
10000802:	0ddb      	lsrs	r3, r3, #23
10000804:	8103      	strh	r3, [r0, #8]
    /* read 4 parameters from CLK_FLL_CONFIG3 register */
    tempReg = SRSS_CLK_FLL_CONFIG3;
10000806:	23b1      	movs	r3, #177	; 0xb1
10000808:	00db      	lsls	r3, r3, #3
1000080a:	58cb      	ldr	r3, [r1, r3]
    config->igain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_IGAIN, tempReg);
1000080c:	220f      	movs	r2, #15
1000080e:	0014      	movs	r4, r2
10000810:	401c      	ands	r4, r3
10000812:	7284      	strb	r4, [r0, #10]
    config->pgain           = (uint8_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_FLL_LF_PGAIN, tempReg);
10000814:	091c      	lsrs	r4, r3, #4
10000816:	4022      	ands	r2, r4
10000818:	72c2      	strb	r2, [r0, #11]
    config->settlingCount   = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_SETTLING_COUNT, tempReg);
1000081a:	0a1a      	lsrs	r2, r3, #8
1000081c:	04d2      	lsls	r2, r2, #19
1000081e:	0cd2      	lsrs	r2, r2, #19
10000820:	8182      	strh	r2, [r0, #12]
    config->outputMode      = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG3_BYPASS_SEL, tempReg));
10000822:	0f1b      	lsrs	r3, r3, #28
10000824:	2203      	movs	r2, #3
10000826:	4013      	ands	r3, r2
10000828:	7383      	strb	r3, [r0, #14]
    /* read 2 parameters from CLK_FLL_CONFIG4 register */
    tempReg = SRSS_CLK_FLL_CONFIG4;
1000082a:	4b08      	ldr	r3, [pc, #32]	; (1000084c <Cy_SysClk_FllGetConfiguration+0x78>)
1000082c:	58cb      	ldr	r3, [r1, r3]
    config->ccoRange        = (cy_en_fll_cco_ranges_t)((uint32_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_RANGE, tempReg));
1000082e:	0a19      	lsrs	r1, r3, #8
10000830:	3204      	adds	r2, #4
10000832:	400a      	ands	r2, r1
10000834:	7182      	strb	r2, [r0, #6]
    config->cco_Freq        = (uint16_t)_FLD2VAL(SRSS_CLK_FLL_CONFIG4_CCO_FREQ, tempReg);
10000836:	0c1b      	lsrs	r3, r3, #16
10000838:	05db      	lsls	r3, r3, #23
1000083a:	0ddb      	lsrs	r3, r3, #23
1000083c:	8203      	strh	r3, [r0, #16]
}
1000083e:	bd10      	pop	{r4, pc}
10000840:	be01      	bkpt	0x0001
}
10000842:	e7ca      	b.n	100007da <Cy_SysClk_FllGetConfiguration+0x6>
10000844:	40260000 	.word	0x40260000
10000848:	00000584 	.word	0x00000584
1000084c:	0000058c 	.word	0x0000058c

10000850 <Cy_SysClk_PllIsEnabled>:
#define CY_SYSCLK_PLL_MAX_OUT_FREQ (150000000UL)


bool Cy_SysClk_PllIsEnabled(uint32_t clkPath)
{
    clkPath--; /* to correctly access PLL config and status registers structures */
10000850:	3801      	subs	r0, #1
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_PLL);
10000852:	4b07      	ldr	r3, [pc, #28]	; (10000870 <Cy_SysClk_PllIsEnabled+0x20>)
10000854:	681a      	ldr	r2, [r3, #0]
10000856:	233f      	movs	r3, #63	; 0x3f
10000858:	5cd3      	ldrb	r3, [r2, r3]
1000085a:	4283      	cmp	r3, r0
1000085c:	d800      	bhi.n	10000860 <Cy_SysClk_PllIsEnabled+0x10>
    __asm("    bkpt    1");
1000085e:	be01      	bkpt	0x0001
    return (_FLD2BOOL(SRSS_CLK_PLL_CONFIG_ENABLE, SRSS_CLK_PLL_CONFIG[clkPath]));
10000860:	3081      	adds	r0, #129	; 0x81
10000862:	30ff      	adds	r0, #255	; 0xff
10000864:	0080      	lsls	r0, r0, #2
10000866:	4b03      	ldr	r3, [pc, #12]	; (10000874 <Cy_SysClk_PllIsEnabled+0x24>)
10000868:	58c0      	ldr	r0, [r0, r3]
1000086a:	0fc0      	lsrs	r0, r0, #31
}
1000086c:	4770      	bx	lr
1000086e:	46c0      	nop			; (mov r8, r8)
10000870:	08000148 	.word	0x08000148
10000874:	40260000 	.word	0x40260000

10000878 <Cy_SysClk_PllGetConfiguration>:


cy_en_sysclk_status_t Cy_SysClk_PllGetConfiguration(uint32_t clkPath, cy_stc_pll_manual_config_t *config)
{
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
    clkPath--; /* to correctly access PLL config and status register structures */
10000878:	3801      	subs	r0, #1
    if (clkPath < CY_SRSS_NUM_PLL)
1000087a:	4b11      	ldr	r3, [pc, #68]	; (100008c0 <Cy_SysClk_PllGetConfiguration+0x48>)
1000087c:	681a      	ldr	r2, [r3, #0]
1000087e:	233f      	movs	r3, #63	; 0x3f
10000880:	5cd3      	ldrb	r3, [r2, r3]
10000882:	4283      	cmp	r3, r0
10000884:	d91a      	bls.n	100008bc <Cy_SysClk_PllGetConfiguration+0x44>
    {
        uint32_t tempReg = SRSS_CLK_PLL_CONFIG[clkPath];
10000886:	3081      	adds	r0, #129	; 0x81
10000888:	30ff      	adds	r0, #255	; 0xff
1000088a:	0080      	lsls	r0, r0, #2
1000088c:	4b0d      	ldr	r3, [pc, #52]	; (100008c4 <Cy_SysClk_PllGetConfiguration+0x4c>)
1000088e:	58c3      	ldr	r3, [r0, r3]
        config->feedbackDiv  = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_FEEDBACK_DIV,  tempReg);
10000890:	227f      	movs	r2, #127	; 0x7f
10000892:	401a      	ands	r2, r3
10000894:	700a      	strb	r2, [r1, #0]
        config->referenceDiv = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_REFERENCE_DIV, tempReg);
10000896:	0a18      	lsrs	r0, r3, #8
10000898:	221f      	movs	r2, #31
1000089a:	4010      	ands	r0, r2
1000089c:	7048      	strb	r0, [r1, #1]
        config->outputDiv    = (uint8_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_OUTPUT_DIV,    tempReg);
1000089e:	0c18      	lsrs	r0, r3, #16
100008a0:	4002      	ands	r2, r0
100008a2:	708a      	strb	r2, [r1, #2]
        config->lfMode       =         _FLD2BOOL(SRSS_CLK_PLL_CONFIG_PLL_LF_MODE,   tempReg);
100008a4:	2280      	movs	r2, #128	; 0x80
100008a6:	0512      	lsls	r2, r2, #20
100008a8:	401a      	ands	r2, r3
100008aa:	1e50      	subs	r0, r2, #1
100008ac:	4182      	sbcs	r2, r0
100008ae:	70ca      	strb	r2, [r1, #3]
        config->outputMode   = (cy_en_fll_pll_output_mode_t)((uint32_t)_FLD2VAL(SRSS_CLK_PLL_CONFIG_BYPASS_SEL, tempReg));
100008b0:	0f1b      	lsrs	r3, r3, #28
100008b2:	2203      	movs	r2, #3
100008b4:	4013      	ands	r3, r2
100008b6:	710b      	strb	r3, [r1, #4]
        retVal = CY_SYSCLK_SUCCESS;
100008b8:	2000      	movs	r0, #0
    }
    return (retVal);
}
100008ba:	4770      	bx	lr
    cy_en_sysclk_status_t retVal = CY_SYSCLK_BAD_PARAM;
100008bc:	4802      	ldr	r0, [pc, #8]	; (100008c8 <Cy_SysClk_PllGetConfiguration+0x50>)
    return (retVal);
100008be:	e7fc      	b.n	100008ba <Cy_SysClk_PllGetConfiguration+0x42>
100008c0:	08000148 	.word	0x08000148
100008c4:	40260000 	.word	0x40260000
100008c8:	004a0001 	.word	0x004a0001

100008cc <Cy_SysClk_FllGetFrequency>:
    return (CY_SYSLIB_DIV_ROUND(freq, 1UL + (uint32_t)Cy_SysClk_ClkTimerGetDivider()));
}


uint32_t Cy_SysClk_FllGetFrequency(void)
{
100008cc:	b5f0      	push	{r4, r5, r6, r7, lr}
100008ce:	b087      	sub	sp, #28
    uint32_t rDiv;    /* FLL reference divider */
    uint32_t oDiv;    /* FLL output divider */
    bool  enabled;    /* FLL enable status; n/a for direct */
    uint32_t freq = 0UL;    /* FLL Frequency */

    cy_stc_fll_manual_config_t fllCfg = {0UL,0U,CY_SYSCLK_FLL_CCO_RANGE0,false,0U,0U,0U,0U,CY_SYSCLK_FLLPLL_OUTPUT_AUTO,0U};
100008d0:	2214      	movs	r2, #20
100008d2:	2100      	movs	r1, #0
100008d4:	a801      	add	r0, sp, #4
100008d6:	f000 fd43 	bl	10001360 <memset>
    Cy_SysClk_FllGetConfiguration(&fllCfg);
100008da:	a801      	add	r0, sp, #4
100008dc:	f7ff ff7a 	bl	100007d4 <Cy_SysClk_FllGetConfiguration>
    enabled = (Cy_SysClk_FllIsEnabled()) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != fllCfg.outputMode);
100008e0:	f7ff ff70 	bl	100007c4 <Cy_SysClk_FllIsEnabled>
100008e4:	2800      	cmp	r0, #0
100008e6:	d007      	beq.n	100008f8 <Cy_SysClk_FllGetFrequency+0x2c>
100008e8:	ab01      	add	r3, sp, #4
100008ea:	7b9b      	ldrb	r3, [r3, #14]
100008ec:	2b02      	cmp	r3, #2
100008ee:	d001      	beq.n	100008f4 <Cy_SysClk_FllGetFrequency+0x28>
100008f0:	2301      	movs	r3, #1
100008f2:	e002      	b.n	100008fa <Cy_SysClk_FllGetFrequency+0x2e>
100008f4:	2300      	movs	r3, #0
100008f6:	e000      	b.n	100008fa <Cy_SysClk_FllGetFrequency+0x2e>
100008f8:	2300      	movs	r3, #0
    fDiv = fllCfg.fllMult;
100008fa:	aa01      	add	r2, sp, #4
100008fc:	9e01      	ldr	r6, [sp, #4]
    rDiv = fllCfg.refDiv;
100008fe:	8894      	ldrh	r4, [r2, #4]
10000900:	0020      	movs	r0, r4
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
10000902:	79d2      	ldrb	r2, [r2, #7]
10000904:	2a00      	cmp	r2, #0
10000906:	d01f      	beq.n	10000948 <Cy_SysClk_FllGetFrequency+0x7c>
10000908:	2502      	movs	r5, #2

    if (enabled && /* If FLL is enabled and not bypassed */
1000090a:	2b00      	cmp	r3, #0
1000090c:	d01e      	beq.n	1000094c <Cy_SysClk_FllGetFrequency+0x80>
1000090e:	2800      	cmp	r0, #0
10000910:	d01d      	beq.n	1000094e <Cy_SysClk_FllGetFrequency+0x82>
        (0UL != rDiv)) /* to avoid division by zero */
    {
        freq = Cy_SysClk_ClkPathMuxGetFrequency(0UL); /* FLL mapped always to path 0 */
10000912:	2000      	movs	r0, #0
10000914:	f7ff fef6 	bl	10000704 <Cy_SysClk_ClkPathMuxGetFrequency>
        freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
10000918:	0032      	movs	r2, r6
1000091a:	2300      	movs	r3, #0
1000091c:	2100      	movs	r1, #0
1000091e:	f000 fbfb 	bl	10001118 <__aeabi_lmul>
10000922:	0006      	movs	r6, r0
10000924:	000f      	movs	r7, r1
10000926:	002a      	movs	r2, r5
10000928:	2300      	movs	r3, #0
1000092a:	0020      	movs	r0, r4
1000092c:	2100      	movs	r1, #0
1000092e:	f000 fbf3 	bl	10001118 <__aeabi_lmul>
10000932:	0002      	movs	r2, r0
10000934:	000b      	movs	r3, r1
10000936:	07cc      	lsls	r4, r1, #31
10000938:	0840      	lsrs	r0, r0, #1
1000093a:	4320      	orrs	r0, r4
1000093c:	0849      	lsrs	r1, r1, #1
1000093e:	1980      	adds	r0, r0, r6
10000940:	4179      	adcs	r1, r7
10000942:	f000 fbc9 	bl	100010d8 <__aeabi_uldivmod>
10000946:	e002      	b.n	1000094e <Cy_SysClk_FllGetFrequency+0x82>
    oDiv = (fllCfg.enableOutputDiv) ? 2UL : 1UL;
10000948:	2501      	movs	r5, #1
1000094a:	e7de      	b.n	1000090a <Cy_SysClk_FllGetFrequency+0x3e>
    uint32_t freq = 0UL;    /* FLL Frequency */
1000094c:	2000      	movs	r0, #0
                                             ((uint64_t)rDiv * (uint64_t)oDiv));
    }

    return (freq);
}
1000094e:	b007      	add	sp, #28
10000950:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

10000954 <Cy_SysClk_PllGetFrequency>:

uint32_t Cy_SysClk_PllGetFrequency(uint32_t clkPath)
{
10000954:	b5f0      	push	{r4, r5, r6, r7, lr}
10000956:	b085      	sub	sp, #20
10000958:	0004      	movs	r4, r0
    uint32_t rDiv;    /* PLL reference divider */
    uint32_t oDiv;    /* PLL output divider */
    bool  enabled;    /* PLL enable status; n/a for direct */
    uint32_t freq=0UL;    /* PLL Frequency */

    if((CY_SRSS_NUM_PLL > 0UL) && (clkPath > 0UL))
1000095a:	4b2e      	ldr	r3, [pc, #184]	; (10000a14 <Cy_SysClk_PllGetFrequency+0xc0>)
1000095c:	681b      	ldr	r3, [r3, #0]
1000095e:	223f      	movs	r2, #63	; 0x3f
10000960:	5c9a      	ldrb	r2, [r3, r2]
10000962:	2a00      	cmp	r2, #0
10000964:	d053      	beq.n	10000a0e <Cy_SysClk_PllGetFrequency+0xba>
10000966:	2800      	cmp	r0, #0
10000968:	d052      	beq.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
    {
        CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
1000096a:	223e      	movs	r2, #62	; 0x3e
1000096c:	5c9b      	ldrb	r3, [r3, r2]
1000096e:	4283      	cmp	r3, r0
10000970:	d800      	bhi.n	10000974 <Cy_SysClk_PllGetFrequency+0x20>
10000972:	be01      	bkpt	0x0001

        if (clkPath <= CY_SRSS_NUM_PLL)
10000974:	4b27      	ldr	r3, [pc, #156]	; (10000a14 <Cy_SysClk_PllGetFrequency+0xc0>)
10000976:	681a      	ldr	r2, [r3, #0]
10000978:	233f      	movs	r3, #63	; 0x3f
1000097a:	5cd3      	ldrb	r3, [r2, r3]
1000097c:	42a3      	cmp	r3, r4
1000097e:	d201      	bcs.n	10000984 <Cy_SysClk_PllGetFrequency+0x30>
    uint32_t freq=0UL;    /* PLL Frequency */
10000980:	2000      	movs	r0, #0
                                                     ((uint64_t)rDiv * (uint64_t)oDiv));
            }
        }
    }

    return (freq);
10000982:	e045      	b.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
            cy_stc_pll_manual_config_t pllcfg = {0U,0U,0U,false,CY_SYSCLK_FLLPLL_OUTPUT_AUTO};
10000984:	2205      	movs	r2, #5
10000986:	2100      	movs	r1, #0
10000988:	a802      	add	r0, sp, #8
1000098a:	f000 fce9 	bl	10001360 <memset>
            (void)Cy_SysClk_PllGetConfiguration(clkPath, &pllcfg);
1000098e:	a902      	add	r1, sp, #8
10000990:	0020      	movs	r0, r4
10000992:	f7ff ff71 	bl	10000878 <Cy_SysClk_PllGetConfiguration>
            enabled = (Cy_SysClk_PllIsEnabled(clkPath)) && (CY_SYSCLK_FLLPLL_OUTPUT_INPUT != pllcfg.outputMode);
10000996:	0020      	movs	r0, r4
10000998:	f7ff ff5a 	bl	10000850 <Cy_SysClk_PllIsEnabled>
1000099c:	2800      	cmp	r0, #0
1000099e:	d007      	beq.n	100009b0 <Cy_SysClk_PllGetFrequency+0x5c>
100009a0:	ab02      	add	r3, sp, #8
100009a2:	791b      	ldrb	r3, [r3, #4]
100009a4:	2b02      	cmp	r3, #2
100009a6:	d001      	beq.n	100009ac <Cy_SysClk_PllGetFrequency+0x58>
100009a8:	2301      	movs	r3, #1
100009aa:	e002      	b.n	100009b2 <Cy_SysClk_PllGetFrequency+0x5e>
100009ac:	2300      	movs	r3, #0
100009ae:	e000      	b.n	100009b2 <Cy_SysClk_PllGetFrequency+0x5e>
100009b0:	2300      	movs	r3, #0
            fDiv = pllcfg.feedbackDiv;
100009b2:	aa02      	add	r2, sp, #8
100009b4:	7816      	ldrb	r6, [r2, #0]
            rDiv = pllcfg.referenceDiv;
100009b6:	7857      	ldrb	r7, [r2, #1]
100009b8:	0038      	movs	r0, r7
            oDiv = pllcfg.outputDiv;
100009ba:	7895      	ldrb	r5, [r2, #2]
            if (enabled && /* If PLL is enabled and not bypassed */
100009bc:	2b00      	cmp	r3, #0
100009be:	d024      	beq.n	10000a0a <Cy_SysClk_PllGetFrequency+0xb6>
100009c0:	2f00      	cmp	r7, #0
100009c2:	d025      	beq.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
            (0UL != rDiv) && (0UL != oDiv)) /* to avoid division by zero */
100009c4:	2d00      	cmp	r5, #0
100009c6:	d101      	bne.n	100009cc <Cy_SysClk_PllGetFrequency+0x78>
    uint32_t freq=0UL;    /* PLL Frequency */
100009c8:	0028      	movs	r0, r5
100009ca:	e021      	b.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
                freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
100009cc:	0020      	movs	r0, r4
100009ce:	f7ff fe99 	bl	10000704 <Cy_SysClk_ClkPathMuxGetFrequency>
                freq = (uint32_t)CY_SYSLIB_DIV_ROUND(((uint64_t)freq * (uint64_t)fDiv),
100009d2:	0032      	movs	r2, r6
100009d4:	2300      	movs	r3, #0
100009d6:	2100      	movs	r1, #0
100009d8:	f000 fb9e 	bl	10001118 <__aeabi_lmul>
100009dc:	9000      	str	r0, [sp, #0]
100009de:	9101      	str	r1, [sp, #4]
100009e0:	002a      	movs	r2, r5
100009e2:	2300      	movs	r3, #0
100009e4:	0038      	movs	r0, r7
100009e6:	2100      	movs	r1, #0
100009e8:	f000 fb96 	bl	10001118 <__aeabi_lmul>
100009ec:	0002      	movs	r2, r0
100009ee:	000b      	movs	r3, r1
100009f0:	07cc      	lsls	r4, r1, #31
100009f2:	0840      	lsrs	r0, r0, #1
100009f4:	4320      	orrs	r0, r4
100009f6:	0849      	lsrs	r1, r1, #1
100009f8:	9c00      	ldr	r4, [sp, #0]
100009fa:	9d01      	ldr	r5, [sp, #4]
100009fc:	1824      	adds	r4, r4, r0
100009fe:	414d      	adcs	r5, r1
10000a00:	0020      	movs	r0, r4
10000a02:	0029      	movs	r1, r5
10000a04:	f000 fb68 	bl	100010d8 <__aeabi_uldivmod>
10000a08:	e002      	b.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
    uint32_t freq=0UL;    /* PLL Frequency */
10000a0a:	2000      	movs	r0, #0
10000a0c:	e000      	b.n	10000a10 <Cy_SysClk_PllGetFrequency+0xbc>
10000a0e:	2000      	movs	r0, #0
}
10000a10:	b005      	add	sp, #20
10000a12:	bdf0      	pop	{r4, r5, r6, r7, pc}
10000a14:	08000148 	.word	0x08000148

10000a18 <Cy_SysClk_ClkPathGetFrequency>:
{
10000a18:	b510      	push	{r4, lr}
10000a1a:	0004      	movs	r4, r0
    CY_ASSERT_L1(clkPath < CY_SRSS_NUM_CLKPATH);
10000a1c:	4b0d      	ldr	r3, [pc, #52]	; (10000a54 <Cy_SysClk_ClkPathGetFrequency+0x3c>)
10000a1e:	681a      	ldr	r2, [r3, #0]
10000a20:	233e      	movs	r3, #62	; 0x3e
10000a22:	5cd3      	ldrb	r3, [r2, r3]
10000a24:	4283      	cmp	r3, r0
10000a26:	d800      	bhi.n	10000a2a <Cy_SysClk_ClkPathGetFrequency+0x12>
10000a28:	be01      	bkpt	0x0001
    if (clkPath == (uint32_t)CY_SYSCLK_CLKHF_IN_CLKPATH0) /* FLL? (always path 0) */
10000a2a:	2c00      	cmp	r4, #0
10000a2c:	d009      	beq.n	10000a42 <Cy_SysClk_ClkPathGetFrequency+0x2a>
    else if (clkPath <= CY_SRSS_NUM_PLL) /* PLL? (always path 1...N)*/
10000a2e:	4b09      	ldr	r3, [pc, #36]	; (10000a54 <Cy_SysClk_ClkPathGetFrequency+0x3c>)
10000a30:	681a      	ldr	r2, [r3, #0]
10000a32:	233f      	movs	r3, #63	; 0x3f
10000a34:	5cd3      	ldrb	r3, [r2, r3]
10000a36:	42a3      	cmp	r3, r4
10000a38:	d208      	bcs.n	10000a4c <Cy_SysClk_ClkPathGetFrequency+0x34>
        freq = Cy_SysClk_ClkPathMuxGetFrequency(clkPath);
10000a3a:	0020      	movs	r0, r4
10000a3c:	f7ff fe62 	bl	10000704 <Cy_SysClk_ClkPathMuxGetFrequency>
}
10000a40:	bd10      	pop	{r4, pc}
        freq = Cy_SysClk_FllGetFrequency();
10000a42:	f7ff ff43 	bl	100008cc <Cy_SysClk_FllGetFrequency>
    if(freq==0UL)
10000a46:	2800      	cmp	r0, #0
10000a48:	d1fa      	bne.n	10000a40 <Cy_SysClk_ClkPathGetFrequency+0x28>
10000a4a:	e7f6      	b.n	10000a3a <Cy_SysClk_ClkPathGetFrequency+0x22>
        freq = Cy_SysClk_PllGetFrequency(clkPath);
10000a4c:	0020      	movs	r0, r4
10000a4e:	f7ff ff81 	bl	10000954 <Cy_SysClk_PllGetFrequency>
10000a52:	e7f8      	b.n	10000a46 <Cy_SysClk_ClkPathGetFrequency+0x2e>
10000a54:	08000148 	.word	0x08000148

10000a58 <Cy_SysClk_ClkHfGetFrequency>:
{
10000a58:	b570      	push	{r4, r5, r6, lr}
10000a5a:	0006      	movs	r6, r0
    uint32_t pDiv = 1UL << (uint32_t)Cy_SysClk_ClkHfGetDivider(clkHf); /* root prescaler (1/2/4/8) */
10000a5c:	f7ff fdec 	bl	10000638 <Cy_SysClk_ClkHfGetDivider>
10000a60:	0005      	movs	r5, r0
10000a62:	2401      	movs	r4, #1
10000a64:	4084      	lsls	r4, r0
    uint32_t path = (uint32_t) Cy_SysClk_ClkHfGetSource(clkHf); /* path input for root 0 (clkHf[0]) */
10000a66:	0030      	movs	r0, r6
10000a68:	f7ff fdd4 	bl	10000614 <Cy_SysClk_ClkHfGetSource>
    uint32_t freq = Cy_SysClk_ClkPathGetFrequency(path);
10000a6c:	f7ff ffd4 	bl	10000a18 <Cy_SysClk_ClkPathGetFrequency>
    return (CY_SYSLIB_DIV_ROUND(freq, pDiv));
10000a70:	0864      	lsrs	r4, r4, #1
10000a72:	1820      	adds	r0, r4, r0
10000a74:	40e8      	lsrs	r0, r5
}
10000a76:	bd70      	pop	{r4, r5, r6, pc}

10000a78 <Cy_SysIpcPipeIsrCm0>:
*
* This is the interrupt service routine for the system pipe.
*
*******************************************************************************/
void Cy_SysIpcPipeIsrCm0(void)
{
10000a78:	b510      	push	{r4, lr}
    Cy_IPC_Pipe_ExecuteCallback(CY_IPC_EP_CYPIPE_CM0_ADDR);
10000a7a:	2000      	movs	r0, #0
10000a7c:	f7ff fc2c 	bl	100002d8 <Cy_IPC_Pipe_ExecuteCallback>
}
10000a80:	bd10      	pop	{r4, pc}

10000a82 <Cy_SystemInit>:
}
10000a82:	4770      	bx	lr

10000a84 <SystemCoreClockUpdate>:
{
10000a84:	b510      	push	{r4, lr}
    uint32 locHf0Clock = Cy_SysClk_ClkHfGetFrequency(0UL);
10000a86:	2000      	movs	r0, #0
10000a88:	f7ff ffe6 	bl	10000a58 <Cy_SysClk_ClkHfGetFrequency>
10000a8c:	1e04      	subs	r4, r0, #0
    if (0UL != locHf0Clock)
10000a8e:	d100      	bne.n	10000a92 <SystemCoreClockUpdate+0xe>
}
10000a90:	bd10      	pop	{r4, pc}
        cy_Hfclk0FreqHz = locHf0Clock;
10000a92:	4b14      	ldr	r3, [pc, #80]	; (10000ae4 <SystemCoreClockUpdate+0x60>)
10000a94:	6018      	str	r0, [r3, #0]
        cy_PeriClkFreqHz = locHf0Clock / (1UL + (uint32_t)Cy_SysClk_ClkPeriGetDivider());
10000a96:	f7ff fdb1 	bl	100005fc <Cy_SysClk_ClkPeriGetDivider>
10000a9a:	1c41      	adds	r1, r0, #1
10000a9c:	0020      	movs	r0, r4
10000a9e:	f000 fa8f 	bl	10000fc0 <__udivsi3>
10000aa2:	0004      	movs	r4, r0
10000aa4:	4b10      	ldr	r3, [pc, #64]	; (10000ae8 <SystemCoreClockUpdate+0x64>)
10000aa6:	6018      	str	r0, [r3, #0]
        SystemCoreClock = cy_PeriClkFreqHz / (1UL + (uint32_t)Cy_SysClk_ClkSlowGetDivider());
10000aa8:	f7ff fd9c 	bl	100005e4 <Cy_SysClk_ClkSlowGetDivider>
10000aac:	1c41      	adds	r1, r0, #1
10000aae:	0020      	movs	r0, r4
10000ab0:	f000 fa86 	bl	10000fc0 <__udivsi3>
10000ab4:	0004      	movs	r4, r0
10000ab6:	4b0d      	ldr	r3, [pc, #52]	; (10000aec <SystemCoreClockUpdate+0x68>)
10000ab8:	6018      	str	r0, [r3, #0]
        cy_delayFreqMhz = (uint8_t)CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1M_THRESHOLD);
10000aba:	3c01      	subs	r4, #1
10000abc:	490c      	ldr	r1, [pc, #48]	; (10000af0 <SystemCoreClockUpdate+0x6c>)
10000abe:	0020      	movs	r0, r4
10000ac0:	f000 fa7e 	bl	10000fc0 <__udivsi3>
10000ac4:	3001      	adds	r0, #1
10000ac6:	4b0b      	ldr	r3, [pc, #44]	; (10000af4 <SystemCoreClockUpdate+0x70>)
10000ac8:	7018      	strb	r0, [r3, #0]
        cy_delayFreqKhz = CY_SYSLIB_DIV_ROUNDUP(SystemCoreClock, CY_DELAY_1K_THRESHOLD);
10000aca:	21fa      	movs	r1, #250	; 0xfa
10000acc:	0089      	lsls	r1, r1, #2
10000ace:	0020      	movs	r0, r4
10000ad0:	f000 fa76 	bl	10000fc0 <__udivsi3>
10000ad4:	3001      	adds	r0, #1
10000ad6:	4b08      	ldr	r3, [pc, #32]	; (10000af8 <SystemCoreClockUpdate+0x74>)
10000ad8:	6018      	str	r0, [r3, #0]
        cy_delay32kMs   = CY_DELAY_MS_OVERFLOW_THRESHOLD * cy_delayFreqKhz;
10000ada:	03c0      	lsls	r0, r0, #15
10000adc:	4b07      	ldr	r3, [pc, #28]	; (10000afc <SystemCoreClockUpdate+0x78>)
10000ade:	6018      	str	r0, [r3, #0]
}
10000ae0:	e7d6      	b.n	10000a90 <SystemCoreClockUpdate+0xc>
10000ae2:	46c0      	nop			; (mov r8, r8)
10000ae4:	08000084 	.word	0x08000084
10000ae8:	08000088 	.word	0x08000088
10000aec:	08000080 	.word	0x08000080
10000af0:	000f4240 	.word	0x000f4240
10000af4:	08000094 	.word	0x08000094
10000af8:	08000090 	.word	0x08000090
10000afc:	0800008c 	.word	0x0800008c

10000b00 <SystemInit>:
{
10000b00:	b510      	push	{r4, lr}
    Cy_PDL_Init(CY_DEVICE_CFG);
10000b02:	4823      	ldr	r0, [pc, #140]	; (10000b90 <SystemInit+0x90>)
10000b04:	f7ff fae0 	bl	100000c8 <Cy_PDL_Init>
    uint32_t copy = SRSS->CLK_FLL_CONFIG;
10000b08:	4c22      	ldr	r4, [pc, #136]	; (10000b94 <SystemInit+0x94>)
10000b0a:	22b0      	movs	r2, #176	; 0xb0
10000b0c:	00d2      	lsls	r2, r2, #3
10000b0e:	58a3      	ldr	r3, [r4, r2]
    copy &= ~SRSS_CLK_FLL_CONFIG_FLL_ENABLE_Msk;
10000b10:	005b      	lsls	r3, r3, #1
10000b12:	085b      	lsrs	r3, r3, #1
    SRSS->CLK_FLL_CONFIG = copy;
10000b14:	50a3      	str	r3, [r4, r2]
    copy = SRSS->CLK_ROOT_SELECT[0u];
10000b16:	21e0      	movs	r1, #224	; 0xe0
10000b18:	0089      	lsls	r1, r1, #2
10000b1a:	5863      	ldr	r3, [r4, r1]
    copy &= ~SRSS_CLK_ROOT_SELECT_ROOT_DIV_Msk; /* Set ROOT_DIV = 0*/
10000b1c:	2030      	movs	r0, #48	; 0x30
10000b1e:	4383      	bics	r3, r0
    SRSS->CLK_ROOT_SELECT[0u] = copy;
10000b20:	5063      	str	r3, [r4, r1]
    SRSS->CLK_FLL_CONFIG  = CY_FB_CLK_FLL_CONFIG_VALUE;
10000b22:	2380      	movs	r3, #128	; 0x80
10000b24:	045b      	lsls	r3, r3, #17
10000b26:	50a3      	str	r3, [r4, r2]
    SRSS->CLK_FLL_CONFIG2 = CY_FB_CLK_FLL_CONFIG2_VALUE;
10000b28:	4b1b      	ldr	r3, [pc, #108]	; (10000b98 <SystemInit+0x98>)
10000b2a:	4a1c      	ldr	r2, [pc, #112]	; (10000b9c <SystemInit+0x9c>)
10000b2c:	50e2      	str	r2, [r4, r3]
    SRSS->CLK_FLL_CONFIG3 = CY_FB_CLK_FLL_CONFIG3_VALUE;
10000b2e:	3304      	adds	r3, #4
10000b30:	22a0      	movs	r2, #160	; 0xa0
10000b32:	0192      	lsls	r2, r2, #6
10000b34:	50e2      	str	r2, [r4, r3]
    SRSS->CLK_FLL_CONFIG4 = CY_FB_CLK_FLL_CONFIG4_VALUE;
10000b36:	4b1a      	ldr	r3, [pc, #104]	; (10000ba0 <SystemInit+0xa0>)
10000b38:	22ff      	movs	r2, #255	; 0xff
10000b3a:	50e2      	str	r2, [r4, r3]
    Cy_WDT_Unlock();
10000b3c:	f7ff fc8e 	bl	1000045c <Cy_WDT_Unlock>
* disabled. Call the Cy_WDT_Unlock() API to unlock the WDT.
*
*******************************************************************************/
__STATIC_INLINE void Cy_WDT_Disable(void)
{
    SRSS_WDT_CTL &= ((uint32_t) ~(_VAL2FLD(SRSS_WDT_CTL_WDT_EN, 1U)));
10000b40:	22c0      	movs	r2, #192	; 0xc0
10000b42:	0052      	lsls	r2, r2, #1
10000b44:	58a3      	ldr	r3, [r4, r2]
10000b46:	2101      	movs	r1, #1
10000b48:	438b      	bics	r3, r1
10000b4a:	50a3      	str	r3, [r4, r2]
    Cy_SystemInit();
10000b4c:	f7ff ff99 	bl	10000a82 <Cy_SystemInit>
    SystemCoreClockUpdate();
10000b50:	f7ff ff98 	bl	10000a84 <SystemCoreClockUpdate>
    REG_IPC_STRUCT_DATA(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT)) = 0UL;
10000b54:	4b13      	ldr	r3, [pc, #76]	; (10000ba4 <SystemInit+0xa4>)
10000b56:	681b      	ldr	r3, [r3, #0]
10000b58:	20ba      	movs	r0, #186	; 0xba
10000b5a:	5a19      	ldrh	r1, [r3, r0]
10000b5c:	00ca      	lsls	r2, r1, #3
10000b5e:	1a52      	subs	r2, r2, r1
10000b60:	6a19      	ldr	r1, [r3, #32]
10000b62:	468c      	mov	ip, r1
10000b64:	4462      	add	r2, ip
10000b66:	2100      	movs	r1, #0
10000b68:	60d1      	str	r1, [r2, #12]
    REG_IPC_STRUCT_RELEASE(CY_IPC_STRUCT_PTR(CY_IPC_CHAN_DDFT)) = 0UL;
10000b6a:	6a1a      	ldr	r2, [r3, #32]
10000b6c:	5a18      	ldrh	r0, [r3, r0]
10000b6e:	00c3      	lsls	r3, r0, #3
10000b70:	1a1b      	subs	r3, r3, r0
10000b72:	18d3      	adds	r3, r2, r3
10000b74:	6059      	str	r1, [r3, #4]
    (void) Cy_IPC_Sema_Init(CY_IPC_CHAN_SEMA, CY_IPC_SEMA_COUNT, ipcSemaArray);
10000b76:	4a0c      	ldr	r2, [pc, #48]	; (10000ba8 <SystemInit+0xa8>)
10000b78:	3180      	adds	r1, #128	; 0x80
10000b7a:	2003      	movs	r0, #3
10000b7c:	f7ff fc40 	bl	10000400 <Cy_IPC_Sema_Init>
    Cy_IPC_Pipe_Config(systemIpcPipeEpArray);
10000b80:	480a      	ldr	r0, [pc, #40]	; (10000bac <SystemInit+0xac>)
10000b82:	f7ff faa7 	bl	100000d4 <Cy_IPC_Pipe_Config>
    Cy_IPC_Pipe_Init(&systemIpcPipeConfigCm0);
10000b86:	480a      	ldr	r0, [pc, #40]	; (10000bb0 <SystemInit+0xb0>)
10000b88:	f7ff fafc 	bl	10000184 <Cy_IPC_Pipe_Init>
}
10000b8c:	bd10      	pop	{r4, pc}
10000b8e:	46c0      	nop			; (mov r8, r8)
10000b90:	10001388 	.word	0x10001388
10000b94:	40260000 	.word	0x40260000
10000b98:	00000584 	.word	0x00000584
10000b9c:	00020001 	.word	0x00020001
10000ba0:	0000058c 	.word	0x0000058c
10000ba4:	08000148 	.word	0x08000148
10000ba8:	080000dc 	.word	0x080000dc
10000bac:	0800015c 	.word	0x0800015c
10000bb0:	10001448 	.word	0x10001448

10000bb4 <Cy_OnResetUser>:
    .weak   Cy_OnResetUser
    .func   Cy_OnResetUser, Cy_OnResetUser
    .type   Cy_OnResetUser, %function

Cy_OnResetUser:
    bx lr
10000bb4:	4770      	bx	lr

10000bb6 <Reset_Handler>:
    /* Reset handler */
    .weak    Reset_Handler
    .type    Reset_Handler, %function

Reset_Handler:
    bl Cy_OnResetUser
10000bb6:	f7ff fffd 	bl	10000bb4 <Cy_OnResetUser>
    cpsid i
10000bba:	b672      	cpsid	i
 *    offset 4: VMA of start of a section to copy to
 *    offset 8: size of the section to copy. Must be multiply of 4
 *
 *  All addresses must be aligned to 4 bytes boundary.
 */
    ldr    r4, =__copy_table_start__
10000bbc:	4c0f      	ldr	r4, [pc, #60]	; (10000bfc <Reset_Handler+0x46>)
    ldr    r5, =__copy_table_end__
10000bbe:	4d10      	ldr	r5, [pc, #64]	; (10000c00 <Reset_Handler+0x4a>)

.L_loop0:
    cmp    r4, r5
10000bc0:	42ac      	cmp	r4, r5
    bge    .L_loop0_done
10000bc2:	da09      	bge.n	10000bd8 <Reset_Handler+0x22>
    ldr    r1, [r4]
10000bc4:	6821      	ldr	r1, [r4, #0]
    ldr    r2, [r4, #4]
10000bc6:	6862      	ldr	r2, [r4, #4]
    ldr    r3, [r4, #8]
10000bc8:	68a3      	ldr	r3, [r4, #8]

.L_loop0_0:
    subs    r3, #4
10000bca:	3b04      	subs	r3, #4
    blt    .L_loop0_0_done
10000bcc:	db02      	blt.n	10000bd4 <Reset_Handler+0x1e>
    ldr    r0, [r1, r3]
10000bce:	58c8      	ldr	r0, [r1, r3]
    str    r0, [r2, r3]
10000bd0:	50d0      	str	r0, [r2, r3]
    b    .L_loop0_0
10000bd2:	e7fa      	b.n	10000bca <Reset_Handler+0x14>

.L_loop0_0_done:
    adds    r4, #12
10000bd4:	340c      	adds	r4, #12
    b    .L_loop0
10000bd6:	e7f3      	b.n	10000bc0 <Reset_Handler+0xa>
 *    __bss_start__: start of the BSS section.
 *    __bss_end__: end of the BSS section.
 *
 *  Both addresses must be aligned to 4 bytes boundary.
 */
    ldr    r1, =__bss_start__
10000bd8:	490a      	ldr	r1, [pc, #40]	; (10000c04 <Reset_Handler+0x4e>)
    ldr    r2, =__bss_end__
10000bda:	4a0b      	ldr	r2, [pc, #44]	; (10000c08 <Reset_Handler+0x52>)

    movs    r0, 0
10000bdc:	2000      	movs	r0, #0

    subs    r2, r1
10000bde:	1a52      	subs	r2, r2, r1
    ble    .L_loop3_done
10000be0:	dd02      	ble.n	10000be8 <Reset_Handler+0x32>

.L_loop3:
    subs    r2, #4
10000be2:	3a04      	subs	r2, #4
    str    r0, [r1, r2]
10000be4:	5088      	str	r0, [r1, r2]
    bgt    .L_loop3
10000be6:	dcfc      	bgt.n	10000be2 <Reset_Handler+0x2c>
.L_loop3_done:
#endif /* __STARTUP_CLEAR_BSS_MULTIPLE || __STARTUP_CLEAR_BSS */

    /* Update Vector Table Offset Register. */
    ldr r0, =__ramVectors
10000be8:	4808      	ldr	r0, [pc, #32]	; (10000c0c <Reset_Handler+0x56>)
    ldr r1, =CY_CPU_VTOR_ADDR
10000bea:	4909      	ldr	r1, [pc, #36]	; (10000c10 <Reset_Handler+0x5a>)
    str r0, [r1]
10000bec:	6008      	str	r0, [r1, #0]
    dsb 0xF
10000bee:	f3bf 8f4f 	dsb	sy

#ifndef __NO_SYSTEM_INIT
    bl    SystemInit
10000bf2:	f7ff ff85 	bl	10000b00 <SystemInit>
#endif

    bl    main
10000bf6:	f000 f9cf 	bl	10000f98 <main>

    /* Should never get here */
    b   .
10000bfa:	e7fe      	b.n	10000bfa <Reset_Handler+0x44>
    ldr    r4, =__copy_table_start__
10000bfc:	10001488 	.word	0x10001488
    ldr    r5, =__copy_table_end__
10000c00:	100014a0 	.word	0x100014a0
    ldr    r1, =__bss_start__
10000c04:	0800012c 	.word	0x0800012c
    ldr    r2, =__bss_end__
10000c08:	080002dc 	.word	0x080002dc
    ldr r0, =__ramVectors
10000c0c:	08000000 	.word	0x08000000
    ldr r1, =CY_CPU_VTOR_ADDR
10000c10:	e000ed08 	.word	0xe000ed08

10000c14 <Default_Handler>:
    .align    1
    .thumb_func
    .weak    Default_Handler
    .type    Default_Handler, %function
Default_Handler:
    b    .
10000c14:	e7fe      	b.n	10000c14 <Default_Handler>
    .size    Default_Handler, . - Default_Handler
    .weak    Cy_SysLib_FaultHandler
    .type    Cy_SysLib_FaultHandler, %function

Cy_SysLib_FaultHandler:
    b    .
10000c16:	e7fe      	b.n	10000c16 <Default_Handler+0x2>

10000c18 <HardFault_Handler>:
    .size    Cy_SysLib_FaultHandler, . - Cy_SysLib_FaultHandler
    .type Fault_Handler, %function

Fault_Handler:
    /* Storing LR content for Creator call stack trace */
    push {LR}
10000c18:	b500      	push	{lr}
    movs r0, #4
10000c1a:	2004      	movs	r0, #4
    mov r1, LR
10000c1c:	4671      	mov	r1, lr
    tst r0, r1
10000c1e:	4208      	tst	r0, r1
    beq .L_MSP
10000c20:	d002      	beq.n	10000c28 <HardFault_Handler+0x10>
    mrs r0, PSP
10000c22:	f3ef 8009 	mrs	r0, PSP
    b .L_API_call
10000c26:	e002      	b.n	10000c2e <HardFault_Handler+0x16>
.L_MSP:
    mrs r0, MSP
10000c28:	f3ef 8008 	mrs	r0, MSP
    /* Compensation of stack pointer address due to pushing 4 bytes of LR */
    adds r0, r0, #4
10000c2c:	3004      	adds	r0, #4
.L_API_call:
    bl Cy_SysLib_FaultHandler
10000c2e:	f000 f989 	bl	10000f44 <Cy_SysLib_FaultHandler>
    b   .
10000c32:	e7fe      	b.n	10000c32 <HardFault_Handler+0x1a>

10000c34 <Cy_GPIO_SetHSIOM>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetHSIOM
*
*******************************************************************************/
void Cy_GPIO_SetHSIOM(GPIO_PRT_Type* base, uint32_t pinNum, en_hsiom_sel_t value)
{
10000c34:	b510      	push	{r4, lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000c36:	2907      	cmp	r1, #7
10000c38:	d900      	bls.n	10000c3c <Cy_GPIO_SetHSIOM+0x8>
10000c3a:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(value));
10000c3c:	231f      	movs	r3, #31
10000c3e:	0014      	movs	r4, r2
10000c40:	439c      	bics	r4, r3
10000c42:	d000      	beq.n	10000c46 <Cy_GPIO_SetHSIOM+0x12>
10000c44:	be01      	bkpt	0x0001

    portNum = ((uint32_t)(base) - CY_GPIO_BASE) / GPIO_PRT_SECTION_SIZE;
10000c46:	4b10      	ldr	r3, [pc, #64]	; (10000c88 <Cy_GPIO_SetHSIOM+0x54>)
10000c48:	681b      	ldr	r3, [r3, #0]
10000c4a:	699c      	ldr	r4, [r3, #24]
10000c4c:	1b00      	subs	r0, r0, r4
10000c4e:	09c0      	lsrs	r0, r0, #7
    portAddrHSIOM = (HSIOM_PRT_V1_Type*)(CY_HSIOM_BASE + (HSIOM_PRT_SECTION_SIZE * portNum));
10000c50:	695b      	ldr	r3, [r3, #20]
10000c52:	0100      	lsls	r0, r0, #4
10000c54:	1818      	adds	r0, r3, r0

    #if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
        pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
    #endif

    if(pinNum < CY_GPIO_PRT_HALF)
10000c56:	2903      	cmp	r1, #3
10000c58:	d80a      	bhi.n	10000c70 <Cy_GPIO_SetHSIOM+0x3c>
        {
            /* secure pin */
            tempReg = 0UL;
        }
    #else
        tempReg = HSIOM_PRT_PORT_SEL0(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000c5a:	6804      	ldr	r4, [r0, #0]
10000c5c:	00c9      	lsls	r1, r1, #3
10000c5e:	231f      	movs	r3, #31
10000c60:	408b      	lsls	r3, r1
10000c62:	439c      	bics	r4, r3
    #endif
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000c64:	231f      	movs	r3, #31
10000c66:	401a      	ands	r2, r3
10000c68:	408a      	lsls	r2, r1
10000c6a:	4322      	orrs	r2, r4
        else
        {
            /* Secure PIN can't be modified using register policy */
        }
    #else
        HSIOM_PRT_PORT_SEL0(portAddrHSIOM) = hsiomReg;
10000c6c:	6002      	str	r2, [r0, #0]
        }
    #else
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
    #endif
    }
}
10000c6e:	bd10      	pop	{r4, pc}
        pinNum -= CY_GPIO_PRT_HALF;
10000c70:	3904      	subs	r1, #4
        tempReg = HSIOM_PRT_PORT_SEL1(portAddrHSIOM) & ~(CY_GPIO_HSIOM_MASK << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000c72:	6844      	ldr	r4, [r0, #4]
10000c74:	00c9      	lsls	r1, r1, #3
10000c76:	231f      	movs	r3, #31
10000c78:	408b      	lsls	r3, r1
10000c7a:	439c      	bics	r4, r3
        hsiomReg = tempReg | (((uint32_t)value & CY_GPIO_HSIOM_MASK) << (pinNum << CY_GPIO_HSIOM_OFFSET));
10000c7c:	231f      	movs	r3, #31
10000c7e:	401a      	ands	r2, r3
10000c80:	408a      	lsls	r2, r1
10000c82:	4322      	orrs	r2, r4
        HSIOM_PRT_PORT_SEL1(portAddrHSIOM) = hsiomReg;
10000c84:	6042      	str	r2, [r0, #4]
}
10000c86:	e7f2      	b.n	10000c6e <Cy_GPIO_SetHSIOM+0x3a>
10000c88:	08000148 	.word	0x08000148

10000c8c <Cy_GPIO_Write>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000c8c:	2907      	cmp	r1, #7
10000c8e:	d900      	bls.n	10000c92 <Cy_GPIO_Write+0x6>
10000c90:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000c92:	2a01      	cmp	r2, #1
10000c94:	d900      	bls.n	10000c98 <Cy_GPIO_Write+0xc>
10000c96:	be01      	bkpt	0x0001

    outMask = CY_GPIO_OUT_MASK << pinNum;
10000c98:	2301      	movs	r3, #1
10000c9a:	408b      	lsls	r3, r1
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    /* Thread-safe: Directly access the pin registers instead of base->OUT */
    if(0UL == value)
10000c9c:	2a00      	cmp	r2, #0
10000c9e:	d101      	bne.n	10000ca4 <Cy_GPIO_Write+0x18>
    {
        GPIO_PRT_OUT_CLR(base) = outMask;
10000ca0:	6043      	str	r3, [r0, #4]
    else
    {
        GPIO_PRT_OUT_SET(base) = outMask;
    }
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000ca2:	4770      	bx	lr
        GPIO_PRT_OUT_SET(base) = outMask;
10000ca4:	6083      	str	r3, [r0, #8]
}
10000ca6:	e7fc      	b.n	10000ca2 <Cy_GPIO_Write+0x16>

10000ca8 <Cy_GPIO_Inv>:

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000ca8:	2907      	cmp	r1, #7
10000caa:	d900      	bls.n	10000cae <Cy_GPIO_Inv+0x6>
10000cac:	be01      	bkpt	0x0001

    outMask = CY_GPIO_OUT_MASK << pinNum;
10000cae:	2301      	movs	r3, #1
10000cb0:	408b      	lsls	r3, r1
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_OUT_INV(base) = outMask;
10000cb2:	60c3      	str	r3, [r0, #12]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000cb4:	4770      	bx	lr
	...

10000cb8 <Cy_GPIO_SetDrivemode>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetDrivemode
*
*******************************************************************************/
void Cy_GPIO_SetDrivemode(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000cb8:	b530      	push	{r4, r5, lr}
10000cba:	0004      	movs	r4, r0
    uint32_t prtCfg;
#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000cbc:	2907      	cmp	r1, #7
10000cbe:	d900      	bls.n	10000cc2 <Cy_GPIO_SetDrivemode+0xa>
10000cc0:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(value));
10000cc2:	230f      	movs	r3, #15
10000cc4:	0010      	movs	r0, r2
10000cc6:	4398      	bics	r0, r3
10000cc8:	d103      	bne.n	10000cd2 <Cy_GPIO_SetDrivemode+0x1a>
10000cca:	2a01      	cmp	r2, #1
10000ccc:	d001      	beq.n	10000cd2 <Cy_GPIO_SetDrivemode+0x1a>
10000cce:	2a09      	cmp	r2, #9
10000cd0:	d100      	bne.n	10000cd4 <Cy_GPIO_SetDrivemode+0x1c>
10000cd2:	be01      	bkpt	0x0001

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    pinType = CY_PRA_GET_PIN_PROT_TYPE(base, pinNum);
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    pinLoc = pinNum << CY_GPIO_DRIVE_MODE_OFFSET;
10000cd4:	0089      	lsls	r1, r1, #2
    {
        /* secure pin */
        tempReg = 0;
    }
#else
    tempReg = (GPIO_PRT_CFG(base) & ~(CY_GPIO_CFG_DM_MASK << pinLoc));
10000cd6:	4b07      	ldr	r3, [pc, #28]	; (10000cf4 <Cy_GPIO_SetDrivemode+0x3c>)
10000cd8:	6818      	ldr	r0, [r3, #0]
10000cda:	2381      	movs	r3, #129	; 0x81
10000cdc:	5cc0      	ldrb	r0, [r0, r3]
10000cde:	1900      	adds	r0, r0, r4
10000ce0:	6804      	ldr	r4, [r0, #0]
10000ce2:	3b72      	subs	r3, #114	; 0x72
10000ce4:	001d      	movs	r5, r3
10000ce6:	408d      	lsls	r5, r1
10000ce8:	43ac      	bics	r4, r5
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) && defined(CY_DEVICE_PSOC6ABLE2) */
    prtCfg = tempReg | ((value & CY_GPIO_CFG_DM_MASK) << pinLoc);
10000cea:	4013      	ands	r3, r2
10000cec:	408b      	lsls	r3, r1
10000cee:	4323      	orrs	r3, r4
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_CFG(base) = prtCfg;
10000cf0:	6003      	str	r3, [r0, #0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000cf2:	bd30      	pop	{r4, r5, pc}
10000cf4:	08000148 	.word	0x08000148

10000cf8 <Cy_GPIO_SetVtrip>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetVtrip
*
*******************************************************************************/
void Cy_GPIO_SetVtrip(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000cf8:	b530      	push	{r4, r5, lr}
10000cfa:	0003      	movs	r3, r0

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000cfc:	2907      	cmp	r1, #7
10000cfe:	d900      	bls.n	10000d02 <Cy_GPIO_SetVtrip+0xa>
10000d00:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000d02:	2a01      	cmp	r2, #1
10000d04:	d900      	bls.n	10000d08 <Cy_GPIO_SetVtrip+0x10>
10000d06:	be01      	bkpt	0x0001
    }
#else
    tempReg = GPIO_PRT_CFG_IN(base) & ~(CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK << pinNum);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg = GPIO_PRT_CFG_IN(base) & ~(CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK << pinNum);
10000d08:	4807      	ldr	r0, [pc, #28]	; (10000d28 <Cy_GPIO_SetVtrip+0x30>)
10000d0a:	6804      	ldr	r4, [r0, #0]
10000d0c:	2082      	movs	r0, #130	; 0x82
10000d0e:	5c20      	ldrb	r0, [r4, r0]
10000d10:	18c0      	adds	r0, r0, r3
10000d12:	6804      	ldr	r4, [r0, #0]
10000d14:	2301      	movs	r3, #1
10000d16:	001d      	movs	r5, r3
10000d18:	408d      	lsls	r5, r1
10000d1a:	43ac      	bics	r4, r5
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    cfgIn = tempReg | ((value & CY_GPIO_CFG_IN_VTRIP_SEL_0_MASK) << pinNum);
10000d1c:	4013      	ands	r3, r2
10000d1e:	408b      	lsls	r3, r1
10000d20:	4323      	orrs	r3, r4
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_CFG_IN(base) = cfgIn;
10000d22:	6003      	str	r3, [r0, #0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000d24:	bd30      	pop	{r4, r5, pc}
10000d26:	46c0      	nop			; (mov r8, r8)
10000d28:	08000148 	.word	0x08000148

10000d2c <Cy_GPIO_SetInterruptMask>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetInterruptMask
*
*******************************************************************************/
void Cy_GPIO_SetInterruptMask(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000d2c:	b530      	push	{r4, r5, lr}

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10000d2e:	2908      	cmp	r1, #8
10000d30:	d900      	bls.n	10000d34 <Cy_GPIO_SetInterruptMask+0x8>
10000d32:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(value));
10000d34:	2a01      	cmp	r2, #1
10000d36:	d900      	bls.n	10000d3a <Cy_GPIO_SetInterruptMask+0xe>
10000d38:	be01      	bkpt	0x0001
    }
#else
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg= GPIO_PRT_INTR_MASK(base) & ~(CY_GPIO_INTR_EN_MASK << pinNum);
10000d3a:	6984      	ldr	r4, [r0, #24]
10000d3c:	2301      	movs	r3, #1
10000d3e:	001d      	movs	r5, r3
10000d40:	408d      	lsls	r5, r1
10000d42:	43ac      	bics	r4, r5
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    intrMask = tempReg | ((value & CY_GPIO_INTR_EN_MASK) << pinNum);
10000d44:	4013      	ands	r3, r2
10000d46:	408b      	lsls	r3, r1
10000d48:	4323      	orrs	r3, r4
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_INTR_MASK(base) = intrMask;
10000d4a:	6183      	str	r3, [r0, #24]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000d4c:	bd30      	pop	{r4, r5, pc}
	...

10000d50 <Cy_GPIO_SetInterruptEdge>:
* \funcusage
* \snippet gpio/snippet/main.c snippet_Cy_GPIO_SetInterruptEdge
*
*******************************************************************************/
void Cy_GPIO_SetInterruptEdge(GPIO_PRT_Type* base, uint32_t pinNum, uint32_t value)
{
10000d50:	b530      	push	{r4, r5, lr}
10000d52:	0003      	movs	r3, r0

#if (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE)
    cy_en_pra_pin_prot_type_t pinType;
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    CY_ASSERT_L2(CY_GPIO_IS_FILTER_PIN_VALID(pinNum));
10000d54:	2908      	cmp	r1, #8
10000d56:	d900      	bls.n	10000d5a <Cy_GPIO_SetInterruptEdge+0xa>
10000d58:	be01      	bkpt	0x0001
    CY_ASSERT_L2(CY_GPIO_IS_INT_EDGE_VALID(value));
10000d5a:	2a03      	cmp	r2, #3
10000d5c:	d900      	bls.n	10000d60 <Cy_GPIO_SetInterruptEdge+0x10>
10000d5e:	be01      	bkpt	0x0001

    pinLoc = pinNum << CY_GPIO_INTR_CFG_OFFSET;
10000d60:	0049      	lsls	r1, r1, #1
    }
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
#endif /* defined(CY_DEVICE_PSOC6ABLE2) */
#else
    tempReg = GPIO_PRT_INTR_CFG(base) & ~(CY_GPIO_INTR_EDGE_MASK << pinLoc);
10000d62:	4807      	ldr	r0, [pc, #28]	; (10000d80 <Cy_GPIO_SetInterruptEdge+0x30>)
10000d64:	6804      	ldr	r4, [r0, #0]
10000d66:	2080      	movs	r0, #128	; 0x80
10000d68:	5c20      	ldrb	r0, [r4, r0]
10000d6a:	18c0      	adds	r0, r0, r3
10000d6c:	6804      	ldr	r4, [r0, #0]
10000d6e:	2303      	movs	r3, #3
10000d70:	001d      	movs	r5, r3
10000d72:	408d      	lsls	r5, r1
10000d74:	43ac      	bics	r4, r5
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */

    intrCfg = tempReg | ((value & CY_GPIO_INTR_EDGE_MASK) << pinLoc);
10000d76:	4013      	ands	r3, r2
10000d78:	408b      	lsls	r3, r1
10000d7a:	4323      	orrs	r3, r4
    else
    {
        /* Secure PIN can't be modified using register policy */
    }
#else
    GPIO_PRT_INTR_CFG(base) = intrCfg;
10000d7c:	6003      	str	r3, [r0, #0]
#endif /* (CY_CPU_CORTEX_M4) && defined(CY_DEVICE_SECURE) */
}
10000d7e:	bd30      	pop	{r4, r5, pc}
10000d80:	08000148 	.word	0x08000148

10000d84 <Cy_GPIO_Pin_Init>:
{
10000d84:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10000d86:	46ce      	mov	lr, r9
10000d88:	4647      	mov	r7, r8
10000d8a:	b580      	push	{r7, lr}
10000d8c:	0007      	movs	r7, r0
10000d8e:	000e      	movs	r6, r1
10000d90:	0014      	movs	r4, r2
    if ((NULL != base) && (NULL != config))
10000d92:	2800      	cmp	r0, #0
10000d94:	d100      	bne.n	10000d98 <Cy_GPIO_Pin_Init+0x14>
10000d96:	e0b1      	b.n	10000efc <Cy_GPIO_Pin_Init+0x178>
10000d98:	2a00      	cmp	r2, #0
10000d9a:	d100      	bne.n	10000d9e <Cy_GPIO_Pin_Init+0x1a>
10000d9c:	e0b0      	b.n	10000f00 <Cy_GPIO_Pin_Init+0x17c>
        CY_ASSERT_L2(CY_GPIO_IS_PIN_VALID(pinNum));
10000d9e:	2907      	cmp	r1, #7
10000da0:	d900      	bls.n	10000da4 <Cy_GPIO_Pin_Init+0x20>
10000da2:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->outVal));
10000da4:	6823      	ldr	r3, [r4, #0]
10000da6:	2b01      	cmp	r3, #1
10000da8:	d900      	bls.n	10000dac <Cy_GPIO_Pin_Init+0x28>
10000daa:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_DM_VALID(config->driveMode));
10000dac:	6863      	ldr	r3, [r4, #4]
10000dae:	220f      	movs	r2, #15
10000db0:	0019      	movs	r1, r3
10000db2:	4391      	bics	r1, r2
10000db4:	d103      	bne.n	10000dbe <Cy_GPIO_Pin_Init+0x3a>
10000db6:	2b01      	cmp	r3, #1
10000db8:	d001      	beq.n	10000dbe <Cy_GPIO_Pin_Init+0x3a>
10000dba:	2b09      	cmp	r3, #9
10000dbc:	d100      	bne.n	10000dc0 <Cy_GPIO_Pin_Init+0x3c>
10000dbe:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_HSIOM_VALID(config->hsiom));
10000dc0:	7a23      	ldrb	r3, [r4, #8]
10000dc2:	221f      	movs	r2, #31
10000dc4:	4393      	bics	r3, r2
10000dc6:	d000      	beq.n	10000dca <Cy_GPIO_Pin_Init+0x46>
10000dc8:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_INT_EDGE_VALID(config->intEdge));
10000dca:	68e3      	ldr	r3, [r4, #12]
10000dcc:	2b03      	cmp	r3, #3
10000dce:	d900      	bls.n	10000dd2 <Cy_GPIO_Pin_Init+0x4e>
10000dd0:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->intMask));
10000dd2:	6923      	ldr	r3, [r4, #16]
10000dd4:	2b01      	cmp	r3, #1
10000dd6:	d900      	bls.n	10000dda <Cy_GPIO_Pin_Init+0x56>
10000dd8:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vtrip));
10000dda:	6963      	ldr	r3, [r4, #20]
10000ddc:	2b01      	cmp	r3, #1
10000dde:	d900      	bls.n	10000de2 <Cy_GPIO_Pin_Init+0x5e>
10000de0:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vregEn));
10000de2:	6a23      	ldr	r3, [r4, #32]
10000de4:	2b01      	cmp	r3, #1
10000de6:	d900      	bls.n	10000dea <Cy_GPIO_Pin_Init+0x66>
10000de8:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->ibufMode));
10000dea:	6a63      	ldr	r3, [r4, #36]	; 0x24
10000dec:	2b01      	cmp	r3, #1
10000dee:	d900      	bls.n	10000df2 <Cy_GPIO_Pin_Init+0x6e>
10000df0:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->vtripSel));
10000df2:	6aa3      	ldr	r3, [r4, #40]	; 0x28
10000df4:	2b01      	cmp	r3, #1
10000df6:	d900      	bls.n	10000dfa <Cy_GPIO_Pin_Init+0x76>
10000df8:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VREF_SEL_VALID(config->vrefSel));
10000dfa:	6ae3      	ldr	r3, [r4, #44]	; 0x2c
10000dfc:	2b03      	cmp	r3, #3
10000dfe:	d900      	bls.n	10000e02 <Cy_GPIO_Pin_Init+0x7e>
10000e00:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VOH_SEL_VALID(config->vohSel));
10000e02:	6b23      	ldr	r3, [r4, #48]	; 0x30
10000e04:	2b07      	cmp	r3, #7
10000e06:	d900      	bls.n	10000e0a <Cy_GPIO_Pin_Init+0x86>
10000e08:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_DRIVE_SEL_VALID(config->driveSel));
10000e0a:	69e3      	ldr	r3, [r4, #28]
10000e0c:	2b03      	cmp	r3, #3
10000e0e:	d900      	bls.n	10000e12 <Cy_GPIO_Pin_Init+0x8e>
10000e10:	be01      	bkpt	0x0001
        CY_ASSERT_L2(CY_GPIO_IS_VALUE_VALID(config->slewRate));
10000e12:	69a3      	ldr	r3, [r4, #24]
10000e14:	2b01      	cmp	r3, #1
10000e16:	d900      	bls.n	10000e1a <Cy_GPIO_Pin_Init+0x96>
10000e18:	be01      	bkpt	0x0001
        maskCfgOut = (CY_GPIO_CFG_OUT_SLOW_MASK << pinNum)
10000e1a:	2501      	movs	r5, #1
10000e1c:	002b      	movs	r3, r5
10000e1e:	40b3      	lsls	r3, r6
                     | (CY_GPIO_CFG_OUT_DRIVE_SEL_MASK << ((uint32_t)(pinNum << 1U) + CY_GPIO_CFG_OUT_DRIVE_OFFSET));
10000e20:	0070      	lsls	r0, r6, #1
10000e22:	3010      	adds	r0, #16
10000e24:	2203      	movs	r2, #3
10000e26:	4691      	mov	r9, r2
10000e28:	0011      	movs	r1, r2
10000e2a:	4081      	lsls	r1, r0
        maskCfgOut = (CY_GPIO_CFG_OUT_SLOW_MASK << pinNum)
10000e2c:	430b      	orrs	r3, r1
10000e2e:	469c      	mov	ip, r3
        tempReg = GPIO_PRT_CFG_OUT(base) & ~(maskCfgOut);
10000e30:	4b34      	ldr	r3, [pc, #208]	; (10000f04 <Cy_GPIO_Pin_Init+0x180>)
10000e32:	4698      	mov	r8, r3
10000e34:	2383      	movs	r3, #131	; 0x83
10000e36:	4641      	mov	r1, r8
10000e38:	6809      	ldr	r1, [r1, #0]
10000e3a:	5cc9      	ldrb	r1, [r1, r3]
10000e3c:	19c9      	adds	r1, r1, r7
10000e3e:	680b      	ldr	r3, [r1, #0]
10000e40:	4662      	mov	r2, ip
10000e42:	4393      	bics	r3, r2
10000e44:	469c      	mov	ip, r3
        tempReg2 = tempReg | ((config->slewRate & CY_GPIO_CFG_OUT_SLOW_MASK) << pinNum)
10000e46:	69a3      	ldr	r3, [r4, #24]
10000e48:	402b      	ands	r3, r5
10000e4a:	40b3      	lsls	r3, r6
10000e4c:	4662      	mov	r2, ip
10000e4e:	4313      	orrs	r3, r2
10000e50:	469c      	mov	ip, r3
                            | ((config->driveSel & CY_GPIO_CFG_OUT_DRIVE_SEL_MASK) << ((uint32_t)(pinNum << 1U) + CY_GPIO_CFG_OUT_DRIVE_OFFSET));
10000e52:	69e2      	ldr	r2, [r4, #28]
10000e54:	464b      	mov	r3, r9
10000e56:	4013      	ands	r3, r2
10000e58:	001a      	movs	r2, r3
10000e5a:	4082      	lsls	r2, r0
        tempReg2 = tempReg | ((config->slewRate & CY_GPIO_CFG_OUT_SLOW_MASK) << pinNum)
10000e5c:	4663      	mov	r3, ip
10000e5e:	4313      	orrs	r3, r2
        GPIO_PRT_CFG_OUT(base) = tempReg2;
10000e60:	600b      	str	r3, [r1, #0]
        Cy_GPIO_SetHSIOM(base, pinNum, config->hsiom);
10000e62:	7a22      	ldrb	r2, [r4, #8]
10000e64:	0031      	movs	r1, r6
10000e66:	0038      	movs	r0, r7
10000e68:	f7ff fee4 	bl	10000c34 <Cy_GPIO_SetHSIOM>
        Cy_GPIO_SetDrivemode(base, pinNum, config->driveMode);
10000e6c:	6862      	ldr	r2, [r4, #4]
10000e6e:	0031      	movs	r1, r6
10000e70:	0038      	movs	r0, r7
10000e72:	f7ff ff21 	bl	10000cb8 <Cy_GPIO_SetDrivemode>
        Cy_GPIO_SetInterruptEdge(base, pinNum, config->intEdge);
10000e76:	68e2      	ldr	r2, [r4, #12]
10000e78:	0031      	movs	r1, r6
10000e7a:	0038      	movs	r0, r7
10000e7c:	f7ff ff68 	bl	10000d50 <Cy_GPIO_SetInterruptEdge>
        Cy_GPIO_SetInterruptMask(base, pinNum, config->intMask);
10000e80:	6922      	ldr	r2, [r4, #16]
10000e82:	0031      	movs	r1, r6
10000e84:	0038      	movs	r0, r7
10000e86:	f7ff ff51 	bl	10000d2c <Cy_GPIO_SetInterruptMask>
        Cy_GPIO_SetVtrip(base, pinNum, config->vtrip);
10000e8a:	6962      	ldr	r2, [r4, #20]
10000e8c:	0031      	movs	r1, r6
10000e8e:	0038      	movs	r0, r7
10000e90:	f7ff ff32 	bl	10000cf8 <Cy_GPIO_SetVtrip>
        tempReg = GPIO_PRT_CFG_SIO(base) & ~(CY_GPIO_SIO_PIN_MASK);
10000e94:	4643      	mov	r3, r8
10000e96:	681a      	ldr	r2, [r3, #0]
10000e98:	2384      	movs	r3, #132	; 0x84
10000e9a:	5cd2      	ldrb	r2, [r2, r3]
10000e9c:	18ba      	adds	r2, r7, r2
10000e9e:	6810      	ldr	r0, [r2, #0]
10000ea0:	337b      	adds	r3, #123	; 0x7b
10000ea2:	4698      	mov	r8, r3
10000ea4:	4398      	bics	r0, r3
        tempReg2 = tempReg | (((config->vregEn & CY_GPIO_VREG_EN_MASK)
10000ea6:	6a23      	ldr	r3, [r4, #32]
10000ea8:	401d      	ands	r5, r3
                                         | ((config->ibufMode & CY_GPIO_IBUF_MASK) << CY_GPIO_IBUF_SHIFT)
10000eaa:	6a63      	ldr	r3, [r4, #36]	; 0x24
10000eac:	005b      	lsls	r3, r3, #1
10000eae:	469c      	mov	ip, r3
10000eb0:	2302      	movs	r3, #2
10000eb2:	4661      	mov	r1, ip
10000eb4:	400b      	ands	r3, r1
10000eb6:	431d      	orrs	r5, r3
                                         | ((config->vtripSel & CY_GPIO_VTRIP_SEL_MASK) << CY_GPIO_VTRIP_SEL_SHIFT)
10000eb8:	6aa3      	ldr	r3, [r4, #40]	; 0x28
10000eba:	009b      	lsls	r3, r3, #2
10000ebc:	469c      	mov	ip, r3
10000ebe:	2304      	movs	r3, #4
10000ec0:	4661      	mov	r1, ip
10000ec2:	400b      	ands	r3, r1
10000ec4:	432b      	orrs	r3, r5
                                         | ((config->vrefSel & CY_GPIO_VREF_SEL_MASK)  << CY_GPIO_VREF_SEL_SHIFT)
10000ec6:	6ae1      	ldr	r1, [r4, #44]	; 0x2c
10000ec8:	00c9      	lsls	r1, r1, #3
10000eca:	2518      	movs	r5, #24
10000ecc:	400d      	ands	r5, r1
10000ece:	432b      	orrs	r3, r5
                                         | ((config->vohSel & CY_GPIO_VOH_SEL_MASK) << CY_GPIO_VOH_SEL_SHIFT))
10000ed0:	6b21      	ldr	r1, [r4, #48]	; 0x30
10000ed2:	014d      	lsls	r5, r1, #5
10000ed4:	4641      	mov	r1, r8
10000ed6:	4029      	ands	r1, r5
10000ed8:	430b      	orrs	r3, r1
                                           << ((pinNum & CY_GPIO_SIO_ODD_PIN_MASK) << CY_GPIO_CFG_SIO_OFFSET));
10000eda:	00b1      	lsls	r1, r6, #2
10000edc:	25fe      	movs	r5, #254	; 0xfe
10000ede:	00ad      	lsls	r5, r5, #2
10000ee0:	4029      	ands	r1, r5
10000ee2:	408b      	lsls	r3, r1
        tempReg2 = tempReg | (((config->vregEn & CY_GPIO_VREG_EN_MASK)
10000ee4:	4303      	orrs	r3, r0
        GPIO_PRT_CFG_SIO(base) = tempReg2;
10000ee6:	6013      	str	r3, [r2, #0]
        Cy_GPIO_Write(base, pinNum, config->outVal);
10000ee8:	6822      	ldr	r2, [r4, #0]
10000eea:	0031      	movs	r1, r6
10000eec:	0038      	movs	r0, r7
10000eee:	f7ff fecd 	bl	10000c8c <Cy_GPIO_Write>
        status = CY_GPIO_SUCCESS;
10000ef2:	2000      	movs	r0, #0
}
10000ef4:	bcc0      	pop	{r6, r7}
10000ef6:	46b9      	mov	r9, r7
10000ef8:	46b0      	mov	r8, r6
10000efa:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
    cy_en_gpio_status_t status = CY_GPIO_BAD_PARAM;
10000efc:	4802      	ldr	r0, [pc, #8]	; (10000f08 <Cy_GPIO_Pin_Init+0x184>)
10000efe:	e7f9      	b.n	10000ef4 <Cy_GPIO_Pin_Init+0x170>
10000f00:	4801      	ldr	r0, [pc, #4]	; (10000f08 <Cy_GPIO_Pin_Init+0x184>)
    return(status);
10000f02:	e7f7      	b.n	10000ef4 <Cy_GPIO_Pin_Init+0x170>
10000f04:	08000148 	.word	0x08000148
10000f08:	005a0001 	.word	0x005a0001

10000f0c <Cy_SysLib_Delay>:
#ifndef CY_SYSLIB_DELAY_CALIBRATION_FACTOR
#define CY_SYSLIB_DELAY_CALIBRATION_FACTOR     1U
#endif

void Cy_SysLib_Delay(uint32_t milliseconds)
{
10000f0c:	b510      	push	{r4, lr}
10000f0e:	0004      	movs	r4, r0
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
10000f10:	e006      	b.n	10000f20 <Cy_SysLib_Delay+0x14>
    {
        /* This loop prevents an overflow in value passed to Cy_SysLib_DelayCycles() API.
         * At 100 MHz, (milliseconds * cy_delayFreqKhz) product overflows
         * in case if milliseconds parameter is more than 42 seconds.
         */
        Cy_SysLib_DelayCycles(cy_delay32kMs);
10000f12:	4b08      	ldr	r3, [pc, #32]	; (10000f34 <Cy_SysLib_Delay+0x28>)
10000f14:	6818      	ldr	r0, [r3, #0]
10000f16:	f000 f82f 	bl	10000f78 <Cy_SysLib_DelayCycles>
        milliseconds -= CY_DELAY_MS_OVERFLOW;
10000f1a:	4b07      	ldr	r3, [pc, #28]	; (10000f38 <Cy_SysLib_Delay+0x2c>)
10000f1c:	469c      	mov	ip, r3
10000f1e:	4464      	add	r4, ip
    while(milliseconds > CY_DELAY_MS_OVERFLOW)
10000f20:	2380      	movs	r3, #128	; 0x80
10000f22:	021b      	lsls	r3, r3, #8
10000f24:	429c      	cmp	r4, r3
10000f26:	d8f4      	bhi.n	10000f12 <Cy_SysLib_Delay+0x6>
    }

    Cy_SysLib_DelayCycles(milliseconds * cy_delayFreqKhz * CY_SYSLIB_DELAY_CALIBRATION_FACTOR);
10000f28:	4b04      	ldr	r3, [pc, #16]	; (10000f3c <Cy_SysLib_Delay+0x30>)
10000f2a:	6818      	ldr	r0, [r3, #0]
10000f2c:	4360      	muls	r0, r4
10000f2e:	f000 f823 	bl	10000f78 <Cy_SysLib_DelayCycles>
}
10000f32:	bd10      	pop	{r4, pc}
10000f34:	0800008c 	.word	0x0800008c
10000f38:	ffff8000 	.word	0xffff8000
10000f3c:	08000090 	.word	0x08000090

10000f40 <Cy_SysLib_ProcessingFault>:
         * Otherwise, the compiler destroys the call stack,
         * because treats this API as a no return function.
         */
        Cy_SysLib_AsmInfiniteLoop();
    #else
        while(true) {}
10000f40:	e7fe      	b.n	10000f40 <Cy_SysLib_ProcessingFault>
	...

10000f44 <Cy_SysLib_FaultHandler>:
{
10000f44:	b510      	push	{r4, lr}
    cy_faultFrame.r0  = faultStackAddr[CY_R0_Pos];
10000f46:	4b0a      	ldr	r3, [pc, #40]	; (10000f70 <Cy_SysLib_FaultHandler+0x2c>)
10000f48:	6802      	ldr	r2, [r0, #0]
10000f4a:	61da      	str	r2, [r3, #28]
    cy_faultFrame.r1  = faultStackAddr[CY_R1_Pos];
10000f4c:	6842      	ldr	r2, [r0, #4]
10000f4e:	621a      	str	r2, [r3, #32]
    cy_faultFrame.r2  = faultStackAddr[CY_R2_Pos];
10000f50:	6882      	ldr	r2, [r0, #8]
10000f52:	625a      	str	r2, [r3, #36]	; 0x24
    cy_faultFrame.r3  = faultStackAddr[CY_R3_Pos];
10000f54:	68c2      	ldr	r2, [r0, #12]
10000f56:	629a      	str	r2, [r3, #40]	; 0x28
    cy_faultFrame.r12 = faultStackAddr[CY_R12_Pos];
10000f58:	6902      	ldr	r2, [r0, #16]
10000f5a:	62da      	str	r2, [r3, #44]	; 0x2c
    cy_faultFrame.lr  = faultStackAddr[CY_LR_Pos];
10000f5c:	6942      	ldr	r2, [r0, #20]
10000f5e:	631a      	str	r2, [r3, #48]	; 0x30
    cy_faultFrame.pc  = faultStackAddr[CY_PC_Pos];
10000f60:	6982      	ldr	r2, [r0, #24]
10000f62:	635a      	str	r2, [r3, #52]	; 0x34
    cy_faultFrame.psr = faultStackAddr[CY_PSR_Pos];
10000f64:	69c2      	ldr	r2, [r0, #28]
10000f66:	639a      	str	r2, [r3, #56]	; 0x38
    Cy_SysLib_ProcessingFault();
10000f68:	f7ff ffea 	bl	10000f40 <Cy_SysLib_ProcessingFault>
}
10000f6c:	bd10      	pop	{r4, pc}
10000f6e:	46c0      	nop			; (mov r8, r8)
10000f70:	080000f0 	.word	0x080000f0
10000f74:	00000000 	.word	0x00000000

10000f78 <Cy_SysLib_DelayCycles>:
.func Cy_SysLib_DelayCycles, Cy_SysLib_DelayCycles
.type Cy_SysLib_DelayCycles, %function
.thumb_func
Cy_SysLib_DelayCycles:      /* cycles bytes */

    ADDS r0, r0, #2         /*    1    2    Round to nearest multiple of 4 */
10000f78:	3002      	adds	r0, #2
    LSRS r0, r0, #2         /*    1    2    Divide by 4 and set flags */
10000f7a:	0880      	lsrs	r0, r0, #2
    BEQ Cy_DelayCycles_done /*    2    2    Skip if 0 */
10000f7c:	d003      	beq.n	10000f86 <Cy_DelayCycles_done>

10000f7e <Cy_DelayCycles_loop>:

Cy_DelayCycles_loop:
    ADDS r0, r0, #1         /*    1    2    Increment counter */
10000f7e:	3001      	adds	r0, #1
    SUBS r0, r0, #2         /*    1    2    Decrement counter by 2 */
10000f80:	3802      	subs	r0, #2
    BNE Cy_DelayCycles_loop /*   (1)2  2    2 CPU cycles (if branch is taken) */
10000f82:	d1fc      	bne.n	10000f7e <Cy_DelayCycles_loop>
    NOP                     /*    1    2    Loop alignment padding */
10000f84:	46c0      	nop			; (mov r8, r8)

10000f86 <Cy_DelayCycles_done>:

Cy_DelayCycles_done:
    NOP                     /*    1    2    Loop alignment padding */
10000f86:	46c0      	nop			; (mov r8, r8)
    BX lr                   /*    3    2 */
10000f88:	4770      	bx	lr

10000f8a <Cy_SysLib_EnterCriticalSection>:
.func Cy_SysLib_EnterCriticalSection, Cy_SysLib_EnterCriticalSection
.type Cy_SysLib_EnterCriticalSection, %function
.thumb_func

Cy_SysLib_EnterCriticalSection:
    MRS r0, PRIMASK         /* Save and return interrupt state */
10000f8a:	f3ef 8010 	mrs	r0, PRIMASK
    cpsid i                 /* Disable interrupts */
10000f8e:	b672      	cpsid	i
    BX lr
10000f90:	4770      	bx	lr

10000f92 <Cy_SysLib_ExitCriticalSection>:
.func Cy_SysLib_ExitCriticalSection, Cy_SysLib_ExitCriticalSection
.type Cy_SysLib_ExitCriticalSection, %function
.thumb_func

Cy_SysLib_ExitCriticalSection:
    MSR PRIMASK, r0         /* Restore interrupt state */
10000f92:	f380 8810 	msr	PRIMASK, r0
    BX lr
10000f96:	4770      	bx	lr

10000f98 <main>:
        /*.vohSel =*/       0UL                     /* SIO-specific setting - ignored */
    };
    

int main(void)
{
10000f98:	b510      	push	{r4, lr}
  \details Enables IRQ interrupts by clearing the I-bit in the CPSR.
           Can only be executed in Privileged modes.
 */
__STATIC_FORCEINLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i" : : : "memory");
10000f9a:	b662      	cpsie	i
    /* Enable global interrupts */
    __enable_irq();

    Cy_GPIO_Pin_Init(P13_7_PORT, P13_7_PIN, &pinConfig);
10000f9c:	4a06      	ldr	r2, [pc, #24]	; (10000fb8 <main+0x20>)
10000f9e:	2107      	movs	r1, #7
10000fa0:	4806      	ldr	r0, [pc, #24]	; (10000fbc <main+0x24>)
10000fa2:	f7ff feef 	bl	10000d84 <Cy_GPIO_Pin_Init>

    
    while (1) {
        Cy_GPIO_Inv(P13_7_PORT, P13_7_PIN);
10000fa6:	2107      	movs	r1, #7
10000fa8:	4804      	ldr	r0, [pc, #16]	; (10000fbc <main+0x24>)
10000faa:	f7ff fe7d 	bl	10000ca8 <Cy_GPIO_Inv>
        Cy_SysLib_Delay(1000);
10000fae:	20fa      	movs	r0, #250	; 0xfa
10000fb0:	0080      	lsls	r0, r0, #2
10000fb2:	f7ff ffab 	bl	10000f0c <Cy_SysLib_Delay>
    while (1) {
10000fb6:	e7f6      	b.n	10000fa6 <main+0xe>
10000fb8:	08000098 	.word	0x08000098
10000fbc:	40310680 	.word	0x40310680

10000fc0 <__udivsi3>:
10000fc0:	2200      	movs	r2, #0
10000fc2:	0843      	lsrs	r3, r0, #1
10000fc4:	428b      	cmp	r3, r1
10000fc6:	d374      	bcc.n	100010b2 <__udivsi3+0xf2>
10000fc8:	0903      	lsrs	r3, r0, #4
10000fca:	428b      	cmp	r3, r1
10000fcc:	d35f      	bcc.n	1000108e <__udivsi3+0xce>
10000fce:	0a03      	lsrs	r3, r0, #8
10000fd0:	428b      	cmp	r3, r1
10000fd2:	d344      	bcc.n	1000105e <__udivsi3+0x9e>
10000fd4:	0b03      	lsrs	r3, r0, #12
10000fd6:	428b      	cmp	r3, r1
10000fd8:	d328      	bcc.n	1000102c <__udivsi3+0x6c>
10000fda:	0c03      	lsrs	r3, r0, #16
10000fdc:	428b      	cmp	r3, r1
10000fde:	d30d      	bcc.n	10000ffc <__udivsi3+0x3c>
10000fe0:	22ff      	movs	r2, #255	; 0xff
10000fe2:	0209      	lsls	r1, r1, #8
10000fe4:	ba12      	rev	r2, r2
10000fe6:	0c03      	lsrs	r3, r0, #16
10000fe8:	428b      	cmp	r3, r1
10000fea:	d302      	bcc.n	10000ff2 <__udivsi3+0x32>
10000fec:	1212      	asrs	r2, r2, #8
10000fee:	0209      	lsls	r1, r1, #8
10000ff0:	d065      	beq.n	100010be <__udivsi3+0xfe>
10000ff2:	0b03      	lsrs	r3, r0, #12
10000ff4:	428b      	cmp	r3, r1
10000ff6:	d319      	bcc.n	1000102c <__udivsi3+0x6c>
10000ff8:	e000      	b.n	10000ffc <__udivsi3+0x3c>
10000ffa:	0a09      	lsrs	r1, r1, #8
10000ffc:	0bc3      	lsrs	r3, r0, #15
10000ffe:	428b      	cmp	r3, r1
10001000:	d301      	bcc.n	10001006 <__udivsi3+0x46>
10001002:	03cb      	lsls	r3, r1, #15
10001004:	1ac0      	subs	r0, r0, r3
10001006:	4152      	adcs	r2, r2
10001008:	0b83      	lsrs	r3, r0, #14
1000100a:	428b      	cmp	r3, r1
1000100c:	d301      	bcc.n	10001012 <__udivsi3+0x52>
1000100e:	038b      	lsls	r3, r1, #14
10001010:	1ac0      	subs	r0, r0, r3
10001012:	4152      	adcs	r2, r2
10001014:	0b43      	lsrs	r3, r0, #13
10001016:	428b      	cmp	r3, r1
10001018:	d301      	bcc.n	1000101e <__udivsi3+0x5e>
1000101a:	034b      	lsls	r3, r1, #13
1000101c:	1ac0      	subs	r0, r0, r3
1000101e:	4152      	adcs	r2, r2
10001020:	0b03      	lsrs	r3, r0, #12
10001022:	428b      	cmp	r3, r1
10001024:	d301      	bcc.n	1000102a <__udivsi3+0x6a>
10001026:	030b      	lsls	r3, r1, #12
10001028:	1ac0      	subs	r0, r0, r3
1000102a:	4152      	adcs	r2, r2
1000102c:	0ac3      	lsrs	r3, r0, #11
1000102e:	428b      	cmp	r3, r1
10001030:	d301      	bcc.n	10001036 <__udivsi3+0x76>
10001032:	02cb      	lsls	r3, r1, #11
10001034:	1ac0      	subs	r0, r0, r3
10001036:	4152      	adcs	r2, r2
10001038:	0a83      	lsrs	r3, r0, #10
1000103a:	428b      	cmp	r3, r1
1000103c:	d301      	bcc.n	10001042 <__udivsi3+0x82>
1000103e:	028b      	lsls	r3, r1, #10
10001040:	1ac0      	subs	r0, r0, r3
10001042:	4152      	adcs	r2, r2
10001044:	0a43      	lsrs	r3, r0, #9
10001046:	428b      	cmp	r3, r1
10001048:	d301      	bcc.n	1000104e <__udivsi3+0x8e>
1000104a:	024b      	lsls	r3, r1, #9
1000104c:	1ac0      	subs	r0, r0, r3
1000104e:	4152      	adcs	r2, r2
10001050:	0a03      	lsrs	r3, r0, #8
10001052:	428b      	cmp	r3, r1
10001054:	d301      	bcc.n	1000105a <__udivsi3+0x9a>
10001056:	020b      	lsls	r3, r1, #8
10001058:	1ac0      	subs	r0, r0, r3
1000105a:	4152      	adcs	r2, r2
1000105c:	d2cd      	bcs.n	10000ffa <__udivsi3+0x3a>
1000105e:	09c3      	lsrs	r3, r0, #7
10001060:	428b      	cmp	r3, r1
10001062:	d301      	bcc.n	10001068 <__udivsi3+0xa8>
10001064:	01cb      	lsls	r3, r1, #7
10001066:	1ac0      	subs	r0, r0, r3
10001068:	4152      	adcs	r2, r2
1000106a:	0983      	lsrs	r3, r0, #6
1000106c:	428b      	cmp	r3, r1
1000106e:	d301      	bcc.n	10001074 <__udivsi3+0xb4>
10001070:	018b      	lsls	r3, r1, #6
10001072:	1ac0      	subs	r0, r0, r3
10001074:	4152      	adcs	r2, r2
10001076:	0943      	lsrs	r3, r0, #5
10001078:	428b      	cmp	r3, r1
1000107a:	d301      	bcc.n	10001080 <__udivsi3+0xc0>
1000107c:	014b      	lsls	r3, r1, #5
1000107e:	1ac0      	subs	r0, r0, r3
10001080:	4152      	adcs	r2, r2
10001082:	0903      	lsrs	r3, r0, #4
10001084:	428b      	cmp	r3, r1
10001086:	d301      	bcc.n	1000108c <__udivsi3+0xcc>
10001088:	010b      	lsls	r3, r1, #4
1000108a:	1ac0      	subs	r0, r0, r3
1000108c:	4152      	adcs	r2, r2
1000108e:	08c3      	lsrs	r3, r0, #3
10001090:	428b      	cmp	r3, r1
10001092:	d301      	bcc.n	10001098 <__udivsi3+0xd8>
10001094:	00cb      	lsls	r3, r1, #3
10001096:	1ac0      	subs	r0, r0, r3
10001098:	4152      	adcs	r2, r2
1000109a:	0883      	lsrs	r3, r0, #2
1000109c:	428b      	cmp	r3, r1
1000109e:	d301      	bcc.n	100010a4 <__udivsi3+0xe4>
100010a0:	008b      	lsls	r3, r1, #2
100010a2:	1ac0      	subs	r0, r0, r3
100010a4:	4152      	adcs	r2, r2
100010a6:	0843      	lsrs	r3, r0, #1
100010a8:	428b      	cmp	r3, r1
100010aa:	d301      	bcc.n	100010b0 <__udivsi3+0xf0>
100010ac:	004b      	lsls	r3, r1, #1
100010ae:	1ac0      	subs	r0, r0, r3
100010b0:	4152      	adcs	r2, r2
100010b2:	1a41      	subs	r1, r0, r1
100010b4:	d200      	bcs.n	100010b8 <__udivsi3+0xf8>
100010b6:	4601      	mov	r1, r0
100010b8:	4152      	adcs	r2, r2
100010ba:	4610      	mov	r0, r2
100010bc:	4770      	bx	lr
100010be:	e7ff      	b.n	100010c0 <__udivsi3+0x100>
100010c0:	b501      	push	{r0, lr}
100010c2:	2000      	movs	r0, #0
100010c4:	f000 f806 	bl	100010d4 <__aeabi_idiv0>
100010c8:	bd02      	pop	{r1, pc}
100010ca:	46c0      	nop			; (mov r8, r8)

100010cc <__aeabi_uidivmod>:
100010cc:	2900      	cmp	r1, #0
100010ce:	d0f7      	beq.n	100010c0 <__udivsi3+0x100>
100010d0:	e776      	b.n	10000fc0 <__udivsi3>
100010d2:	4770      	bx	lr

100010d4 <__aeabi_idiv0>:
100010d4:	4770      	bx	lr
100010d6:	46c0      	nop			; (mov r8, r8)

100010d8 <__aeabi_uldivmod>:
100010d8:	2b00      	cmp	r3, #0
100010da:	d111      	bne.n	10001100 <__aeabi_uldivmod+0x28>
100010dc:	2a00      	cmp	r2, #0
100010de:	d10f      	bne.n	10001100 <__aeabi_uldivmod+0x28>
100010e0:	2900      	cmp	r1, #0
100010e2:	d100      	bne.n	100010e6 <__aeabi_uldivmod+0xe>
100010e4:	2800      	cmp	r0, #0
100010e6:	d002      	beq.n	100010ee <__aeabi_uldivmod+0x16>
100010e8:	2100      	movs	r1, #0
100010ea:	43c9      	mvns	r1, r1
100010ec:	0008      	movs	r0, r1
100010ee:	b407      	push	{r0, r1, r2}
100010f0:	4802      	ldr	r0, [pc, #8]	; (100010fc <__aeabi_uldivmod+0x24>)
100010f2:	a102      	add	r1, pc, #8	; (adr r1, 100010fc <__aeabi_uldivmod+0x24>)
100010f4:	1840      	adds	r0, r0, r1
100010f6:	9002      	str	r0, [sp, #8]
100010f8:	bd03      	pop	{r0, r1, pc}
100010fa:	46c0      	nop			; (mov r8, r8)
100010fc:	ffffffd9 	.word	0xffffffd9
10001100:	b403      	push	{r0, r1}
10001102:	4668      	mov	r0, sp
10001104:	b501      	push	{r0, lr}
10001106:	9802      	ldr	r0, [sp, #8]
10001108:	f000 f834 	bl	10001174 <__udivmoddi4>
1000110c:	9b01      	ldr	r3, [sp, #4]
1000110e:	469e      	mov	lr, r3
10001110:	b002      	add	sp, #8
10001112:	bc0c      	pop	{r2, r3}
10001114:	4770      	bx	lr
10001116:	46c0      	nop			; (mov r8, r8)

10001118 <__aeabi_lmul>:
10001118:	b5f0      	push	{r4, r5, r6, r7, lr}
1000111a:	46ce      	mov	lr, r9
1000111c:	4647      	mov	r7, r8
1000111e:	b580      	push	{r7, lr}
10001120:	0007      	movs	r7, r0
10001122:	4699      	mov	r9, r3
10001124:	0c3b      	lsrs	r3, r7, #16
10001126:	469c      	mov	ip, r3
10001128:	0413      	lsls	r3, r2, #16
1000112a:	0c1b      	lsrs	r3, r3, #16
1000112c:	001d      	movs	r5, r3
1000112e:	000e      	movs	r6, r1
10001130:	4661      	mov	r1, ip
10001132:	0400      	lsls	r0, r0, #16
10001134:	0c14      	lsrs	r4, r2, #16
10001136:	0c00      	lsrs	r0, r0, #16
10001138:	4345      	muls	r5, r0
1000113a:	434b      	muls	r3, r1
1000113c:	4360      	muls	r0, r4
1000113e:	4361      	muls	r1, r4
10001140:	18c0      	adds	r0, r0, r3
10001142:	0c2c      	lsrs	r4, r5, #16
10001144:	1820      	adds	r0, r4, r0
10001146:	468c      	mov	ip, r1
10001148:	4283      	cmp	r3, r0
1000114a:	d903      	bls.n	10001154 <__aeabi_lmul+0x3c>
1000114c:	2380      	movs	r3, #128	; 0x80
1000114e:	025b      	lsls	r3, r3, #9
10001150:	4698      	mov	r8, r3
10001152:	44c4      	add	ip, r8
10001154:	4649      	mov	r1, r9
10001156:	4379      	muls	r1, r7
10001158:	4372      	muls	r2, r6
1000115a:	0c03      	lsrs	r3, r0, #16
1000115c:	4463      	add	r3, ip
1000115e:	042d      	lsls	r5, r5, #16
10001160:	0c2d      	lsrs	r5, r5, #16
10001162:	18c9      	adds	r1, r1, r3
10001164:	0400      	lsls	r0, r0, #16
10001166:	1940      	adds	r0, r0, r5
10001168:	1889      	adds	r1, r1, r2
1000116a:	bcc0      	pop	{r6, r7}
1000116c:	46b9      	mov	r9, r7
1000116e:	46b0      	mov	r8, r6
10001170:	bdf0      	pop	{r4, r5, r6, r7, pc}
10001172:	46c0      	nop			; (mov r8, r8)

10001174 <__udivmoddi4>:
10001174:	b5f0      	push	{r4, r5, r6, r7, lr}
10001176:	4657      	mov	r7, sl
10001178:	464e      	mov	r6, r9
1000117a:	4645      	mov	r5, r8
1000117c:	46de      	mov	lr, fp
1000117e:	b5e0      	push	{r5, r6, r7, lr}
10001180:	0004      	movs	r4, r0
10001182:	000d      	movs	r5, r1
10001184:	4692      	mov	sl, r2
10001186:	4699      	mov	r9, r3
10001188:	b083      	sub	sp, #12
1000118a:	428b      	cmp	r3, r1
1000118c:	d830      	bhi.n	100011f0 <__udivmoddi4+0x7c>
1000118e:	d02d      	beq.n	100011ec <__udivmoddi4+0x78>
10001190:	4649      	mov	r1, r9
10001192:	4650      	mov	r0, sl
10001194:	f000 f8ba 	bl	1000130c <__clzdi2>
10001198:	0029      	movs	r1, r5
1000119a:	0006      	movs	r6, r0
1000119c:	0020      	movs	r0, r4
1000119e:	f000 f8b5 	bl	1000130c <__clzdi2>
100011a2:	1a33      	subs	r3, r6, r0
100011a4:	4698      	mov	r8, r3
100011a6:	3b20      	subs	r3, #32
100011a8:	469b      	mov	fp, r3
100011aa:	d433      	bmi.n	10001214 <__udivmoddi4+0xa0>
100011ac:	465a      	mov	r2, fp
100011ae:	4653      	mov	r3, sl
100011b0:	4093      	lsls	r3, r2
100011b2:	4642      	mov	r2, r8
100011b4:	001f      	movs	r7, r3
100011b6:	4653      	mov	r3, sl
100011b8:	4093      	lsls	r3, r2
100011ba:	001e      	movs	r6, r3
100011bc:	42af      	cmp	r7, r5
100011be:	d83a      	bhi.n	10001236 <__udivmoddi4+0xc2>
100011c0:	42af      	cmp	r7, r5
100011c2:	d100      	bne.n	100011c6 <__udivmoddi4+0x52>
100011c4:	e078      	b.n	100012b8 <__udivmoddi4+0x144>
100011c6:	465b      	mov	r3, fp
100011c8:	1ba4      	subs	r4, r4, r6
100011ca:	41bd      	sbcs	r5, r7
100011cc:	2b00      	cmp	r3, #0
100011ce:	da00      	bge.n	100011d2 <__udivmoddi4+0x5e>
100011d0:	e075      	b.n	100012be <__udivmoddi4+0x14a>
100011d2:	2200      	movs	r2, #0
100011d4:	2300      	movs	r3, #0
100011d6:	9200      	str	r2, [sp, #0]
100011d8:	9301      	str	r3, [sp, #4]
100011da:	2301      	movs	r3, #1
100011dc:	465a      	mov	r2, fp
100011de:	4093      	lsls	r3, r2
100011e0:	9301      	str	r3, [sp, #4]
100011e2:	2301      	movs	r3, #1
100011e4:	4642      	mov	r2, r8
100011e6:	4093      	lsls	r3, r2
100011e8:	9300      	str	r3, [sp, #0]
100011ea:	e028      	b.n	1000123e <__udivmoddi4+0xca>
100011ec:	4282      	cmp	r2, r0
100011ee:	d9cf      	bls.n	10001190 <__udivmoddi4+0x1c>
100011f0:	2200      	movs	r2, #0
100011f2:	2300      	movs	r3, #0
100011f4:	9200      	str	r2, [sp, #0]
100011f6:	9301      	str	r3, [sp, #4]
100011f8:	9b0c      	ldr	r3, [sp, #48]	; 0x30
100011fa:	2b00      	cmp	r3, #0
100011fc:	d001      	beq.n	10001202 <__udivmoddi4+0x8e>
100011fe:	601c      	str	r4, [r3, #0]
10001200:	605d      	str	r5, [r3, #4]
10001202:	9800      	ldr	r0, [sp, #0]
10001204:	9901      	ldr	r1, [sp, #4]
10001206:	b003      	add	sp, #12
10001208:	bcf0      	pop	{r4, r5, r6, r7}
1000120a:	46bb      	mov	fp, r7
1000120c:	46b2      	mov	sl, r6
1000120e:	46a9      	mov	r9, r5
10001210:	46a0      	mov	r8, r4
10001212:	bdf0      	pop	{r4, r5, r6, r7, pc}
10001214:	4642      	mov	r2, r8
10001216:	2320      	movs	r3, #32
10001218:	1a9b      	subs	r3, r3, r2
1000121a:	4652      	mov	r2, sl
1000121c:	40da      	lsrs	r2, r3
1000121e:	4641      	mov	r1, r8
10001220:	0013      	movs	r3, r2
10001222:	464a      	mov	r2, r9
10001224:	408a      	lsls	r2, r1
10001226:	0017      	movs	r7, r2
10001228:	4642      	mov	r2, r8
1000122a:	431f      	orrs	r7, r3
1000122c:	4653      	mov	r3, sl
1000122e:	4093      	lsls	r3, r2
10001230:	001e      	movs	r6, r3
10001232:	42af      	cmp	r7, r5
10001234:	d9c4      	bls.n	100011c0 <__udivmoddi4+0x4c>
10001236:	2200      	movs	r2, #0
10001238:	2300      	movs	r3, #0
1000123a:	9200      	str	r2, [sp, #0]
1000123c:	9301      	str	r3, [sp, #4]
1000123e:	4643      	mov	r3, r8
10001240:	2b00      	cmp	r3, #0
10001242:	d0d9      	beq.n	100011f8 <__udivmoddi4+0x84>
10001244:	07fb      	lsls	r3, r7, #31
10001246:	0872      	lsrs	r2, r6, #1
10001248:	431a      	orrs	r2, r3
1000124a:	4646      	mov	r6, r8
1000124c:	087b      	lsrs	r3, r7, #1
1000124e:	e00e      	b.n	1000126e <__udivmoddi4+0xfa>
10001250:	42ab      	cmp	r3, r5
10001252:	d101      	bne.n	10001258 <__udivmoddi4+0xe4>
10001254:	42a2      	cmp	r2, r4
10001256:	d80c      	bhi.n	10001272 <__udivmoddi4+0xfe>
10001258:	1aa4      	subs	r4, r4, r2
1000125a:	419d      	sbcs	r5, r3
1000125c:	2001      	movs	r0, #1
1000125e:	1924      	adds	r4, r4, r4
10001260:	416d      	adcs	r5, r5
10001262:	2100      	movs	r1, #0
10001264:	3e01      	subs	r6, #1
10001266:	1824      	adds	r4, r4, r0
10001268:	414d      	adcs	r5, r1
1000126a:	2e00      	cmp	r6, #0
1000126c:	d006      	beq.n	1000127c <__udivmoddi4+0x108>
1000126e:	42ab      	cmp	r3, r5
10001270:	d9ee      	bls.n	10001250 <__udivmoddi4+0xdc>
10001272:	3e01      	subs	r6, #1
10001274:	1924      	adds	r4, r4, r4
10001276:	416d      	adcs	r5, r5
10001278:	2e00      	cmp	r6, #0
1000127a:	d1f8      	bne.n	1000126e <__udivmoddi4+0xfa>
1000127c:	9800      	ldr	r0, [sp, #0]
1000127e:	9901      	ldr	r1, [sp, #4]
10001280:	465b      	mov	r3, fp
10001282:	1900      	adds	r0, r0, r4
10001284:	4169      	adcs	r1, r5
10001286:	2b00      	cmp	r3, #0
10001288:	db24      	blt.n	100012d4 <__udivmoddi4+0x160>
1000128a:	002b      	movs	r3, r5
1000128c:	465a      	mov	r2, fp
1000128e:	4644      	mov	r4, r8
10001290:	40d3      	lsrs	r3, r2
10001292:	002a      	movs	r2, r5
10001294:	40e2      	lsrs	r2, r4
10001296:	001c      	movs	r4, r3
10001298:	465b      	mov	r3, fp
1000129a:	0015      	movs	r5, r2
1000129c:	2b00      	cmp	r3, #0
1000129e:	db2a      	blt.n	100012f6 <__udivmoddi4+0x182>
100012a0:	0026      	movs	r6, r4
100012a2:	409e      	lsls	r6, r3
100012a4:	0033      	movs	r3, r6
100012a6:	0026      	movs	r6, r4
100012a8:	4647      	mov	r7, r8
100012aa:	40be      	lsls	r6, r7
100012ac:	0032      	movs	r2, r6
100012ae:	1a80      	subs	r0, r0, r2
100012b0:	4199      	sbcs	r1, r3
100012b2:	9000      	str	r0, [sp, #0]
100012b4:	9101      	str	r1, [sp, #4]
100012b6:	e79f      	b.n	100011f8 <__udivmoddi4+0x84>
100012b8:	42a3      	cmp	r3, r4
100012ba:	d8bc      	bhi.n	10001236 <__udivmoddi4+0xc2>
100012bc:	e783      	b.n	100011c6 <__udivmoddi4+0x52>
100012be:	4642      	mov	r2, r8
100012c0:	2320      	movs	r3, #32
100012c2:	2100      	movs	r1, #0
100012c4:	1a9b      	subs	r3, r3, r2
100012c6:	2200      	movs	r2, #0
100012c8:	9100      	str	r1, [sp, #0]
100012ca:	9201      	str	r2, [sp, #4]
100012cc:	2201      	movs	r2, #1
100012ce:	40da      	lsrs	r2, r3
100012d0:	9201      	str	r2, [sp, #4]
100012d2:	e786      	b.n	100011e2 <__udivmoddi4+0x6e>
100012d4:	4642      	mov	r2, r8
100012d6:	2320      	movs	r3, #32
100012d8:	1a9b      	subs	r3, r3, r2
100012da:	002a      	movs	r2, r5
100012dc:	4646      	mov	r6, r8
100012de:	409a      	lsls	r2, r3
100012e0:	0023      	movs	r3, r4
100012e2:	40f3      	lsrs	r3, r6
100012e4:	4644      	mov	r4, r8
100012e6:	4313      	orrs	r3, r2
100012e8:	002a      	movs	r2, r5
100012ea:	40e2      	lsrs	r2, r4
100012ec:	001c      	movs	r4, r3
100012ee:	465b      	mov	r3, fp
100012f0:	0015      	movs	r5, r2
100012f2:	2b00      	cmp	r3, #0
100012f4:	dad4      	bge.n	100012a0 <__udivmoddi4+0x12c>
100012f6:	4642      	mov	r2, r8
100012f8:	002f      	movs	r7, r5
100012fa:	2320      	movs	r3, #32
100012fc:	0026      	movs	r6, r4
100012fe:	4097      	lsls	r7, r2
10001300:	1a9b      	subs	r3, r3, r2
10001302:	40de      	lsrs	r6, r3
10001304:	003b      	movs	r3, r7
10001306:	4333      	orrs	r3, r6
10001308:	e7cd      	b.n	100012a6 <__udivmoddi4+0x132>
1000130a:	46c0      	nop			; (mov r8, r8)

1000130c <__clzdi2>:
1000130c:	b510      	push	{r4, lr}
1000130e:	2900      	cmp	r1, #0
10001310:	d103      	bne.n	1000131a <__clzdi2+0xe>
10001312:	f000 f807 	bl	10001324 <__clzsi2>
10001316:	3020      	adds	r0, #32
10001318:	e002      	b.n	10001320 <__clzdi2+0x14>
1000131a:	0008      	movs	r0, r1
1000131c:	f000 f802 	bl	10001324 <__clzsi2>
10001320:	bd10      	pop	{r4, pc}
10001322:	46c0      	nop			; (mov r8, r8)

10001324 <__clzsi2>:
10001324:	211c      	movs	r1, #28
10001326:	2301      	movs	r3, #1
10001328:	041b      	lsls	r3, r3, #16
1000132a:	4298      	cmp	r0, r3
1000132c:	d301      	bcc.n	10001332 <__clzsi2+0xe>
1000132e:	0c00      	lsrs	r0, r0, #16
10001330:	3910      	subs	r1, #16
10001332:	0a1b      	lsrs	r3, r3, #8
10001334:	4298      	cmp	r0, r3
10001336:	d301      	bcc.n	1000133c <__clzsi2+0x18>
10001338:	0a00      	lsrs	r0, r0, #8
1000133a:	3908      	subs	r1, #8
1000133c:	091b      	lsrs	r3, r3, #4
1000133e:	4298      	cmp	r0, r3
10001340:	d301      	bcc.n	10001346 <__clzsi2+0x22>
10001342:	0900      	lsrs	r0, r0, #4
10001344:	3904      	subs	r1, #4
10001346:	a202      	add	r2, pc, #8	; (adr r2, 10001350 <__clzsi2+0x2c>)
10001348:	5c10      	ldrb	r0, [r2, r0]
1000134a:	1840      	adds	r0, r0, r1
1000134c:	4770      	bx	lr
1000134e:	46c0      	nop			; (mov r8, r8)
10001350:	02020304 	.word	0x02020304
10001354:	01010101 	.word	0x01010101
	...

10001360 <memset>:
10001360:	0003      	movs	r3, r0
10001362:	1882      	adds	r2, r0, r2
10001364:	4293      	cmp	r3, r2
10001366:	d100      	bne.n	1000136a <memset+0xa>
10001368:	4770      	bx	lr
1000136a:	7019      	strb	r1, [r3, #0]
1000136c:	3301      	adds	r3, #1
1000136e:	e7f9      	b.n	10001364 <memset+0x4>

10001370 <_init>:
10001370:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
10001372:	46c0      	nop			; (mov r8, r8)
10001374:	bcf8      	pop	{r3, r4, r5, r6, r7}
10001376:	bc08      	pop	{r3}
10001378:	469e      	mov	lr, r3
1000137a:	4770      	bx	lr

1000137c <_fini>:
1000137c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
1000137e:	46c0      	nop			; (mov r8, r8)
10001380:	bcf8      	pop	{r3, r4, r5, r6, r7}
10001382:	bc08      	pop	{r3}
10001384:	469e      	mov	lr, r3
10001386:	4770      	bx	lr

10001388 <cy_deviceIpBlockCfgPSoC6_02>:
10001388:	0000 4020 0000 4024 0000 4000 0000 0000     .. @..$@...@....
10001398:	0000 4023 0000 4030 0000 4031 0000 409f     ..#@..0@..1@...@
100013a8:	0000 4022 0000 4010 0000 409d 2020 2020     .."@...@...@    
100013b8:	1020 1010 1d10 801d 0017 0075 03ff 0206      .........u.....
100013c8:	0006 0436 2010 0000 c07f 0000 0400 0000     ..6.. ..........
100013d8:	0000 0000 1900 4b32 7d64 0000 0000 8000     ......2Kd}......
100013e8:	0040 0b08 0010 0000 0000 01ff 0220 1f00     @........... ...
100013f8:	8000 0400 08ff 1810 1000 1400 1800 1c00     ................
10001408:	4440 4c48 0050 0000 1008 0000 0008 0000     @DHLP...........
10001418:	0004 0000 1004 0000 1200 0000 2104 0000     .............!..
10001428:	2100 0000 1600 0000 1140 0240 13c4 1300     .!......@.@.....
10001438:	1380 13a0 1340 1388 13a8 0020 001c 0000     ....@..... .....

10001448 <systemIpcPipeConfigCm0.1>:
10001448:	0003 0000 0001 0000 0001 0000 0000 0000     ................
10001458:	0305 0060 0004 0000 0001 0000 0000 0000     ..`.............
10001468:	0001 0000 0406 0060 0008 0000 02bc 0800     ......`.........
10001478:	0a79 1000                                   y...

1000147c <__EH_FRAME_BEGIN__>:
1000147c:	0000 0000                                   ....
